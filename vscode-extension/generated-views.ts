// Auto-generated - DO NOT EDIT DIRECTLY
// Edit views/process-tree.js instead and run: node build-views.mjs

export const PROCESS_TREE_JS = "// 3D Process Tree Visualization\n// Shared between VS Code extension and local dev testing\n\n(function() {\n  'use strict';\n  \n  // Check if we're in VS Code webview or standalone\n  const isVSCode = typeof acquireVsCodeApi === 'function';\n  \n  // Show dev badge if not in VS Code\n  if (!isVSCode) {\n    const badge = document.createElement('div');\n    badge.className = 'dev-badge';\n    badge.textContent = 'DEV MODE';\n    document.body.appendChild(badge);\n  }\n  \n  const colors = {\n    'editor': 0xb06bff, 'tui': 0xff69b4, 'bridge': 0x6bff9f,\n    'db': 0xffeb6b, 'proxy': 0x6b9fff, 'ai': 0xff9f6b,\n    'shell': 0x6bffff, 'dev': 0x6bff9f, 'ide': 0x6b9fff, 'lsp': 0x888888\n  };\n  \n  let width = window.innerWidth, height = window.innerHeight;\n  let meshes = new Map(), connections = new Map(), ws;\n  let graveyard = [];\n  const MAX_GRAVEYARD = 30;\n  const GRAVEYARD_Y = -200;\n  \n  // Three.js setup\n  const scene = new THREE.Scene();\n  const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 5000);\n  camera.position.set(0, 150, 400);\n  camera.lookAt(0, 0, 0);\n  \n  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  \n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.05;\n  controls.minDistance = 20;\n  controls.maxDistance = 3000;\n  controls.enablePan = true;\n  controls.autoRotate = true;\n  controls.autoRotateSpeed = 0.3;\n  controls.target.set(0, 0, 0);\n  \n  let focusedPid = null;\n  let focusTarget = new THREE.Vector3(0, 0, 0);\n  let focusDistance = null;\n  let transitioning = false;\n  \n  // Tour mode state\n  let tourMode = false;\n  let tourIndex = 0;\n  let tourProcessList = [];\n  let tourAutoPlay = false;\n  let tourAutoPlayInterval = null;\n  const TOUR_SPEED = 2500; // ms between auto-advances\n  \n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n  \n  renderer.domElement.addEventListener('click', (e) => {\n    mouse.x = (e.clientX / width) * 2 - 1;\n    mouse.y = -(e.clientY / height) * 2 + 1;\n    \n    raycaster.setFromCamera(mouse, camera);\n    const meshArray = Array.from(meshes.values());\n    const intersects = raycaster.intersectObjects(meshArray);\n    \n    if (intersects.length > 0) {\n      const clicked = intersects[0].object;\n      const pid = clicked.userData.pid;\n      \n      if (focusedPid === String(pid)) {\n        focusedPid = null;\n        focusTarget.set(0, 0, 0);\n        focusDistance = null;\n      } else {\n        focusedPid = String(pid);\n        focusTarget.copy(clicked.position);\n        focusDistance = 80 + (clicked.userData.size || 6) * 3;\n      }\n      transitioning = true;\n      controls.autoRotate = true;\n    } else if (!e.shiftKey) {\n      focusedPid = null;\n      focusTarget.set(0, 0, 0);\n      focusDistance = null;\n      transitioning = true;\n    }\n  });\n  \n  renderer.domElement.addEventListener('dblclick', () => {\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    camera.position.set(0, 150, 400);\n  });\n  \n  // Tour Mode Functions\n  function updateTourUI() {\n    let tourUI = document.getElementById('tour-ui');\n    if (!tourUI) {\n      tourUI = document.createElement('div');\n      tourUI.id = 'tour-ui';\n      tourUI.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.85);padding:12px 20px;border-radius:8px;color:#fff;font-family:monospace;font-size:12px;z-index:1000;display:none;text-align:center;border:1px solid #444;';\n      document.body.appendChild(tourUI);\n    }\n    \n    if (tourMode && tourProcessList.length > 0) {\n      const current = tourProcessList[tourIndex];\n      const mesh = meshes.get(current);\n      const name = mesh?.userData?.name || current;\n      const icon = mesh?.userData?.icon || '‚óè';\n      const category = mesh?.userData?.category || '';\n      \n      tourUI.style.display = 'block';\n      tourUI.innerHTML = `\n        <div style=\"margin-bottom:8px;font-size:14px;color:#88ccff;\">üé¨ TOUR MODE</div>\n        <div style=\"font-size:18px;margin-bottom:4px;\">${icon} ${name}</div>\n        <div style=\"color:#888;margin-bottom:8px;\">${category} ‚Ä¢ ${tourIndex + 1}/${tourProcessList.length}</div>\n        <div style=\"color:#666;font-size:10px;\">\n          ‚Üê ‚Üí Navigate ‚Ä¢ Space ${tourAutoPlay ? 'Stop' : 'Auto'} ‚Ä¢ Esc Exit\n        </div>\n        ${tourAutoPlay ? '<div style=\"color:#6bff9f;margin-top:6px;\">‚ñ∂ Auto-playing...</div>' : ''}\n      `;\n      // Hide the hint when in tour mode\n      const hint = document.getElementById('tour-hint');\n      if (hint) hint.style.display = 'none';\n    } else {\n      tourUI.style.display = 'none';\n      // Show the hint when not in tour mode\n      const hint = document.getElementById('tour-hint');\n      if (hint) hint.style.display = 'block';\n    }\n  }\n  \n  function buildTourList() {\n    // Build ordered list: kernel first, then by category, then by tree depth\n    const categoryOrder = ['kernel', 'ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    const list = Array.from(meshes.keys());\n    \n    list.sort((a, b) => {\n      const meshA = meshes.get(a);\n      const meshB = meshes.get(b);\n      const catA = meshA?.userData?.category || 'zzz';\n      const catB = meshB?.userData?.category || 'zzz';\n      const orderA = categoryOrder.indexOf(catA);\n      const orderB = categoryOrder.indexOf(catB);\n      return (orderA === -1 ? 99 : orderA) - (orderB === -1 ? 99 : orderB);\n    });\n    \n    return list;\n  }\n  \n  function focusOnProcess(pid) {\n    const mesh = meshes.get(pid);\n    if (!mesh) return;\n    \n    focusedPid = pid;\n    focusTarget.copy(mesh.position);\n    focusDistance = 80 + (mesh.userData.size || 6) * 3;\n    transitioning = true;\n    controls.autoRotate = true;\n  }\n  \n  function startTour() {\n    tourMode = true;\n    tourProcessList = buildTourList();\n    tourIndex = 0;\n    if (tourProcessList.length > 0) {\n      focusOnProcess(tourProcessList[0]);\n    }\n    updateTourUI();\n  }\n  \n  function exitTour() {\n    tourMode = false;\n    tourAutoPlay = false;\n    if (tourAutoPlayInterval) {\n      clearInterval(tourAutoPlayInterval);\n      tourAutoPlayInterval = null;\n    }\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    updateTourUI();\n  }\n  \n  function tourNext() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex + 1) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function tourPrev() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex - 1 + tourProcessList.length) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function toggleAutoPlay() {\n    tourAutoPlay = !tourAutoPlay;\n    if (tourAutoPlay) {\n      tourAutoPlayInterval = setInterval(tourNext, TOUR_SPEED);\n    } else {\n      if (tourAutoPlayInterval) {\n        clearInterval(tourAutoPlayInterval);\n        tourAutoPlayInterval = null;\n      }\n    }\n    updateTourUI();\n  }\n  \n  // Keyboard controls\n  document.addEventListener('keydown', (e) => {\n    // T to start tour\n    if (e.key === 't' || e.key === 'T') {\n      if (!tourMode) {\n        startTour();\n      }\n      return;\n    }\n    \n    if (tourMode) {\n      switch(e.key) {\n        case 'ArrowRight':\n        case 'l':\n        case 'L':\n          tourNext();\n          e.preventDefault();\n          break;\n        case 'ArrowLeft':\n        case 'h':\n        case 'H':\n          tourPrev();\n          e.preventDefault();\n          break;\n        case ' ':\n          toggleAutoPlay();\n          e.preventDefault();\n          break;\n        case 'Escape':\n        case 'q':\n        case 'Q':\n          exitTour();\n          e.preventDefault();\n          break;\n      }\n    }\n  });\n  \n  let processTree = { roots: [], byPid: new Map() };\n  \n  let kernelMesh = null, kernelGlow = null, kernelCore = null;\n  function createKernelNode() {\n    const group = new THREE.Group();\n    \n    const outerGeo = new THREE.SphereGeometry(35, 32, 32);\n    const outerMat = new THREE.MeshBasicMaterial({\n      color: 0x4488ff, transparent: true, opacity: 0.15, wireframe: true\n    });\n    group.add(new THREE.Mesh(outerGeo, outerMat));\n    \n    const ringGeo = new THREE.TorusGeometry(25, 1.5, 8, 48);\n    const ringMat = new THREE.MeshBasicMaterial({\n      color: 0x66aaff, transparent: true, opacity: 0.4\n    });\n    const ring = new THREE.Mesh(ringGeo, ringMat);\n    ring.rotation.x = Math.PI / 2;\n    group.add(ring);\n    kernelGlow = ring;\n    \n    const coreGeo = new THREE.SphereGeometry(12, 24, 24);\n    const coreMat = new THREE.MeshBasicMaterial({\n      color: 0x88ccff, transparent: true, opacity: 0.7\n    });\n    const core = new THREE.Mesh(coreGeo, coreMat);\n    group.add(core);\n    kernelCore = core;\n    \n    group.userData = {\n      pid: 'kernel', name: 'Fedora Linux', icon: 'üêß', category: 'kernel',\n      cpu: 0, rss: 0, size: 35, targetPos: new THREE.Vector3(0, 0, 0), pulsePhase: 0\n    };\n    return group;\n  }\n  \n  kernelMesh = createKernelNode();\n  scene.add(kernelMesh);\n  meshes.set('kernel', kernelMesh);\n  \n  function createNodeMesh(node) {\n    const cpu = node.cpu || 0;\n    const memMB = (node.rss || 10000) / 1024;\n    const baseColor = colors[node.category] || 0x666666;\n    const size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + cpu * 0.1));\n    \n    const geo = new THREE.SphereGeometry(size, 12, 12);\n    const mat = new THREE.MeshBasicMaterial({\n      color: baseColor, transparent: true, opacity: 0.7 + cpu * 0.003\n    });\n    \n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.userData = { \n      ...node, size, baseColor, targetPos: new THREE.Vector3(),\n      pulsePhase: Math.random() * Math.PI * 2\n    };\n    return mesh;\n  }\n  \n  function createConnectionLine() {\n    const geo = new THREE.CylinderGeometry(1.5, 1.5, 1, 8);\n    const mat = new THREE.MeshBasicMaterial({\n      color: 0x444444, transparent: true, opacity: 0.5\n    });\n    return new THREE.Mesh(geo, mat);\n  }\n  \n  function updateConnectionMesh(conn, childPos, parentPos) {\n    const mesh = conn.line;\n    const mid = new THREE.Vector3().addVectors(childPos, parentPos).multiplyScalar(0.5);\n    mesh.position.copy(mid);\n    const dir = new THREE.Vector3().subVectors(parentPos, childPos);\n    const length = dir.length();\n    mesh.scale.set(1, length, 1);\n    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());\n  }\n  \n  function layoutTree(processes) {\n    const byPid = new Map();\n    const children = new Map();\n    \n    processes.forEach(p => {\n      byPid.set(String(p.pid), p);\n      children.set(String(p.pid), []);\n    });\n    \n    const roots = [];\n    processes.forEach(p => {\n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && byPid.has(parentPid)) {\n        children.get(parentPid).push(p);\n      } else {\n        roots.push(p);\n      }\n    });\n    \n    const categoryOrder = ['ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    roots.sort((a, b) => {\n      const ai = categoryOrder.indexOf(a.category);\n      const bi = categoryOrder.indexOf(b.category);\n      return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);\n    });\n    \n    const levelHeight = 50, baseRadius = 100;\n    \n    function countDescendants(pid) {\n      const nodeChildren = children.get(pid) || [];\n      let count = nodeChildren.length;\n      nodeChildren.forEach(c => count += countDescendants(String(c.pid)));\n      return count;\n    }\n    \n    function positionNode(node, depth, angle, radius, parentX, parentZ) {\n      const pid = String(node.pid);\n      const nodeChildren = children.get(pid) || [];\n      const childCount = nodeChildren.length;\n      \n      const x = parentX + Math.cos(angle) * radius;\n      const z = parentZ + Math.sin(angle) * radius;\n      \n      node.targetX = x;\n      node.targetY = -depth * levelHeight;\n      node.targetZ = z;\n      \n      if (childCount > 0) {\n        const arcSpread = Math.min(Math.PI * 0.9, Math.PI * 0.3 * childCount);\n        const startAngle = angle - arcSpread / 2;\n        const childRadius = 35 + childCount * 10;\n        \n        nodeChildren.forEach((child, i) => {\n          const childAngle = childCount === 1 ? angle : startAngle + (arcSpread / (childCount - 1)) * i;\n          positionNode(child, depth + 1, childAngle, childRadius, x, z);\n        });\n      }\n    }\n    \n    const totalRoots = roots.length;\n    if (totalRoots > 0) {\n      const weights = roots.map(r => 1 + countDescendants(String(r.pid)) * 0.5);\n      const totalWeight = weights.reduce((a, b) => a + b, 0);\n      \n      let currentAngle = -Math.PI / 2;\n      roots.forEach((root, i) => {\n        const angleSpan = (weights[i] / totalWeight) * Math.PI * 2;\n        const angle = currentAngle + angleSpan / 2;\n        currentAngle += angleSpan;\n        positionNode(root, 0, angle, baseRadius, 0, 0);\n      });\n    }\n    \n    return { roots, byPid, children };\n  }\n  \n  function updateLabels() {\n    const container = document.getElementById('labels');\n    container.innerHTML = '';\n    scene.updateMatrixWorld();\n    \n    meshes.forEach((mesh, pid) => {\n      const pos = new THREE.Vector3();\n      mesh.getWorldPosition(pos);\n      const labelPos = pos.clone();\n      labelPos.y += (mesh.userData.size || 8) + 5;\n      labelPos.project(camera);\n      \n      const x = (labelPos.x * 0.5 + 0.5) * width;\n      const y = (-labelPos.y * 0.5 + 0.5) * height;\n      \n      if (labelPos.z < 1 && x > -100 && x < width + 100 && y > -100 && y < height + 100) {\n        const d = mesh.userData;\n        const color = '#' + (colors[d.category] || 0x666666).toString(16).padStart(6, '0');\n        const distToCamera = camera.position.distanceTo(pos);\n        const proximityScale = Math.max(0.4, Math.min(3, 150 / distToCamera));\n        const opacity = focusedPid \n          ? (pid === focusedPid ? 1 : (d.parentInteresting === parseInt(focusedPid) ? 0.9 : 0.3))\n          : Math.max(0.5, Math.min(1, 300 / distToCamera));\n        \n        const cpuPct = Math.min(100, d.cpu || 0);\n        const memMB = ((d.rss || 0) / 1024).toFixed(0);\n        \n        const label = document.createElement('div');\n        label.className = 'proc-label';\n        label.style.left = x + 'px';\n        label.style.top = y + 'px';\n        label.style.opacity = opacity;\n        label.style.transform = 'translate(-50%, -100%) scale(' + proximityScale + ')';\n        label.innerHTML = '<div class=\"icon\">' + (d.icon || '‚óè') + '</div><div class=\"name\" style=\"color:' + color + '\">' + (d.name || pid) + '</div><div class=\"info\">' + memMB + 'MB ¬∑ ' + cpuPct.toFixed(0) + '%</div>';\n        container.appendChild(label);\n      }\n    });\n  }\n  \n  function updateViz(processData) {\n    if (!processData?.interesting) return;\n    \n    const processes = processData.interesting;\n    document.getElementById('process-count').textContent = processes.length;\n    \n    processTree = layoutTree(processes);\n    const currentPids = new Set(processes.map(p => String(p.pid)));\n    \n    processes.forEach(p => {\n      const pid = String(p.pid);\n      \n      if (!meshes.has(pid)) {\n        const mesh = createNodeMesh(p);\n        mesh.position.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        mesh.userData.targetPos.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        scene.add(mesh);\n        meshes.set(pid, mesh);\n      } else {\n        const mesh = meshes.get(pid);\n        const d = mesh.userData;\n        d.cpu = p.cpu; d.mem = p.mem; d.rss = p.rss; d.name = p.name;\n        d.targetPos.set(p.targetX || d.targetPos.x, p.targetY || d.targetPos.y, p.targetZ || d.targetPos.z);\n        \n        const memMB = (p.rss || 10000) / 1024;\n        d.size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + p.cpu * 0.1));\n        mesh.scale.setScalar(d.size / 6);\n        \n        const baseColor = colors[p.category] || 0x666666;\n        const brighten = Math.min(1.8, 1 + p.cpu * 0.02);\n        const r = ((baseColor >> 16) & 255) * brighten;\n        const g = ((baseColor >> 8) & 255) * brighten;\n        const b = (baseColor & 255) * brighten;\n        mesh.material.color.setRGB(Math.min(255, r) / 255, Math.min(255, g) / 255, Math.min(255, b) / 255);\n        mesh.material.opacity = 0.7 + p.cpu * 0.003;\n      }\n      \n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && meshes.has(parentPid)) {\n        const connKey = pid + '->' + parentPid;\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid });\n        }\n      } else {\n        const connKey = pid + '->kernel';\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid: 'kernel' });\n        }\n      }\n    });\n    \n    meshes.forEach((mesh, pid) => {\n      if (pid === 'kernel') return;\n      if (!currentPids.has(pid) && !mesh.userData.isDead) {\n        mesh.userData.isDead = true;\n        mesh.userData.deathTime = Date.now();\n        \n        const graveyardIndex = graveyard.length;\n        const col = graveyardIndex % 10;\n        const row = Math.floor(graveyardIndex / 10);\n        mesh.userData.targetPos.set((col - 4.5) * 25, GRAVEYARD_Y - row * 20, 0);\n        \n        mesh.material.opacity = 0.25;\n        mesh.material.color.setHex(0x444444);\n        \n        graveyard.push({ pid, mesh, name: mesh.userData.name, deathTime: Date.now() });\n        meshes.delete(pid);\n        \n        while (graveyard.length > MAX_GRAVEYARD) {\n          const oldest = graveyard.shift();\n          scene.remove(oldest.mesh);\n          if (oldest.mesh.geometry) oldest.mesh.geometry.dispose();\n          if (oldest.mesh.material) oldest.mesh.material.dispose();\n        }\n      }\n    });\n    \n    const graveyardPids = new Set(graveyard.map(g => g.pid));\n    connections.forEach((conn, key) => {\n      const childExists = meshes.has(conn.childPid) || graveyardPids.has(conn.childPid);\n      const parentExists = meshes.has(conn.parentPid) || graveyardPids.has(conn.parentPid);\n      if (!childExists || !parentExists) {\n        scene.remove(conn.line);\n        conn.line.geometry.dispose();\n        conn.line.material.dispose();\n        connections.delete(key);\n      }\n    });\n    \n    // Refresh tour list if in tour mode (processes may have changed)\n    if (tourMode) {\n      const oldPid = tourProcessList[tourIndex];\n      tourProcessList = buildTourList();\n      // Try to stay on the same process if it still exists\n      const newIndex = tourProcessList.indexOf(oldPid);\n      if (newIndex !== -1) {\n        tourIndex = newIndex;\n      } else if (tourIndex >= tourProcessList.length) {\n        tourIndex = Math.max(0, tourProcessList.length - 1);\n      }\n      updateTourUI();\n    }\n  }\n  \n  let time = 0;\n  function animate() {\n    requestAnimationFrame(animate);\n    time += 0.016;\n    \n    if (focusedPid && meshes.has(focusedPid)) {\n      focusTarget.lerp(meshes.get(focusedPid).position, 0.08);\n    }\n    \n    controls.target.lerp(focusTarget, transitioning ? 0.06 : 0.02);\n    \n    if (focusDistance !== null) {\n      const currentDist = camera.position.distanceTo(controls.target);\n      if (Math.abs(currentDist - focusDistance) > 5) {\n        const dir = camera.position.clone().sub(controls.target).normalize();\n        const targetPos = controls.target.clone().add(dir.multiplyScalar(focusDistance));\n        camera.position.lerp(targetPos, 0.04);\n      } else {\n        transitioning = false;\n      }\n    } else {\n      transitioning = false;\n    }\n    \n    controls.update();\n    \n    if (kernelGlow) {\n      kernelGlow.rotation.z = time * 0.3;\n      kernelGlow.rotation.x = Math.PI / 2 + Math.sin(time * 0.5) * 0.1;\n    }\n    if (kernelCore) {\n      const pulse = 1 + Math.sin(time * 0.8) * 0.1;\n      kernelCore.scale.setScalar(pulse);\n    }\n    if (kernelMesh) {\n      kernelMesh.rotation.y = time * 0.1;\n    }\n    \n    // Graveyard animation with null checks\n    graveyard.forEach((grave, i) => {\n      const mesh = grave.mesh;\n      if (mesh && mesh.userData && mesh.material) {\n        const d = mesh.userData;\n        mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.02;\n        mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.015;\n        mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.02;\n        mesh.position.x += Math.sin(time * 0.3 + i) * 0.05;\n        const age = (Date.now() - grave.deathTime) / 1000;\n        mesh.material.opacity = Math.max(0.1, 0.3 - age * 0.005);\n      }\n    });\n    \n    // Active meshes animation with null checks\n    meshes.forEach((mesh, pid) => {\n      if (!mesh || !mesh.userData || !mesh.material) return;\n      const d = mesh.userData;\n      const cpu = d.cpu || 0;\n      const isFocused = focusedPid === pid;\n      const isRelated = focusedPid && (d.parentInteresting === parseInt(focusedPid) || String(d.parentInteresting) === focusedPid);\n      \n      mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.03;\n      mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.03;\n      mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.03;\n      \n      const float = Math.sin(time * 0.5 + d.pulsePhase) * 2;\n      mesh.position.y += float * 0.02;\n      \n      const pulseAmp = isFocused ? 0.2 : (0.1 + cpu * 0.005);\n      const pulse = 1 + Math.sin(time * (1 + cpu * 0.05) + d.pulsePhase) * pulseAmp;\n      const sizeMultiplier = isFocused ? 1.5 : (isRelated ? 1.2 : 1);\n      mesh.scale.setScalar((d.size / 6) * pulse * sizeMultiplier);\n      \n      if (focusedPid) {\n        mesh.material.opacity = isFocused ? 1 : (isRelated ? 0.8 : 0.3);\n      } else {\n        mesh.material.opacity = 0.7 + cpu * 0.003;\n      }\n    });\n    \n    connections.forEach(conn => {\n      const childMesh = meshes.get(conn.childPid);\n      const parentMesh = meshes.get(conn.parentPid);\n      if (childMesh && parentMesh) {\n        updateConnectionMesh(conn, childMesh.position, parentMesh.position);\n        const involvesFocus = focusedPid && (conn.childPid === focusedPid || conn.parentPid === focusedPid);\n        conn.line.material.opacity = focusedPid ? (involvesFocus ? 0.9 : 0.15) : 0.5;\n        conn.line.material.color.setHex(involvesFocus ? 0xff69b4 : 0x444444);\n        const thickness = involvesFocus ? 2.5 : 1.5;\n        conn.line.scale.x = thickness / 1.5;\n        conn.line.scale.z = thickness / 1.5;\n      }\n    });\n    \n    renderer.render(scene, camera);\n    updateLabels();\n  }\n  \n  function connectWS() {\n    try {\n      ws = new WebSocket('ws://127.0.0.1:7890/ws');\n      ws.onopen = () => document.getElementById('status-dot').classList.add('online');\n      ws.onclose = () => {\n        document.getElementById('status-dot').classList.remove('online');\n        setTimeout(connectWS, 2000);\n      };\n      ws.onerror = () => ws.close();\n      ws.onmessage = (e) => {\n        try {\n          const data = JSON.parse(e.data);\n          if (data.system) {\n            document.getElementById('uptime').textContent = data.system.uptime.formatted;\n            document.getElementById('cpus').textContent = data.system.cpus;\n            const m = data.system.memory;\n            document.getElementById('mem-text').textContent = m.used + ' / ' + m.total;\n          }\n          updateViz(data.processes);\n        } catch {}\n      };\n    } catch {\n      setTimeout(connectWS, 2000);\n    }\n  }\n  \n  window.addEventListener('resize', () => {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n  });\n  \n  // Expose for external use (mock data injection, etc.)\n  window.ProcessTreeViz = {\n    updateViz,\n    scene,\n    camera,\n    meshes,\n    connections,\n    graveyard,\n    // Tour mode\n    startTour,\n    exitTour,\n    tourNext,\n    tourPrev,\n    toggleAutoPlay,\n    isTourMode: () => tourMode\n  };\n  \n  // Add tour hint to the UI\n  const tourHint = document.createElement('div');\n  tourHint.id = 'tour-hint';\n  tourHint.style.cssText = 'position:fixed;bottom:20px;right:20px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px;color:#888;font-family:monospace;font-size:11px;z-index:999;';\n  tourHint.innerHTML = 'Press <span style=\"color:#88ccff;font-weight:bold;\">T</span> for Tour Mode';\n  document.body.appendChild(tourHint);\n  \n  animate();\n  connectWS();\n})();\n";
