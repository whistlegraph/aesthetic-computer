// Auto-generated - DO NOT EDIT DIRECTLY
// Edit views/process-tree.js instead and run: node build-views.mjs

export const PROCESS_TREE_JS = "// 3D Process Tree Visualization\n// Shared between VS Code extension and local dev testing\n\n(function() {\n  'use strict';\n  \n  // Check if we're in VS Code webview or standalone\n  const isVSCode = typeof acquireVsCodeApi === 'function';\n  \n  // üé® Color Schemes (imported from color-schemes.js or embedded)\n  const colorSchemes = window.AestheticColorSchemes?.schemes || {\n    dark: {\n      background: '#181318',\n      backgroundAlt: '#141214',\n      foreground: '#ffffffcc',\n      foregroundBright: '#ffffff',\n      foregroundMuted: '#555555',\n      accent: '#a87090',\n      accentBright: '#ff69b4',\n      statusOnline: '#0f0',\n      categories: {\n        editor: 0xb06bff, tui: 0xff69b4, bridge: 0x6bff9f,\n        db: 0xffeb6b, proxy: 0x6b9fff, ai: 0xff9f6b,\n        shell: 0x6bffff, dev: 0x6bff9f, ide: 0x6b9fff, lsp: 0x888888, kernel: 0x88ccff\n      },\n      three: {\n        sceneBackground: 0x000000,\n        kernelOuter: 0x4488ff, kernelRing: 0x66aaff, kernelCore: 0x88ccff,\n        connectionLine: 0x444444, connectionActive: 0xff69b4, deadProcess: 0x444444\n      },\n      ui: { shadow: 'rgba(0, 0, 0, 0.6)', overlay: 'rgba(0, 0, 0, 0.85)' }\n    },\n    light: {\n      background: '#fcf7c5',\n      backgroundAlt: '#f5f0c0',\n      foreground: '#281e5a',\n      foregroundBright: '#281e5a',\n      foregroundMuted: '#806060',\n      accent: '#387adf',\n      accentBright: '#006400',\n      statusOnline: '#006400',\n      categories: {\n        editor: 0x8040d0, tui: 0xd04080, bridge: 0x208040,\n        db: 0xa08000, proxy: 0x2060c0, ai: 0xc06020,\n        shell: 0x008080, dev: 0x208040, ide: 0x2060c0, lsp: 0x606060, kernel: 0x387adf\n      },\n      three: {\n        sceneBackground: 0xfcf7c5,\n        kernelOuter: 0x387adf, kernelRing: 0x006400, kernelCore: 0x387adf,\n        connectionLine: 0xa8a080, connectionActive: 0x006400, deadProcess: 0xa8a080\n      },\n      ui: { shadow: 'rgba(0, 0, 0, 0.2)', overlay: 'rgba(252, 247, 197, 0.95)' }\n    }\n  };\n  \n  // Detect theme from data attribute, URL param, or VS Code CSS vars\n  function detectTheme() {\n    // Check data attribute first (set by the HTML)\n    const dataTheme = document.body.dataset.theme;\n    if (dataTheme === 'light' || dataTheme === 'dark') return dataTheme;\n    \n    // Check URL param\n    const urlParams = new URLSearchParams(window.location.search);\n    const urlTheme = urlParams.get('theme');\n    if (urlTheme === 'light' || urlTheme === 'dark') return urlTheme;\n    \n    // Check VS Code CSS variables\n    if (typeof getComputedStyle !== 'undefined') {\n      const bgColor = getComputedStyle(document.body).getPropertyValue('--vscode-editor-background').trim();\n      if (bgColor && bgColor.startsWith('#')) {\n        const r = parseInt(bgColor.slice(1, 3), 16);\n        const g = parseInt(bgColor.slice(3, 5), 16);\n        const b = parseInt(bgColor.slice(5, 7), 16);\n        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n        return luminance > 0.5 ? 'light' : 'dark';\n      }\n    }\n    \n    return 'dark';\n  }\n  \n  let currentTheme = detectTheme();\n  let scheme = colorSchemes[currentTheme];\n  let colors = scheme.categories;\n  \n  // Apply initial body styling based on detected theme\n  document.body.style.background = scheme.background;\n  document.body.style.color = scheme.foreground;\n  document.body.dataset.theme = currentTheme;\n  \n  // Show dev badge if not in VS Code\n  if (!isVSCode) {\n    const badge = document.createElement('div');\n    badge.className = 'dev-badge';\n    badge.textContent = 'DEV MODE';\n    document.body.appendChild(badge);\n  }\n  \n  let width = window.innerWidth, height = window.innerHeight;\n  let meshes = new Map(), connections = new Map(), ws;\n  let graveyard = [];\n  const MAX_GRAVEYARD = 30;\n  const GRAVEYARD_Y = -200;\n  \n  // Three.js setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(scheme.three.sceneBackground);\n  \n  const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 5000);\n  camera.position.set(0, 150, 400);\n  camera.lookAt(0, 0, 0);\n  \n  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setClearColor(scheme.three.sceneBackground);\n  \n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.05;\n  controls.minDistance = 20;\n  controls.maxDistance = 3000;\n  controls.enablePan = true;\n  controls.autoRotate = true;\n  controls.autoRotateSpeed = 0.3;\n  controls.target.set(0, 0, 0);\n  \n  let focusedPid = null;\n  let focusTarget = new THREE.Vector3(0, 0, 0);\n  let focusDistance = null;\n  let transitioning = false;\n  \n  // Tour mode state\n  let tourMode = false;\n  let tourIndex = 0;\n  let tourProcessList = [];\n  let tourAutoPlay = false;\n  let tourAutoPlayInterval = null;\n  const TOUR_SPEED = 2500; // ms between auto-advances\n  \n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n  \n  renderer.domElement.addEventListener('click', (e) => {\n    mouse.x = (e.clientX / width) * 2 - 1;\n    mouse.y = -(e.clientY / height) * 2 + 1;\n    \n    raycaster.setFromCamera(mouse, camera);\n    const meshArray = Array.from(meshes.values());\n    const intersects = raycaster.intersectObjects(meshArray);\n    \n    if (intersects.length > 0) {\n      const clicked = intersects[0].object;\n      const pid = clicked.userData.pid;\n      \n      if (focusedPid === String(pid)) {\n        focusedPid = null;\n        focusTarget.set(0, 0, 0);\n        focusDistance = null;\n      } else {\n        focusedPid = String(pid);\n        focusTarget.copy(clicked.position);\n        focusDistance = 80 + (clicked.userData.size || 6) * 3;\n      }\n      transitioning = true;\n      controls.autoRotate = true;\n    } else if (!e.shiftKey) {\n      focusedPid = null;\n      focusTarget.set(0, 0, 0);\n      focusDistance = null;\n      transitioning = true;\n    }\n  });\n  \n  renderer.domElement.addEventListener('dblclick', () => {\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    camera.position.set(0, 150, 400);\n  });\n  \n  // Tour Mode Functions\n  function updateTourUI() {\n    let tourUI = document.getElementById('tour-ui');\n    if (!tourUI) {\n      tourUI = document.createElement('div');\n      tourUI.id = 'tour-ui';\n      document.body.appendChild(tourUI);\n    }\n    // Update styling each time based on current theme\n    tourUI.style.cssText = `position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:${scheme.ui.overlay};padding:12px 20px;border-radius:8px;color:${scheme.foregroundBright};font-family:monospace;font-size:12px;z-index:1000;display:none;text-align:center;border:1px solid ${scheme.foregroundMuted}40;`;\n    \n    if (tourMode && tourProcessList.length > 0) {\n      const current = tourProcessList[tourIndex];\n      const mesh = meshes.get(current);\n      const name = mesh?.userData?.name || current;\n      const icon = mesh?.userData?.icon || '‚óè';\n      const category = mesh?.userData?.category || '';\n      \n      tourUI.style.display = 'block';\n      tourUI.innerHTML = `\n        <div style=\"margin-bottom:8px;font-size:14px;color:${scheme.accent};\">üé¨ TOUR MODE</div>\n        <div style=\"font-size:18px;margin-bottom:4px;color:${scheme.foregroundBright};\">${icon} ${name}</div>\n        <div style=\"color:${scheme.foregroundMuted};margin-bottom:12px;\">${category} ‚Ä¢ ${tourIndex + 1}/${tourProcessList.length}</div>\n        <div style=\"display:flex;gap:8px;justify-content:center;flex-wrap:wrap;\">\n          <button onclick=\"ProcessTreeViz.tourPrev()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">‚Üê Prev</button>\n          <button onclick=\"ProcessTreeViz.toggleAutoPlay()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">${tourAutoPlay ? '‚è∏ Stop' : '‚ñ∂ Auto'}</button>\n          <button onclick=\"ProcessTreeViz.tourNext()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">Next ‚Üí</button>\n          <button onclick=\"ProcessTreeViz.exitTour()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">‚úï Exit</button>\n        </div>\n        ${tourAutoPlay ? `<div style=\"color:${scheme.accentBright};margin-top:8px;\">‚ñ∂ Auto-playing...</div>` : ''}\n      `;\n      // Hide the tour button when in tour mode\n      const btn = document.getElementById('tour-btn');\n      if (btn) btn.style.display = 'none';\n    } else {\n      tourUI.style.display = 'none';\n      // Show the tour button when not in tour mode\n      const btn = document.getElementById('tour-btn');\n      if (btn) btn.style.display = 'block';\n    }\n  }\n  \n  function buildTourList() {\n    // Build ordered list: kernel first, then by category, then by tree depth\n    const categoryOrder = ['kernel', 'ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    const list = Array.from(meshes.keys());\n    \n    list.sort((a, b) => {\n      const meshA = meshes.get(a);\n      const meshB = meshes.get(b);\n      const catA = meshA?.userData?.category || 'zzz';\n      const catB = meshB?.userData?.category || 'zzz';\n      const orderA = categoryOrder.indexOf(catA);\n      const orderB = categoryOrder.indexOf(catB);\n      return (orderA === -1 ? 99 : orderA) - (orderB === -1 ? 99 : orderB);\n    });\n    \n    return list;\n  }\n  \n  function focusOnProcess(pid) {\n    const mesh = meshes.get(pid);\n    if (!mesh) return;\n    \n    focusedPid = pid;\n    focusTarget.copy(mesh.position);\n    focusDistance = 80 + (mesh.userData.size || 6) * 3;\n    transitioning = true;\n    controls.autoRotate = true;\n  }\n  \n  function startTour() {\n    tourMode = true;\n    tourProcessList = buildTourList();\n    tourIndex = 0;\n    if (tourProcessList.length > 0) {\n      focusOnProcess(tourProcessList[0]);\n    }\n    updateTourUI();\n  }\n  \n  function exitTour() {\n    tourMode = false;\n    tourAutoPlay = false;\n    if (tourAutoPlayInterval) {\n      clearInterval(tourAutoPlayInterval);\n      tourAutoPlayInterval = null;\n    }\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    updateTourUI();\n  }\n  \n  function tourNext() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex + 1) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function tourPrev() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex - 1 + tourProcessList.length) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function toggleAutoPlay() {\n    tourAutoPlay = !tourAutoPlay;\n    if (tourAutoPlay) {\n      tourAutoPlayInterval = setInterval(tourNext, TOUR_SPEED);\n    } else {\n      if (tourAutoPlayInterval) {\n        clearInterval(tourAutoPlayInterval);\n        tourAutoPlayInterval = null;\n      }\n    }\n    updateTourUI();\n  }\n  \n  // Keyboard controls\n  document.addEventListener('keydown', (e) => {\n    // T to start tour\n    if (e.key === 't' || e.key === 'T') {\n      if (!tourMode) {\n        startTour();\n      }\n      return;\n    }\n    \n    if (tourMode) {\n      switch(e.key) {\n        case 'ArrowRight':\n        case 'l':\n        case 'L':\n          tourNext();\n          e.preventDefault();\n          break;\n        case 'ArrowLeft':\n        case 'h':\n        case 'H':\n          tourPrev();\n          e.preventDefault();\n          break;\n        case ' ':\n          toggleAutoPlay();\n          e.preventDefault();\n          break;\n        case 'Escape':\n        case 'q':\n        case 'Q':\n          exitTour();\n          e.preventDefault();\n          break;\n      }\n    }\n  });\n  \n  let processTree = { roots: [], byPid: new Map() };\n  \n  let kernelMesh = null, kernelGlow = null, kernelCore = null;\n  function createKernelNode() {\n    const group = new THREE.Group();\n    \n    const outerGeo = new THREE.SphereGeometry(35, 32, 32);\n    const outerMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelOuter, transparent: true, opacity: 0.15, wireframe: true\n    });\n    group.add(new THREE.Mesh(outerGeo, outerMat));\n    \n    const ringGeo = new THREE.TorusGeometry(25, 1.5, 8, 48);\n    const ringMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelRing, transparent: true, opacity: 0.4\n    });\n    const ring = new THREE.Mesh(ringGeo, ringMat);\n    ring.rotation.x = Math.PI / 2;\n    group.add(ring);\n    kernelGlow = ring;\n    \n    const coreGeo = new THREE.SphereGeometry(12, 24, 24);\n    const coreMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelCore, transparent: true, opacity: 0.7\n    });\n    const core = new THREE.Mesh(coreGeo, coreMat);\n    group.add(core);\n    kernelCore = core;\n    \n    group.userData = {\n      pid: 'kernel', name: 'Fedora Linux', icon: 'üêß', category: 'kernel',\n      cpu: 0, rss: 0, size: 35, targetPos: new THREE.Vector3(0, 0, 0), pulsePhase: 0\n    };\n    return group;\n  }\n  \n  kernelMesh = createKernelNode();\n  scene.add(kernelMesh);\n  meshes.set('kernel', kernelMesh);\n  \n  function createNodeMesh(node) {\n    const cpu = node.cpu || 0;\n    const memMB = (node.rss || 10000) / 1024;\n    const baseColor = colors[node.category] || 0x666666;\n    const size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + cpu * 0.1));\n    \n    const geo = new THREE.SphereGeometry(size, 12, 12);\n    const mat = new THREE.MeshBasicMaterial({\n      color: baseColor, transparent: true, opacity: 0.7 + cpu * 0.003\n    });\n    \n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.userData = { \n      ...node, size, baseColor, targetPos: new THREE.Vector3(),\n      pulsePhase: Math.random() * Math.PI * 2\n    };\n    return mesh;\n  }\n  \n  function createConnectionLine() {\n    const geo = new THREE.CylinderGeometry(1.5, 1.5, 1, 8);\n    const mat = new THREE.MeshBasicMaterial({\n      color: scheme.three.connectionLine, transparent: true, opacity: 0.5\n    });\n    return new THREE.Mesh(geo, mat);\n  }\n  \n  function updateConnectionMesh(conn, childPos, parentPos) {\n    const mesh = conn.line;\n    const mid = new THREE.Vector3().addVectors(childPos, parentPos).multiplyScalar(0.5);\n    mesh.position.copy(mid);\n    const dir = new THREE.Vector3().subVectors(parentPos, childPos);\n    const length = dir.length();\n    mesh.scale.set(1, length, 1);\n    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());\n  }\n  \n  function layoutTree(processes) {\n    const byPid = new Map();\n    const children = new Map();\n    \n    processes.forEach(p => {\n      byPid.set(String(p.pid), p);\n      children.set(String(p.pid), []);\n    });\n    \n    const roots = [];\n    processes.forEach(p => {\n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && byPid.has(parentPid)) {\n        children.get(parentPid).push(p);\n      } else {\n        roots.push(p);\n      }\n    });\n    \n    const categoryOrder = ['ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    roots.sort((a, b) => {\n      const ai = categoryOrder.indexOf(a.category);\n      const bi = categoryOrder.indexOf(b.category);\n      return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);\n    });\n    \n    const levelHeight = 50, baseRadius = 100;\n    \n    function countDescendants(pid) {\n      const nodeChildren = children.get(pid) || [];\n      let count = nodeChildren.length;\n      nodeChildren.forEach(c => count += countDescendants(String(c.pid)));\n      return count;\n    }\n    \n    function positionNode(node, depth, angle, radius, parentX, parentZ) {\n      const pid = String(node.pid);\n      const nodeChildren = children.get(pid) || [];\n      const childCount = nodeChildren.length;\n      \n      const x = parentX + Math.cos(angle) * radius;\n      const z = parentZ + Math.sin(angle) * radius;\n      \n      node.targetX = x;\n      node.targetY = -depth * levelHeight;\n      node.targetZ = z;\n      \n      if (childCount > 0) {\n        const arcSpread = Math.min(Math.PI * 0.9, Math.PI * 0.3 * childCount);\n        const startAngle = angle - arcSpread / 2;\n        const childRadius = 35 + childCount * 10;\n        \n        nodeChildren.forEach((child, i) => {\n          const childAngle = childCount === 1 ? angle : startAngle + (arcSpread / (childCount - 1)) * i;\n          positionNode(child, depth + 1, childAngle, childRadius, x, z);\n        });\n      }\n    }\n    \n    const totalRoots = roots.length;\n    if (totalRoots > 0) {\n      const weights = roots.map(r => 1 + countDescendants(String(r.pid)) * 0.5);\n      const totalWeight = weights.reduce((a, b) => a + b, 0);\n      \n      let currentAngle = -Math.PI / 2;\n      roots.forEach((root, i) => {\n        const angleSpan = (weights[i] / totalWeight) * Math.PI * 2;\n        const angle = currentAngle + angleSpan / 2;\n        currentAngle += angleSpan;\n        positionNode(root, 0, angle, baseRadius, 0, 0);\n      });\n    }\n    \n    return { roots, byPid, children };\n  }\n  \n  function updateLabels() {\n    const container = document.getElementById('labels');\n    container.innerHTML = '';\n    scene.updateMatrixWorld();\n    \n    meshes.forEach((mesh, pid) => {\n      const pos = new THREE.Vector3();\n      mesh.getWorldPosition(pos);\n      const labelPos = pos.clone();\n      labelPos.y += (mesh.userData.size || 8) + 5;\n      labelPos.project(camera);\n      \n      const x = (labelPos.x * 0.5 + 0.5) * width;\n      const y = (-labelPos.y * 0.5 + 0.5) * height;\n      \n      if (labelPos.z < 1 && x > -100 && x < width + 100 && y > -100 && y < height + 100) {\n        const d = mesh.userData;\n        const color = '#' + (colors[d.category] || 0x666666).toString(16).padStart(6, '0');\n        const distToCamera = camera.position.distanceTo(pos);\n        // Larger base scale, less reduction with distance\n        const proximityScale = Math.max(0.7, Math.min(3, 200 / distToCamera));\n        // Higher minimum opacity - always readable\n        const opacity = focusedPid \n          ? (pid === focusedPid ? 1 : (d.parentInteresting === parseInt(focusedPid) ? 0.95 : 0.7))\n          : Math.max(0.85, Math.min(1, 400 / distToCamera));\n        \n        const cpuPct = Math.min(100, d.cpu || 0);\n        const memMB = ((d.rss || 0) / 1024).toFixed(0);\n        \n        // Extract short command for display (first 40 chars of cmdShort or cmd)\n        const cmdDisplay = d.cmdShort || d.cmd || '';\n        const cmdShort = cmdDisplay.length > 50 ? cmdDisplay.slice(0, 47) + '...' : cmdDisplay;\n        \n        const label = document.createElement('div');\n        label.className = 'proc-label';\n        label.style.left = x + 'px';\n        label.style.top = y + 'px';\n        label.style.opacity = opacity;\n        label.style.transform = 'translate(-50%, -100%) scale(' + proximityScale + ')';\n        // Show name, then command on second line, then stats\n        label.innerHTML = '<div class=\"icon\">' + (d.icon || '‚óè') + '</div>' +\n          '<div class=\"name\" style=\"color:' + color + '\">' + (d.name || pid) + '</div>' +\n          (cmdShort ? '<div class=\"cmd\" style=\"color:' + scheme.foregroundMuted + ';font-size:8px;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">' + cmdShort + '</div>' : '') +\n          '<div class=\"info\" style=\"color:' + scheme.foregroundMuted + ';\">' + memMB + 'MB ¬∑ ' + cpuPct.toFixed(0) + '%</div>';\n        container.appendChild(label);\n      }\n    });\n  }\n  \n  function updateViz(processData) {\n    if (!processData?.interesting) return;\n    \n    const processes = processData.interesting;\n    document.getElementById('process-count').textContent = processes.length;\n    \n    processTree = layoutTree(processes);\n    const currentPids = new Set(processes.map(p => String(p.pid)));\n    \n    processes.forEach(p => {\n      const pid = String(p.pid);\n      \n      if (!meshes.has(pid)) {\n        const mesh = createNodeMesh(p);\n        mesh.position.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        mesh.userData.targetPos.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        scene.add(mesh);\n        meshes.set(pid, mesh);\n      } else {\n        const mesh = meshes.get(pid);\n        const d = mesh.userData;\n        d.cpu = p.cpu; d.mem = p.mem; d.rss = p.rss; d.name = p.name;\n        d.targetPos.set(p.targetX || d.targetPos.x, p.targetY || d.targetPos.y, p.targetZ || d.targetPos.z);\n        \n        const memMB = (p.rss || 10000) / 1024;\n        d.size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + p.cpu * 0.1));\n        mesh.scale.setScalar(d.size / 6);\n        \n        const baseColor = colors[p.category] || 0x666666;\n        const brighten = Math.min(1.8, 1 + p.cpu * 0.02);\n        const r = ((baseColor >> 16) & 255) * brighten;\n        const g = ((baseColor >> 8) & 255) * brighten;\n        const b = (baseColor & 255) * brighten;\n        mesh.material.color.setRGB(Math.min(255, r) / 255, Math.min(255, g) / 255, Math.min(255, b) / 255);\n        mesh.material.opacity = 0.7 + p.cpu * 0.003;\n      }\n      \n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && meshes.has(parentPid)) {\n        const connKey = pid + '->' + parentPid;\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid });\n        }\n      } else {\n        const connKey = pid + '->kernel';\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid: 'kernel' });\n        }\n      }\n    });\n    \n    meshes.forEach((mesh, pid) => {\n      if (pid === 'kernel') return;\n      if (!currentPids.has(pid) && !mesh.userData.isDead) {\n        mesh.userData.isDead = true;\n        mesh.userData.deathTime = Date.now();\n        \n        const graveyardIndex = graveyard.length;\n        const col = graveyardIndex % 10;\n        const row = Math.floor(graveyardIndex / 10);\n        mesh.userData.targetPos.set((col - 4.5) * 25, GRAVEYARD_Y - row * 20, 0);\n        \n        mesh.material.opacity = 0.25;\n        mesh.material.color.setHex(scheme.three.deadProcess);\n        \n        graveyard.push({ pid, mesh, name: mesh.userData.name, deathTime: Date.now() });\n        meshes.delete(pid);\n        \n        while (graveyard.length > MAX_GRAVEYARD) {\n          const oldest = graveyard.shift();\n          scene.remove(oldest.mesh);\n          if (oldest.mesh.geometry) oldest.mesh.geometry.dispose();\n          if (oldest.mesh.material) oldest.mesh.material.dispose();\n        }\n      }\n    });\n    \n    const graveyardPids = new Set(graveyard.map(g => g.pid));\n    connections.forEach((conn, key) => {\n      const childExists = meshes.has(conn.childPid) || graveyardPids.has(conn.childPid);\n      const parentExists = meshes.has(conn.parentPid) || graveyardPids.has(conn.parentPid);\n      if (!childExists || !parentExists) {\n        scene.remove(conn.line);\n        conn.line.geometry.dispose();\n        conn.line.material.dispose();\n        connections.delete(key);\n      }\n    });\n    \n    // Refresh tour list if in tour mode (processes may have changed)\n    if (tourMode) {\n      const oldPid = tourProcessList[tourIndex];\n      tourProcessList = buildTourList();\n      // Try to stay on the same process if it still exists\n      const newIndex = tourProcessList.indexOf(oldPid);\n      if (newIndex !== -1) {\n        tourIndex = newIndex;\n      } else if (tourIndex >= tourProcessList.length) {\n        tourIndex = Math.max(0, tourProcessList.length - 1);\n      }\n      updateTourUI();\n    }\n  }\n  \n  let time = 0;\n  function animate() {\n    requestAnimationFrame(animate);\n    time += 0.016;\n    \n    if (focusedPid && meshes.has(focusedPid)) {\n      focusTarget.lerp(meshes.get(focusedPid).position, 0.08);\n    }\n    \n    controls.target.lerp(focusTarget, transitioning ? 0.06 : 0.02);\n    \n    if (focusDistance !== null) {\n      const currentDist = camera.position.distanceTo(controls.target);\n      if (Math.abs(currentDist - focusDistance) > 5) {\n        const dir = camera.position.clone().sub(controls.target).normalize();\n        const targetPos = controls.target.clone().add(dir.multiplyScalar(focusDistance));\n        camera.position.lerp(targetPos, 0.04);\n      } else {\n        transitioning = false;\n      }\n    } else {\n      transitioning = false;\n    }\n    \n    controls.update();\n    \n    if (kernelGlow) {\n      kernelGlow.rotation.z = time * 0.3;\n      kernelGlow.rotation.x = Math.PI / 2 + Math.sin(time * 0.5) * 0.1;\n    }\n    if (kernelCore) {\n      const pulse = 1 + Math.sin(time * 0.8) * 0.1;\n      kernelCore.scale.setScalar(pulse);\n    }\n    if (kernelMesh) {\n      kernelMesh.rotation.y = time * 0.1;\n    }\n    \n    // Graveyard animation with null checks\n    graveyard.forEach((grave, i) => {\n      const mesh = grave.mesh;\n      if (mesh && mesh.userData && mesh.material) {\n        const d = mesh.userData;\n        mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.02;\n        mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.015;\n        mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.02;\n        mesh.position.x += Math.sin(time * 0.3 + i) * 0.05;\n        const age = (Date.now() - grave.deathTime) / 1000;\n        mesh.material.opacity = Math.max(0.1, 0.3 - age * 0.005);\n      }\n    });\n    \n    // Active meshes animation with null checks\n    meshes.forEach((mesh, pid) => {\n      if (!mesh || !mesh.userData || !mesh.material) return;\n      const d = mesh.userData;\n      const cpu = d.cpu || 0;\n      const isFocused = focusedPid === pid;\n      const isRelated = focusedPid && (d.parentInteresting === parseInt(focusedPid) || String(d.parentInteresting) === focusedPid);\n      \n      mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.03;\n      mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.03;\n      mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.03;\n      \n      const float = Math.sin(time * 0.5 + d.pulsePhase) * 2;\n      mesh.position.y += float * 0.02;\n      \n      const pulseAmp = isFocused ? 0.2 : (0.1 + cpu * 0.005);\n      const pulse = 1 + Math.sin(time * (1 + cpu * 0.05) + d.pulsePhase) * pulseAmp;\n      const sizeMultiplier = isFocused ? 1.5 : (isRelated ? 1.2 : 1);\n      mesh.scale.setScalar((d.size / 6) * pulse * sizeMultiplier);\n      \n      if (focusedPid) {\n        mesh.material.opacity = isFocused ? 1 : (isRelated ? 0.8 : 0.3);\n      } else {\n        mesh.material.opacity = 0.7 + cpu * 0.003;\n      }\n    });\n    \n    connections.forEach(conn => {\n      const childMesh = meshes.get(conn.childPid);\n      const parentMesh = meshes.get(conn.parentPid);\n      if (childMesh && parentMesh) {\n        updateConnectionMesh(conn, childMesh.position, parentMesh.position);\n        const involvesFocus = focusedPid && (conn.childPid === focusedPid || conn.parentPid === focusedPid);\n        conn.line.material.opacity = focusedPid ? (involvesFocus ? 0.9 : 0.15) : 0.5;\n        conn.line.material.color.setHex(involvesFocus ? scheme.three.connectionActive : scheme.three.connectionLine);\n        const thickness = involvesFocus ? 2.5 : 1.5;\n        conn.line.scale.x = thickness / 1.5;\n        conn.line.scale.z = thickness / 1.5;\n      }\n    });\n    \n    renderer.render(scene, camera);\n    updateLabels();\n  }\n  \n  function connectWS() {\n    try {\n      ws = new WebSocket('ws://127.0.0.1:7890/ws');\n      ws.onopen = () => document.getElementById('status-dot').classList.add('online');\n      ws.onclose = () => {\n        document.getElementById('status-dot').classList.remove('online');\n        setTimeout(connectWS, 2000);\n      };\n      ws.onerror = () => ws.close();\n      ws.onmessage = (e) => {\n        try {\n          const data = JSON.parse(e.data);\n          if (data.system) {\n            document.getElementById('uptime').textContent = data.system.uptime.formatted;\n            document.getElementById('cpus').textContent = data.system.cpus;\n            const m = data.system.memory;\n            document.getElementById('mem-text').textContent = m.used + ' / ' + m.total;\n          }\n          updateViz(data.processes);\n        } catch {}\n      };\n    } catch {\n      setTimeout(connectWS, 2000);\n    }\n  }\n  \n  window.addEventListener('resize', () => {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n  });\n  \n  // üé® Theme switching function\n  function setTheme(themeName) {\n    if (themeName !== 'light' && themeName !== 'dark') return;\n    currentTheme = themeName;\n    scheme = colorSchemes[currentTheme];\n    colors = scheme.categories;\n    \n    // Update scene background\n    scene.background.setHex(scheme.three.sceneBackground);\n    renderer.setClearColor(scheme.three.sceneBackground);\n    \n    // Update body styling\n    document.body.dataset.theme = themeName;\n    document.body.style.background = scheme.background;\n    document.body.style.color = scheme.foreground;\n    \n    // Update kernel mesh colors\n    if (kernelMesh) {\n      kernelMesh.children[0].material.color.setHex(scheme.three.kernelOuter);\n      if (kernelGlow) kernelGlow.material.color.setHex(scheme.three.kernelRing);\n      if (kernelCore) kernelCore.material.color.setHex(scheme.three.kernelCore);\n    }\n    \n    // Update all process node colors\n    meshes.forEach((mesh, pid) => {\n      if (pid === 'kernel') return;\n      const category = mesh.userData.category;\n      const newColor = colors[category] || 0x666666;\n      mesh.material.color.setHex(newColor);\n      mesh.userData.baseColor = newColor;\n    });\n    \n    // Update connections\n    connections.forEach(conn => {\n      conn.line.material.color.setHex(scheme.three.connectionLine);\n    });\n    \n    // Update graveyard\n    graveyard.forEach(grave => {\n      if (grave.mesh && grave.mesh.material) {\n        grave.mesh.material.color.setHex(scheme.three.deadProcess);\n      }\n    });\n    \n    // Update CSS styles\n    updateThemeStyles();\n  }\n  \n  function toggleTheme() {\n    setTheme(currentTheme === 'dark' ? 'light' : 'dark');\n    return currentTheme;\n  }\n  \n  function updateThemeStyles() {\n    // Update dynamic CSS based on theme\n    let styleEl = document.getElementById('theme-dynamic-styles');\n    if (!styleEl) {\n      styleEl = document.createElement('style');\n      styleEl.id = 'theme-dynamic-styles';\n      document.head.appendChild(styleEl);\n    }\n    styleEl.textContent = `\n      .title .dot { color: ${scheme.accentBright}; }\n      .status-dot { background: ${scheme.accent}; }\n      .status-dot.online { background: ${scheme.statusOnline}; }\n      .stats { color: ${scheme.foregroundMuted}; }\n      .stats .val { color: ${scheme.foregroundBright}; }\n      .mem { color: ${scheme.foregroundMuted}; }\n      .center { color: ${scheme.foregroundMuted}; }\n      .center .count { color: ${scheme.foregroundBright}; }\n      .proc-label { text-shadow: 0 0 3px ${scheme.background}, 0 0 6px ${scheme.background}; }\n      .proc-label .info { color: ${scheme.foregroundMuted}; }\n      .dev-badge { background: ${currentTheme === 'light' ? scheme.accentBright : scheme.accentBright}; color: ${currentTheme === 'light' ? '#fff' : '#000'}; }\n      #tour-ui { background: ${scheme.ui.overlay}; border-color: ${scheme.foregroundMuted}; }\n      #tour-hint { background: ${scheme.ui.overlay}; }\n    `;\n  }\n  \n  // Apply initial theme styles\n  updateThemeStyles();\n  \n  // Expose for external use (mock data injection, etc.)\n  window.ProcessTreeViz = {\n    updateViz,\n    scene,\n    camera,\n    meshes,\n    connections,\n    graveyard,\n    // Tour mode\n    startTour,\n    exitTour,\n    tourNext,\n    tourPrev,\n    toggleAutoPlay,\n    isTourMode: () => tourMode,\n    // Theme control\n    setTheme,\n    toggleTheme,\n    getTheme: () => currentTheme,\n    getScheme: () => scheme,\n    colorSchemes\n  };\n  \n  // Add tour button to the UI (touch-friendly, no keyboard shortcuts)\n  const tourBtn = document.createElement('button');\n  tourBtn.id = 'tour-btn';\n  tourBtn.style.cssText = `position:fixed;bottom:20px;right:20px;background:${scheme.ui.overlay};padding:10px 16px;border-radius:6px;color:${scheme.foregroundMuted};font-family:monospace;font-size:12px;z-index:999;border:1px solid ${scheme.foregroundMuted}40;cursor:pointer;`;\n  tourBtn.textContent = 'üé¨ Tour';\n  tourBtn.onclick = () => { if (!tourMode) startTour(); else exitTour(); };\n  document.body.appendChild(tourBtn);\n  \n  animate();\n  connectWS();\n})();";
