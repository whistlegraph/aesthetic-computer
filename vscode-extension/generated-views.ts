// Auto-generated - DO NOT EDIT DIRECTLY
// Edit views/process-tree.js and views/ast-tree.js instead and run: node build-views.mjs

export const PROCESS_TREE_JS = "// 3D Process Tree Visualization\n// Shared between VS Code extension and local dev testing\n\n(function() {\n  'use strict';\n  \n  // Check if we're in VS Code webview or standalone\n  const isVSCode = typeof acquireVsCodeApi === 'function';\n  \n  // üé® Color Schemes (imported from color-schemes.js or embedded)\n  const colorSchemes = window.AestheticColorSchemes?.schemes || {\n    dark: {\n      background: '#181318',\n      backgroundAlt: '#141214',\n      foreground: '#ffffffcc',\n      foregroundBright: '#ffffff',\n      foregroundMuted: '#555555',\n      accent: '#a87090',\n      accentBright: '#ff69b4',\n      statusOnline: '#0f0',\n      categories: {\n        editor: 0xb06bff, tui: 0xff69b4, bridge: 0x6bff9f,\n        db: 0xffeb6b, proxy: 0x6b9fff, ai: 0xff9f6b,\n        shell: 0x6bffff, dev: 0x6bff9f, ide: 0x6b9fff, lsp: 0x888888, kernel: 0x88ccff\n      },\n      three: {\n        sceneBackground: 0x000000,\n        kernelOuter: 0x4488ff, kernelRing: 0x66aaff, kernelCore: 0x88ccff,\n        connectionLine: 0x444444, connectionActive: 0xff69b4, deadProcess: 0x444444\n      },\n      ui: { shadow: 'rgba(0, 0, 0, 0.6)', overlay: 'rgba(0, 0, 0, 0.85)' }\n    },\n    light: {\n      background: '#fcf7c5',\n      backgroundAlt: '#f5f0c0',\n      foreground: '#281e5a',\n      foregroundBright: '#281e5a',\n      foregroundMuted: '#806060',\n      accent: '#387adf',\n      accentBright: '#006400',\n      statusOnline: '#006400',\n      categories: {\n        editor: 0x8040d0, tui: 0xd04080, bridge: 0x208040,\n        db: 0xa08000, proxy: 0x2060c0, ai: 0xc06020,\n        shell: 0x008080, dev: 0x208040, ide: 0x2060c0, lsp: 0x606060, kernel: 0x387adf\n      },\n      three: {\n        sceneBackground: 0xfcf7c5,\n        kernelOuter: 0x387adf, kernelRing: 0x006400, kernelCore: 0x387adf,\n        connectionLine: 0xa8a080, connectionActive: 0x006400, deadProcess: 0xa8a080\n      },\n      ui: { shadow: 'rgba(0, 0, 0, 0.2)', overlay: 'rgba(252, 247, 197, 0.95)' }\n    }\n  };\n  \n  // Detect theme from data attribute, URL param, or VS Code CSS vars\n  function detectTheme() {\n    // Check data attribute first (set by the HTML)\n    const dataTheme = document.body.dataset.theme;\n    if (dataTheme === 'light' || dataTheme === 'dark') return dataTheme;\n    \n    // Check URL param\n    const urlParams = new URLSearchParams(window.location.search);\n    const urlTheme = urlParams.get('theme');\n    if (urlTheme === 'light' || urlTheme === 'dark') return urlTheme;\n    \n    // Check VS Code CSS variables\n    if (typeof getComputedStyle !== 'undefined') {\n      const bgColor = getComputedStyle(document.body).getPropertyValue('--vscode-editor-background').trim();\n      if (bgColor && bgColor.startsWith('#')) {\n        const r = parseInt(bgColor.slice(1, 3), 16);\n        const g = parseInt(bgColor.slice(3, 5), 16);\n        const b = parseInt(bgColor.slice(5, 7), 16);\n        const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;\n        return luminance > 0.5 ? 'light' : 'dark';\n      }\n    }\n    \n    return 'dark';\n  }\n  \n  let currentTheme = detectTheme();\n  let scheme = colorSchemes[currentTheme];\n  let colors = scheme.categories;\n  \n  // Apply initial body styling based on detected theme\n  document.body.style.background = scheme.background;\n  document.body.style.color = scheme.foreground;\n  document.body.dataset.theme = currentTheme;\n  \n  // Show dev badge if not in VS Code\n  if (!isVSCode) {\n    const badge = document.createElement('div');\n    badge.className = 'dev-badge';\n    badge.textContent = 'DEV MODE';\n    document.body.appendChild(badge);\n  }\n  \n  let width = window.innerWidth, height = window.innerHeight;\n  let meshes = new Map(), connections = new Map(), ws;\n  let graveyard = [];\n  const MAX_GRAVEYARD = 30;\n  const GRAVEYARD_Y = -200;\n  \n  // Three.js setup\n  const scene = new THREE.Scene();\n  scene.background = new THREE.Color(scheme.three.sceneBackground);\n  \n  const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 5000);\n  camera.position.set(0, 150, 400);\n  camera.lookAt(0, 0, 0);\n  \n  const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });\n  renderer.setSize(width, height);\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setClearColor(scheme.three.sceneBackground);\n  \n  const controls = new THREE.OrbitControls(camera, renderer.domElement);\n  controls.enableDamping = true;\n  controls.dampingFactor = 0.05;\n  controls.minDistance = 20;\n  controls.maxDistance = 3000;\n  controls.enablePan = true;\n  controls.autoRotate = true;\n  controls.autoRotateSpeed = 0.3;\n  controls.target.set(0, 0, 0);\n  \n  let focusedPid = null;\n  let focusTarget = new THREE.Vector3(0, 0, 0);\n  let focusDistance = null;\n  let transitioning = false;\n  \n  // Tour mode state\n  let tourMode = false;\n  let tourIndex = 0;\n  let tourProcessList = [];\n  let tourAutoPlay = false;\n  let tourAutoPlayInterval = null;\n  const TOUR_SPEED = 2500; // ms between auto-advances\n  \n  const raycaster = new THREE.Raycaster();\n  const mouse = new THREE.Vector2();\n  \n  renderer.domElement.addEventListener('click', (e) => {\n    mouse.x = (e.clientX / width) * 2 - 1;\n    mouse.y = -(e.clientY / height) * 2 + 1;\n    \n    raycaster.setFromCamera(mouse, camera);\n    const meshArray = Array.from(meshes.values());\n    const intersects = raycaster.intersectObjects(meshArray);\n    \n    if (intersects.length > 0) {\n      const clicked = intersects[0].object;\n      const pid = clicked.userData.pid;\n      \n      if (focusedPid === String(pid)) {\n        focusedPid = null;\n        focusTarget.set(0, 0, 0);\n        focusDistance = null;\n      } else {\n        focusedPid = String(pid);\n        focusTarget.copy(clicked.position);\n        focusDistance = 80 + (clicked.userData.size || 6) * 3;\n      }\n      transitioning = true;\n      controls.autoRotate = true;\n    } else if (!e.shiftKey) {\n      focusedPid = null;\n      focusTarget.set(0, 0, 0);\n      focusDistance = null;\n      transitioning = true;\n    }\n  });\n  \n  renderer.domElement.addEventListener('dblclick', () => {\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    camera.position.set(0, 150, 400);\n  });\n  \n  // Tour Mode Functions\n  function updateTourUI() {\n    let tourUI = document.getElementById('tour-ui');\n    if (!tourUI) {\n      tourUI = document.createElement('div');\n      tourUI.id = 'tour-ui';\n      document.body.appendChild(tourUI);\n    }\n    // Update styling each time based on current theme\n    tourUI.style.cssText = `position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:${scheme.ui.overlay};padding:12px 20px;border-radius:8px;color:${scheme.foregroundBright};font-family:monospace;font-size:12px;z-index:1000;display:none;text-align:center;border:1px solid ${scheme.foregroundMuted}40;`;\n    \n    if (tourMode && tourProcessList.length > 0) {\n      const current = tourProcessList[tourIndex];\n      const mesh = meshes.get(current);\n      const name = mesh?.userData?.name || current;\n      const icon = mesh?.userData?.icon || '‚óè';\n      const category = mesh?.userData?.category || '';\n      \n      tourUI.style.display = 'block';\n      tourUI.innerHTML = `\n        <div style=\"margin-bottom:8px;font-size:14px;color:${scheme.accent};\">üé¨ TOUR MODE</div>\n        <div style=\"font-size:18px;margin-bottom:4px;color:${scheme.foregroundBright};\">${icon} ${name}</div>\n        <div style=\"color:${scheme.foregroundMuted};margin-bottom:12px;\">${category} ‚Ä¢ ${tourIndex + 1}/${tourProcessList.length}</div>\n        <div style=\"display:flex;gap:8px;justify-content:center;flex-wrap:wrap;\">\n          <button onclick=\"ProcessTreeViz.tourPrev()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">‚Üê Prev</button>\n          <button onclick=\"ProcessTreeViz.toggleAutoPlay()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">${tourAutoPlay ? '‚è∏ Stop' : '‚ñ∂ Auto'}</button>\n          <button onclick=\"ProcessTreeViz.tourNext()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">Next ‚Üí</button>\n          <button onclick=\"ProcessTreeViz.exitTour()\" style=\"padding:8px 16px;border-radius:4px;border:1px solid ${scheme.foregroundMuted}40;background:${currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)'};color:${scheme.foregroundBright};cursor:pointer;font-family:monospace;\">‚úï Exit</button>\n        </div>\n        ${tourAutoPlay ? `<div style=\"color:${scheme.accentBright};margin-top:8px;\">‚ñ∂ Auto-playing...</div>` : ''}\n      `;\n      // Hide the tour button when in tour mode\n      const btn = document.getElementById('tour-btn');\n      if (btn) btn.style.display = 'none';\n    } else {\n      tourUI.style.display = 'none';\n      // Show the tour button when not in tour mode\n      const btn = document.getElementById('tour-btn');\n      if (btn) btn.style.display = 'block';\n    }\n  }\n  \n  function buildTourList() {\n    // Build ordered list: kernel first, then by category, then by tree depth\n    const categoryOrder = ['kernel', 'ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    const list = Array.from(meshes.keys());\n    \n    list.sort((a, b) => {\n      const meshA = meshes.get(a);\n      const meshB = meshes.get(b);\n      const catA = meshA?.userData?.category || 'zzz';\n      const catB = meshB?.userData?.category || 'zzz';\n      const orderA = categoryOrder.indexOf(catA);\n      const orderB = categoryOrder.indexOf(catB);\n      return (orderA === -1 ? 99 : orderA) - (orderB === -1 ? 99 : orderB);\n    });\n    \n    return list;\n  }\n  \n  function focusOnProcess(pid) {\n    const mesh = meshes.get(pid);\n    if (!mesh) return;\n    \n    focusedPid = pid;\n    focusTarget.copy(mesh.position);\n    focusDistance = 80 + (mesh.userData.size || 6) * 3;\n    transitioning = true;\n    controls.autoRotate = true;\n  }\n  \n  function startTour() {\n    tourMode = true;\n    tourProcessList = buildTourList();\n    tourIndex = 0;\n    if (tourProcessList.length > 0) {\n      focusOnProcess(tourProcessList[0]);\n    }\n    updateTourUI();\n  }\n  \n  function exitTour() {\n    tourMode = false;\n    tourAutoPlay = false;\n    if (tourAutoPlayInterval) {\n      clearInterval(tourAutoPlayInterval);\n      tourAutoPlayInterval = null;\n    }\n    focusedPid = null;\n    focusTarget.set(0, 0, 0);\n    focusDistance = null;\n    transitioning = true;\n    updateTourUI();\n  }\n  \n  function tourNext() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex + 1) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function tourPrev() {\n    if (!tourMode || tourProcessList.length === 0) return;\n    tourIndex = (tourIndex - 1 + tourProcessList.length) % tourProcessList.length;\n    focusOnProcess(tourProcessList[tourIndex]);\n    updateTourUI();\n  }\n  \n  function toggleAutoPlay() {\n    tourAutoPlay = !tourAutoPlay;\n    if (tourAutoPlay) {\n      tourAutoPlayInterval = setInterval(tourNext, TOUR_SPEED);\n    } else {\n      if (tourAutoPlayInterval) {\n        clearInterval(tourAutoPlayInterval);\n        tourAutoPlayInterval = null;\n      }\n    }\n    updateTourUI();\n  }\n  \n  // Keyboard controls\n  document.addEventListener('keydown', (e) => {\n    // T to start tour\n    if (e.key === 't' || e.key === 'T') {\n      if (!tourMode) {\n        startTour();\n      }\n      return;\n    }\n    \n    if (tourMode) {\n      switch(e.key) {\n        case 'ArrowRight':\n        case 'l':\n        case 'L':\n          tourNext();\n          e.preventDefault();\n          break;\n        case 'ArrowLeft':\n        case 'h':\n        case 'H':\n          tourPrev();\n          e.preventDefault();\n          break;\n        case ' ':\n          toggleAutoPlay();\n          e.preventDefault();\n          break;\n        case 'Escape':\n        case 'q':\n        case 'Q':\n          exitTour();\n          e.preventDefault();\n          break;\n      }\n    }\n  });\n  \n  let processTree = { roots: [], byPid: new Map() };\n  \n  let kernelMesh = null, kernelGlow = null, kernelCore = null;\n  function createKernelNode() {\n    const group = new THREE.Group();\n    \n    const outerGeo = new THREE.SphereGeometry(35, 32, 32);\n    const outerMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelOuter, transparent: true, opacity: 0.15, wireframe: true\n    });\n    group.add(new THREE.Mesh(outerGeo, outerMat));\n    \n    const ringGeo = new THREE.TorusGeometry(25, 1.5, 8, 48);\n    const ringMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelRing, transparent: true, opacity: 0.4\n    });\n    const ring = new THREE.Mesh(ringGeo, ringMat);\n    ring.rotation.x = Math.PI / 2;\n    group.add(ring);\n    kernelGlow = ring;\n    \n    const coreGeo = new THREE.SphereGeometry(12, 24, 24);\n    const coreMat = new THREE.MeshBasicMaterial({\n      color: scheme.three.kernelCore, transparent: true, opacity: 0.7\n    });\n    const core = new THREE.Mesh(coreGeo, coreMat);\n    group.add(core);\n    kernelCore = core;\n    \n    group.userData = {\n      pid: 'kernel', name: 'Fedora Linux', icon: 'üêß', category: 'kernel',\n      cpu: 0, rss: 0, size: 35, targetPos: new THREE.Vector3(0, 0, 0), pulsePhase: 0\n    };\n    return group;\n  }\n  \n  kernelMesh = createKernelNode();\n  scene.add(kernelMesh);\n  meshes.set('kernel', kernelMesh);\n  \n  function createNodeMesh(node) {\n    const cpu = node.cpu || 0;\n    const memMB = (node.rss || 10000) / 1024;\n    const baseColor = colors[node.category] || 0x666666;\n    const size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + cpu * 0.1));\n    \n    const geo = new THREE.SphereGeometry(size, 12, 12);\n    const mat = new THREE.MeshBasicMaterial({\n      color: baseColor, transparent: true, opacity: 0.7 + cpu * 0.003\n    });\n    \n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.userData = { \n      ...node, size, baseColor, targetPos: new THREE.Vector3(),\n      pulsePhase: Math.random() * Math.PI * 2\n    };\n    return mesh;\n  }\n  \n  function createConnectionLine() {\n    const geo = new THREE.CylinderGeometry(1.5, 1.5, 1, 8);\n    const mat = new THREE.MeshBasicMaterial({\n      color: scheme.three.connectionLine, transparent: true, opacity: 0.5\n    });\n    return new THREE.Mesh(geo, mat);\n  }\n  \n  function updateConnectionMesh(conn, childPos, parentPos) {\n    const mesh = conn.line;\n    const mid = new THREE.Vector3().addVectors(childPos, parentPos).multiplyScalar(0.5);\n    mesh.position.copy(mid);\n    const dir = new THREE.Vector3().subVectors(parentPos, childPos);\n    const length = dir.length();\n    mesh.scale.set(1, length, 1);\n    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());\n  }\n  \n  function layoutTree(processes) {\n    const byPid = new Map();\n    const children = new Map();\n    \n    processes.forEach(p => {\n      byPid.set(String(p.pid), p);\n      children.set(String(p.pid), []);\n    });\n    \n    const roots = [];\n    processes.forEach(p => {\n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && byPid.has(parentPid)) {\n        children.get(parentPid).push(p);\n      } else {\n        roots.push(p);\n      }\n    });\n    \n    const categoryOrder = ['ide', 'editor', 'tui', 'dev', 'db', 'shell', 'ai', 'lsp', 'proxy', 'bridge'];\n    roots.sort((a, b) => {\n      const ai = categoryOrder.indexOf(a.category);\n      const bi = categoryOrder.indexOf(b.category);\n      return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);\n    });\n    \n    const levelHeight = 50, baseRadius = 100;\n    \n    function countDescendants(pid) {\n      const nodeChildren = children.get(pid) || [];\n      let count = nodeChildren.length;\n      nodeChildren.forEach(c => count += countDescendants(String(c.pid)));\n      return count;\n    }\n    \n    function positionNode(node, depth, angle, radius, parentX, parentZ) {\n      const pid = String(node.pid);\n      const nodeChildren = children.get(pid) || [];\n      const childCount = nodeChildren.length;\n      \n      const x = parentX + Math.cos(angle) * radius;\n      const z = parentZ + Math.sin(angle) * radius;\n      \n      node.targetX = x;\n      node.targetY = -depth * levelHeight;\n      node.targetZ = z;\n      \n      if (childCount > 0) {\n        const arcSpread = Math.min(Math.PI * 0.9, Math.PI * 0.3 * childCount);\n        const startAngle = angle - arcSpread / 2;\n        const childRadius = 35 + childCount * 10;\n        \n        nodeChildren.forEach((child, i) => {\n          const childAngle = childCount === 1 ? angle : startAngle + (arcSpread / (childCount - 1)) * i;\n          positionNode(child, depth + 1, childAngle, childRadius, x, z);\n        });\n      }\n    }\n    \n    const totalRoots = roots.length;\n    if (totalRoots > 0) {\n      const weights = roots.map(r => 1 + countDescendants(String(r.pid)) * 0.5);\n      const totalWeight = weights.reduce((a, b) => a + b, 0);\n      \n      let currentAngle = -Math.PI / 2;\n      roots.forEach((root, i) => {\n        const angleSpan = (weights[i] / totalWeight) * Math.PI * 2;\n        const angle = currentAngle + angleSpan / 2;\n        currentAngle += angleSpan;\n        positionNode(root, 0, angle, baseRadius, 0, 0);\n      });\n    }\n    \n    return { roots, byPid, children };\n  }\n  \n  function updateLabels() {\n    const container = document.getElementById('labels');\n    container.innerHTML = '';\n    scene.updateMatrixWorld();\n    \n    meshes.forEach((mesh, pid) => {\n      const pos = new THREE.Vector3();\n      mesh.getWorldPosition(pos);\n      const labelPos = pos.clone();\n      labelPos.y += (mesh.userData.size || 8) + 5;\n      labelPos.project(camera);\n      \n      const x = (labelPos.x * 0.5 + 0.5) * width;\n      const y = (-labelPos.y * 0.5 + 0.5) * height;\n      \n      if (labelPos.z < 1 && x > -100 && x < width + 100 && y > -100 && y < height + 100) {\n        const d = mesh.userData;\n        const color = '#' + (colors[d.category] || 0x666666).toString(16).padStart(6, '0');\n        const distToCamera = camera.position.distanceTo(pos);\n        // Larger base scale, less reduction with distance\n        const proximityScale = Math.max(0.7, Math.min(3, 200 / distToCamera));\n        // Higher minimum opacity - always readable\n        const opacity = focusedPid \n          ? (pid === focusedPid ? 1 : (d.parentInteresting === parseInt(focusedPid) ? 0.95 : 0.7))\n          : Math.max(0.85, Math.min(1, 400 / distToCamera));\n        \n        const cpuPct = Math.min(100, d.cpu || 0);\n        const memMB = ((d.rss || 0) / 1024).toFixed(0);\n        \n        // Extract short command for display (first 40 chars of cmdShort or cmd)\n        const cmdDisplay = d.cmdShort || d.cmd || '';\n        const cmdShort = cmdDisplay.length > 50 ? cmdDisplay.slice(0, 47) + '...' : cmdDisplay;\n        \n        const label = document.createElement('div');\n        label.className = 'proc-label';\n        label.style.left = x + 'px';\n        label.style.top = y + 'px';\n        label.style.opacity = opacity;\n        label.style.transform = 'translate(-50%, -100%) scale(' + proximityScale + ')';\n        // Show name, then command on second line, then stats\n        label.innerHTML = '<div class=\"icon\">' + (d.icon || '‚óè') + '</div>' +\n          '<div class=\"name\" style=\"color:' + color + '\">' + (d.name || pid) + '</div>' +\n          (cmdShort ? '<div class=\"cmd\" style=\"color:' + scheme.foregroundMuted + ';font-size:8px;max-width:150px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">' + cmdShort + '</div>' : '') +\n          '<div class=\"info\" style=\"color:' + scheme.foregroundMuted + ';\">' + memMB + 'MB ¬∑ ' + cpuPct.toFixed(0) + '%</div>';\n        container.appendChild(label);\n      }\n    });\n    \n    // Add labels for graveyard (dead) processes\n    graveyard.forEach((grave) => {\n      const mesh = grave.mesh;\n      if (!mesh) return;\n      \n      const pos = new THREE.Vector3();\n      mesh.getWorldPosition(pos);\n      const labelPos = pos.clone();\n      labelPos.y += 8;\n      labelPos.project(camera);\n      \n      const x = (labelPos.x * 0.5 + 0.5) * width;\n      const y = (-labelPos.y * 0.5 + 0.5) * height;\n      \n      if (labelPos.z < 1 && x > -100 && x < width + 100 && y > -100 && y < height + 100) {\n        const distToCamera = camera.position.distanceTo(pos);\n        const proximityScale = Math.max(0.5, Math.min(2, 150 / distToCamera));\n        const age = (Date.now() - grave.deathTime) / 1000;\n        const opacity = Math.max(0.3, 0.7 - age * 0.01);\n        \n        const cmdShort = grave.cmd ? (grave.cmd.length > 30 ? grave.cmd.slice(0, 27) + '...' : grave.cmd) : '';\n        const timeAgo = age < 60 ? Math.floor(age) + 's ago' : Math.floor(age / 60) + 'm ago';\n        \n        const label = document.createElement('div');\n        label.className = 'proc-label graveyard';\n        label.style.left = x + 'px';\n        label.style.top = y + 'px';\n        label.style.opacity = opacity;\n        label.style.transform = 'translate(-50%, -100%) scale(' + proximityScale + ')';\n        label.innerHTML = '<div class=\"icon\">üíÄ</div>' +\n          '<div class=\"name\" style=\"color:' + scheme.foregroundMuted + ';text-decoration:line-through;\">' + (grave.name || grave.pid) + '</div>' +\n          (cmdShort ? '<div class=\"cmd\" style=\"color:' + scheme.foregroundMuted + ';font-size:7px;opacity:0.7;max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;\">' + cmdShort + '</div>' : '') +\n          '<div class=\"info\" style=\"color:' + scheme.foregroundMuted + ';opacity:0.6;\">' + timeAgo + '</div>';\n        container.appendChild(label);\n      }\n    });\n  }\n  \n  function updateViz(processData) {\n    if (!processData?.interesting) return;\n    \n    const processes = processData.interesting;\n    document.getElementById('process-count').textContent = processes.length;\n    \n    processTree = layoutTree(processes);\n    const currentPids = new Set(processes.map(p => String(p.pid)));\n    \n    processes.forEach(p => {\n      const pid = String(p.pid);\n      \n      if (!meshes.has(pid)) {\n        const mesh = createNodeMesh(p);\n        mesh.position.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        mesh.userData.targetPos.set(p.targetX || 0, p.targetY || 0, p.targetZ || 0);\n        scene.add(mesh);\n        meshes.set(pid, mesh);\n      } else {\n        const mesh = meshes.get(pid);\n        const d = mesh.userData;\n        d.cpu = p.cpu; d.mem = p.mem; d.rss = p.rss; d.name = p.name;\n        d.targetPos.set(p.targetX || d.targetPos.x, p.targetY || d.targetPos.y, p.targetZ || d.targetPos.z);\n        \n        const memMB = (p.rss || 10000) / 1024;\n        d.size = Math.max(4, Math.min(12, 3 + memMB * 0.05 + p.cpu * 0.1));\n        mesh.scale.setScalar(d.size / 6);\n        \n        const baseColor = colors[p.category] || 0x666666;\n        const brighten = Math.min(1.8, 1 + p.cpu * 0.02);\n        const r = ((baseColor >> 16) & 255) * brighten;\n        const g = ((baseColor >> 8) & 255) * brighten;\n        const b = (baseColor & 255) * brighten;\n        mesh.material.color.setRGB(Math.min(255, r) / 255, Math.min(255, g) / 255, Math.min(255, b) / 255);\n        mesh.material.opacity = 0.7 + p.cpu * 0.003;\n      }\n      \n      const parentPid = String(p.parentInteresting || 0);\n      if (parentPid && meshes.has(parentPid)) {\n        const connKey = pid + '->' + parentPid;\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid });\n        }\n      } else {\n        const connKey = pid + '->kernel';\n        if (!connections.has(connKey)) {\n          const line = createConnectionLine();\n          scene.add(line);\n          connections.set(connKey, { line, childPid: pid, parentPid: 'kernel' });\n        }\n      }\n    });\n    \n    meshes.forEach((mesh, pid) => {\n      if (pid === 'kernel') return;\n      if (!currentPids.has(pid) && !mesh.userData.isDead) {\n        mesh.userData.isDead = true;\n        mesh.userData.deathTime = Date.now();\n        \n        const graveyardIndex = graveyard.length;\n        const col = graveyardIndex % 10;\n        const row = Math.floor(graveyardIndex / 10);\n        mesh.userData.targetPos.set((col - 4.5) * 25, GRAVEYARD_Y - row * 20, 0);\n        \n        mesh.material.opacity = 0.25;\n        mesh.material.color.setHex(scheme.three.deadProcess);\n        \n        // Store full process info for graveyard labels\n        const d = mesh.userData;\n        graveyard.push({ \n          pid, \n          mesh, \n          name: d.name,\n          icon: d.icon || 'üíÄ',\n          cmd: d.cmdShort || d.cmd || '',\n          category: d.category,\n          deathTime: Date.now() \n        });\n        meshes.delete(pid);\n        \n        while (graveyard.length > MAX_GRAVEYARD) {\n          const oldest = graveyard.shift();\n          scene.remove(oldest.mesh);\n          if (oldest.mesh.geometry) oldest.mesh.geometry.dispose();\n          if (oldest.mesh.material) oldest.mesh.material.dispose();\n        }\n      }\n    });\n    \n    const graveyardPids = new Set(graveyard.map(g => g.pid));\n    connections.forEach((conn, key) => {\n      const childExists = meshes.has(conn.childPid) || graveyardPids.has(conn.childPid);\n      const parentExists = meshes.has(conn.parentPid) || graveyardPids.has(conn.parentPid);\n      if (!childExists || !parentExists) {\n        scene.remove(conn.line);\n        conn.line.geometry.dispose();\n        conn.line.material.dispose();\n        connections.delete(key);\n      }\n    });\n    \n    // Refresh tour list if in tour mode (processes may have changed)\n    if (tourMode) {\n      const oldPid = tourProcessList[tourIndex];\n      tourProcessList = buildTourList();\n      // Try to stay on the same process if it still exists\n      const newIndex = tourProcessList.indexOf(oldPid);\n      if (newIndex !== -1) {\n        tourIndex = newIndex;\n      } else if (tourIndex >= tourProcessList.length) {\n        tourIndex = Math.max(0, tourProcessList.length - 1);\n      }\n      updateTourUI();\n    }\n  }\n  \n  let time = 0;\n  function animate() {\n    requestAnimationFrame(animate);\n    time += 0.016;\n    \n    if (focusedPid && meshes.has(focusedPid)) {\n      focusTarget.lerp(meshes.get(focusedPid).position, 0.08);\n    }\n    \n    controls.target.lerp(focusTarget, transitioning ? 0.06 : 0.02);\n    \n    if (focusDistance !== null) {\n      const currentDist = camera.position.distanceTo(controls.target);\n      if (Math.abs(currentDist - focusDistance) > 5) {\n        const dir = camera.position.clone().sub(controls.target).normalize();\n        const targetPos = controls.target.clone().add(dir.multiplyScalar(focusDistance));\n        camera.position.lerp(targetPos, 0.04);\n      } else {\n        transitioning = false;\n      }\n    } else {\n      transitioning = false;\n    }\n    \n    controls.update();\n    \n    if (kernelGlow) {\n      kernelGlow.rotation.z = time * 0.3;\n      kernelGlow.rotation.x = Math.PI / 2 + Math.sin(time * 0.5) * 0.1;\n    }\n    if (kernelCore) {\n      const pulse = 1 + Math.sin(time * 0.8) * 0.1;\n      kernelCore.scale.setScalar(pulse);\n    }\n    if (kernelMesh) {\n      kernelMesh.rotation.y = time * 0.1;\n    }\n    \n    // Graveyard animation with null checks\n    graveyard.forEach((grave, i) => {\n      const mesh = grave.mesh;\n      if (mesh && mesh.userData && mesh.material) {\n        const d = mesh.userData;\n        mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.02;\n        mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.015;\n        mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.02;\n        mesh.position.x += Math.sin(time * 0.3 + i) * 0.05;\n        const age = (Date.now() - grave.deathTime) / 1000;\n        mesh.material.opacity = Math.max(0.1, 0.3 - age * 0.005);\n      }\n    });\n    \n    // Active meshes animation with null checks\n    meshes.forEach((mesh, pid) => {\n      if (!mesh || !mesh.userData || !mesh.material) return;\n      const d = mesh.userData;\n      const cpu = d.cpu || 0;\n      const isFocused = focusedPid === pid;\n      const isRelated = focusedPid && (d.parentInteresting === parseInt(focusedPid) || String(d.parentInteresting) === focusedPid);\n      \n      mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.03;\n      mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.03;\n      mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.03;\n      \n      const float = Math.sin(time * 0.5 + d.pulsePhase) * 2;\n      mesh.position.y += float * 0.02;\n      \n      const pulseAmp = isFocused ? 0.2 : (0.1 + cpu * 0.005);\n      const pulse = 1 + Math.sin(time * (1 + cpu * 0.05) + d.pulsePhase) * pulseAmp;\n      const sizeMultiplier = isFocused ? 1.5 : (isRelated ? 1.2 : 1);\n      mesh.scale.setScalar((d.size / 6) * pulse * sizeMultiplier);\n      \n      if (focusedPid) {\n        mesh.material.opacity = isFocused ? 1 : (isRelated ? 0.8 : 0.3);\n      } else {\n        mesh.material.opacity = 0.7 + cpu * 0.003;\n      }\n    });\n    \n    connections.forEach(conn => {\n      const childMesh = meshes.get(conn.childPid);\n      const parentMesh = meshes.get(conn.parentPid);\n      if (childMesh && parentMesh) {\n        updateConnectionMesh(conn, childMesh.position, parentMesh.position);\n        const involvesFocus = focusedPid && (conn.childPid === focusedPid || conn.parentPid === focusedPid);\n        conn.line.material.opacity = focusedPid ? (involvesFocus ? 0.9 : 0.15) : 0.5;\n        conn.line.material.color.setHex(involvesFocus ? scheme.three.connectionActive : scheme.three.connectionLine);\n        const thickness = involvesFocus ? 2.5 : 1.5;\n        conn.line.scale.x = thickness / 1.5;\n        conn.line.scale.z = thickness / 1.5;\n      }\n    });\n    \n    // üå≥ AST Tree Animation (if loaded)\n    if (window.ASTTreeViz?.animateAST) {\n      window.ASTTreeViz.animateAST();\n    }\n    \n    renderer.render(scene, camera);\n    updateLabels();\n  }\n  \n  // Connection state tracking\n  let connectionState = 'disconnected'; // disconnected, connecting, connected\n  let reconnectAttempts = 0;\n  let lastConnectTime = 0;\n  \n  function updateConnectionUI() {\n    const dot = document.getElementById('status-dot');\n    let overlay = document.getElementById('connection-overlay');\n    \n    if (!overlay) {\n      overlay = document.createElement('div');\n      overlay.id = 'connection-overlay';\n      overlay.style.cssText = `\n        position: fixed; top: 0; left: 0; right: 0; bottom: 0;\n        display: flex; flex-direction: column; align-items: center; justify-content: center;\n        background: ${scheme.ui.overlay}; z-index: 500; pointer-events: none;\n        transition: opacity 0.5s ease;\n      `;\n      document.body.appendChild(overlay);\n    }\n    \n    if (connectionState === 'connected') {\n      dot?.classList.add('online');\n      overlay.style.opacity = '0';\n      setTimeout(() => { if (connectionState === 'connected') overlay.style.display = 'none'; }, 500);\n    } else {\n      dot?.classList.remove('online');\n      overlay.style.display = 'flex';\n      overlay.style.opacity = '1';\n      \n      const statusText = connectionState === 'connecting' \n        ? `Connecting to process server...` \n        : `Waiting for process server (attempt ${reconnectAttempts})`;\n      const subText = reconnectAttempts > 3 \n        ? 'Server may still be starting up...' \n        : 'ws://127.0.0.1:7890';\n      \n      overlay.innerHTML = `\n        <div style=\"font-size: 48px; margin-bottom: 16px;\">${connectionState === 'connecting' ? 'üîÑ' : '‚è≥'}</div>\n        <div style=\"font-size: 16px; color: ${scheme.foregroundBright}; margin-bottom: 8px;\">${statusText}</div>\n        <div style=\"font-size: 12px; color: ${scheme.foregroundMuted};\">${subText}</div>\n        ${reconnectAttempts > 5 ? `<button onclick=\"location.reload()\" style=\"margin-top: 16px; padding: 8px 16px; background: ${scheme.accent}; border: none; border-radius: 4px; color: ${scheme.foregroundBright}; cursor: pointer; pointer-events: auto;\">üîÑ Refresh Page</button>` : ''}\n      `;\n    }\n  }\n  \n  function connectWS() {\n    connectionState = 'connecting';\n    reconnectAttempts++;\n    updateConnectionUI();\n    \n    try {\n      ws = new WebSocket('ws://127.0.0.1:7890/ws');\n      \n      ws.onopen = () => {\n        connectionState = 'connected';\n        reconnectAttempts = 0;\n        lastConnectTime = Date.now();\n        updateConnectionUI();\n        console.log('üü¢ Connected to process server');\n      };\n      \n      ws.onclose = () => {\n        connectionState = 'disconnected';\n        updateConnectionUI();\n        // Exponential backoff: 1s, 2s, 4s, 8s, max 10s\n        const delay = Math.min(1000 * Math.pow(2, Math.min(reconnectAttempts - 1, 3)), 10000);\n        console.log(`üî¥ Disconnected, reconnecting in ${delay}ms (attempt ${reconnectAttempts})`);\n        setTimeout(connectWS, delay);\n      };\n      \n      ws.onerror = (err) => {\n        console.log('üî¥ WebSocket error:', err);\n        ws.close();\n      };\n      \n      ws.onmessage = (e) => {\n        try {\n          const data = JSON.parse(e.data);\n          if (data.system) {\n            document.getElementById('uptime').textContent = data.system.uptime.formatted;\n            document.getElementById('cpus').textContent = data.system.cpus;\n            const m = data.system.memory;\n            document.getElementById('mem-text').textContent = m.used + ' / ' + m.total;\n          }\n          updateViz(data.processes);\n        } catch {}\n      };\n    } catch (err) {\n      console.log('üî¥ WebSocket creation error:', err);\n      connectionState = 'disconnected';\n      updateConnectionUI();\n      setTimeout(connectWS, 2000);\n    }\n  }\n  \n  window.addEventListener('resize', () => {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(width, height);\n  });\n  \n  // üé® Theme switching function\n  function setTheme(themeName) {\n    if (themeName !== 'light' && themeName !== 'dark') return;\n    currentTheme = themeName;\n    scheme = colorSchemes[currentTheme];\n    colors = scheme.categories;\n    \n    // Update scene background\n    scene.background.setHex(scheme.three.sceneBackground);\n    renderer.setClearColor(scheme.three.sceneBackground);\n    \n    // Update body styling\n    document.body.dataset.theme = themeName;\n    document.body.style.background = scheme.background;\n    document.body.style.color = scheme.foreground;\n    \n    // Update kernel mesh colors\n    if (kernelMesh) {\n      kernelMesh.children[0].material.color.setHex(scheme.three.kernelOuter);\n      if (kernelGlow) kernelGlow.material.color.setHex(scheme.three.kernelRing);\n      if (kernelCore) kernelCore.material.color.setHex(scheme.three.kernelCore);\n    }\n    \n    // Update all process node colors\n    meshes.forEach((mesh, pid) => {\n      if (pid === 'kernel') return;\n      const category = mesh.userData.category;\n      const newColor = colors[category] || 0x666666;\n      mesh.material.color.setHex(newColor);\n      mesh.userData.baseColor = newColor;\n    });\n    \n    // Update connections\n    connections.forEach(conn => {\n      conn.line.material.color.setHex(scheme.three.connectionLine);\n    });\n    \n    // Update graveyard\n    graveyard.forEach(grave => {\n      if (grave.mesh && grave.mesh.material) {\n        grave.mesh.material.color.setHex(scheme.three.deadProcess);\n      }\n    });\n    \n    // Update CSS styles\n    updateThemeStyles();\n  }\n  \n  function toggleTheme() {\n    setTheme(currentTheme === 'dark' ? 'light' : 'dark');\n    return currentTheme;\n  }\n  \n  function updateThemeStyles() {\n    // Update dynamic CSS based on theme\n    let styleEl = document.getElementById('theme-dynamic-styles');\n    if (!styleEl) {\n      styleEl = document.createElement('style');\n      styleEl.id = 'theme-dynamic-styles';\n      document.head.appendChild(styleEl);\n    }\n    styleEl.textContent = `\n      .title .dot { color: ${scheme.accentBright}; }\n      .status-dot { background: ${scheme.accent}; }\n      .status-dot.online { background: ${scheme.statusOnline}; }\n      .stats { color: ${scheme.foregroundMuted}; }\n      .stats .val { color: ${scheme.foregroundBright}; }\n      .mem { color: ${scheme.foregroundMuted}; }\n      .center { color: ${scheme.foregroundMuted}; }\n      .center .count { color: ${scheme.foregroundBright}; }\n      .proc-label { text-shadow: 0 0 3px ${scheme.background}, 0 0 6px ${scheme.background}; }\n      .proc-label .info { color: ${scheme.foregroundMuted}; }\n      .dev-badge { background: ${currentTheme === 'light' ? scheme.accentBright : scheme.accentBright}; color: ${currentTheme === 'light' ? '#fff' : '#000'}; }\n      #tour-ui { background: ${scheme.ui.overlay}; border-color: ${scheme.foregroundMuted}; }\n      #tour-hint { background: ${scheme.ui.overlay}; }\n    `;\n  }\n  \n  // Apply initial theme styles\n  updateThemeStyles();\n  \n  // Expose for external use (mock data injection, etc.)\n  window.ProcessTreeViz = {\n    updateViz,\n    scene,\n    camera,\n    meshes,\n    connections,\n    graveyard,\n    // Tour mode\n    startTour,\n    exitTour,\n    tourNext,\n    tourPrev,\n    toggleAutoPlay,\n    isTourMode: () => tourMode,\n    // Theme control\n    setTheme,\n    toggleTheme,\n    getTheme: () => currentTheme,\n    getScheme: () => scheme,\n    colorSchemes\n  };\n  \n  // Add tour button to the UI (touch-friendly, no keyboard shortcuts)\n  const tourBtn = document.createElement('button');\n  tourBtn.id = 'tour-btn';\n  tourBtn.style.cssText = `position:fixed;bottom:20px;right:20px;background:${scheme.ui.overlay};padding:10px 16px;border-radius:6px;color:${scheme.foregroundMuted};font-family:monospace;font-size:12px;z-index:999;border:1px solid ${scheme.foregroundMuted}40;cursor:pointer;`;\n  tourBtn.textContent = 'üé¨ Tour';\n  tourBtn.onclick = () => { if (!tourMode) startTour(); else exitTour(); };\n  document.body.appendChild(tourBtn);\n  \n  animate();\n  connectWS();\n})();";

export const AST_TREE_JS = "// 3D AST Tree Visualization\n// Renders JavaScript/TypeScript AST as interactive 3D trees\n\n(function() {\n  'use strict';\n  \n  // Only initialize if we have ProcessTreeViz (shared scene)\n  if (!window.ProcessTreeViz) {\n    console.warn('AST visualization requires ProcessTreeViz to be loaded first');\n    return;\n  }\n  \n  const { scene, camera, colorSchemes } = window.ProcessTreeViz;\n  let currentTheme = window.ProcessTreeViz.getTheme();\n  let scheme = colorSchemes[currentTheme];\n  \n  // AST visualization state\n  const astMeshes = new Map(); // fileName -> { root, nodes: Map<id, mesh> }\n  const astConnections = new Map();\n  let astFiles = [];\n  \n  // AST node colors by type\n  const nodeColors = {\n    Program: 0x88ccff,\n    FunctionDeclaration: 0xb06bff,\n    FunctionExpression: 0xb06bff,\n    ArrowFunctionExpression: 0xa060e0,\n    ClassDeclaration: 0xff69b4,\n    ClassExpression: 0xff69b4,\n    MethodDefinition: 0xe050a0,\n    VariableDeclaration: 0x6bff9f,\n    VariableDeclarator: 0x50d080,\n    ImportDeclaration: 0xffeb6b,\n    ExportNamedDeclaration: 0xffc040,\n    ExportDefaultDeclaration: 0xffa030,\n    CallExpression: 0x6b9fff,\n    MemberExpression: 0x5080d0,\n    Identifier: 0x888888,\n    Literal: 0x666666,\n    ObjectExpression: 0x6bffff,\n    ArrayExpression: 0x50d0d0,\n    IfStatement: 0xff9f6b,\n    ForStatement: 0xe08050,\n    WhileStatement: 0xd07040,\n    ReturnStatement: 0x80ff80,\n    BlockStatement: 0x555555,\n    ExpressionStatement: 0x444444,\n  };\n  \n  // Position offset for AST trees (to the right of process tree)\n  const AST_OFFSET_X = 300;\n  const AST_OFFSET_Z = 0;\n  \n  function getNodeColor(type) {\n    return nodeColors[type] || 0x666666;\n  }\n  \n  function getNodeSize(node) {\n    // Size based on code span and importance\n    const span = node.end - node.start;\n    const baseSize = Math.max(3, Math.min(10, 2 + Math.log(span + 1) * 0.8));\n    \n    // Boost important node types\n    const important = ['FunctionDeclaration', 'ClassDeclaration', 'MethodDefinition', 'Program'];\n    if (important.includes(node.type)) return baseSize * 1.3;\n    return baseSize;\n  }\n  \n  function createASTNodeMesh(node) {\n    const size = getNodeSize(node);\n    const color = getNodeColor(node.type);\n    \n    const geo = new THREE.SphereGeometry(size, 10, 10);\n    const mat = new THREE.MeshBasicMaterial({\n      color: color,\n      transparent: true,\n      opacity: 0.8,\n    });\n    \n    const mesh = new THREE.Mesh(geo, mat);\n    mesh.userData = {\n      ...node,\n      size,\n      baseColor: color,\n      targetPos: new THREE.Vector3(),\n      pulsePhase: Math.random() * Math.PI * 2,\n    };\n    \n    return mesh;\n  }\n  \n  function createASTConnection() {\n    const geo = new THREE.CylinderGeometry(0.8, 0.8, 1, 6);\n    const mat = new THREE.MeshBasicMaterial({\n      color: scheme.three.connectionLine,\n      transparent: true,\n      opacity: 0.4,\n    });\n    return new THREE.Mesh(geo, mat);\n  }\n  \n  function updateConnectionMesh(conn, childPos, parentPos) {\n    const mesh = conn.line;\n    const mid = new THREE.Vector3().addVectors(childPos, parentPos).multiplyScalar(0.5);\n    mesh.position.copy(mid);\n    const dir = new THREE.Vector3().subVectors(parentPos, childPos);\n    const length = dir.length();\n    mesh.scale.set(1, length, 1);\n    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());\n  }\n  \n  function layoutASTTree(root, fileIndex = 0) {\n    if (!root) return;\n    \n    const levelHeight = 30;\n    const baseX = AST_OFFSET_X + fileIndex * 200;\n    const baseZ = AST_OFFSET_Z;\n    \n    function positionNode(node, depth, angle, radius, parentX, parentZ) {\n      const childCount = node.children?.length || 0;\n      \n      const x = parentX + Math.cos(angle) * radius;\n      const z = parentZ + Math.sin(angle) * radius;\n      const y = -depth * levelHeight;\n      \n      node.targetX = x;\n      node.targetY = y;\n      node.targetZ = z;\n      \n      if (childCount > 0) {\n        const arcSpread = Math.min(Math.PI * 1.2, Math.PI * 0.25 * childCount);\n        const startAngle = angle - arcSpread / 2;\n        const childRadius = 20 + childCount * 5;\n        \n        node.children.forEach((child, i) => {\n          const childAngle = childCount === 1 ? angle : startAngle + (arcSpread / Math.max(1, childCount - 1)) * i;\n          positionNode(child, depth + 1, childAngle, childRadius, x, z);\n        });\n      }\n    }\n    \n    positionNode(root, 0, -Math.PI / 2, 0, baseX, baseZ);\n  }\n  \n  function updateASTVisualization(files) {\n    astFiles = files;\n    \n    // Track which files are still present\n    const currentFileNames = new Set(files.map(f => f.fileName));\n    \n    // Remove old file visualizations\n    astMeshes.forEach((fileData, fileName) => {\n      if (!currentFileNames.has(fileName)) {\n        fileData.nodes.forEach(mesh => {\n          scene.remove(mesh);\n          mesh.geometry.dispose();\n          mesh.material.dispose();\n        });\n        astMeshes.delete(fileName);\n      }\n    });\n    \n    // Remove old connections for removed files\n    astConnections.forEach((conn, key) => {\n      const fileName = key.split('-')[0];\n      if (!currentFileNames.has(fileName)) {\n        scene.remove(conn.line);\n        conn.line.geometry.dispose();\n        conn.line.material.dispose();\n        astConnections.delete(key);\n      }\n    });\n    \n    // Update/create visualizations for each file\n    files.forEach((file, fileIndex) => {\n      if (!file.ast) return;\n      \n      layoutASTTree(file.ast, fileIndex);\n      \n      // Get or create file data\n      let fileData = astMeshes.get(file.fileName);\n      if (!fileData) {\n        fileData = { nodes: new Map() };\n        astMeshes.set(file.fileName, fileData);\n      }\n      \n      const currentNodeIds = new Set();\n      \n      // Process all nodes recursively\n      function processNode(node, parentId) {\n        if (!node) return;\n        \n        currentNodeIds.add(node.id);\n        \n        // Create or update mesh\n        let mesh = fileData.nodes.get(node.id);\n        if (!mesh) {\n          mesh = createASTNodeMesh(node);\n          mesh.position.set(node.targetX || 0, node.targetY || 0, node.targetZ || 0);\n          scene.add(mesh);\n          fileData.nodes.set(node.id, mesh);\n        }\n        \n        // Update target position\n        mesh.userData.targetPos.set(node.targetX || 0, node.targetY || 0, node.targetZ || 0);\n        mesh.userData.name = node.name;\n        mesh.userData.type = node.type;\n        \n        // Create connection to parent\n        if (parentId) {\n          const connKey = `${node.id}->${parentId}`;\n          if (!astConnections.has(connKey)) {\n            const line = createASTConnection();\n            scene.add(line);\n            astConnections.set(connKey, { line, childId: node.id, parentId, fileName: file.fileName });\n          }\n        }\n        \n        // Process children\n        if (node.children) {\n          node.children.forEach(child => processNode(child, node.id));\n        }\n      }\n      \n      processNode(file.ast, null);\n      \n      // Remove nodes that no longer exist\n      fileData.nodes.forEach((mesh, nodeId) => {\n        if (!currentNodeIds.has(nodeId)) {\n          scene.remove(mesh);\n          mesh.geometry.dispose();\n          mesh.material.dispose();\n          fileData.nodes.delete(nodeId);\n        }\n      });\n    });\n    \n    // Clean up orphaned connections\n    astConnections.forEach((conn, key) => {\n      const [childPart] = key.split('->');\n      const fileName = childPart.split('-')[0];\n      const fileData = astMeshes.get(fileName);\n      \n      if (!fileData || !fileData.nodes.has(conn.childId) || !fileData.nodes.has(conn.parentId)) {\n        scene.remove(conn.line);\n        conn.line.geometry.dispose();\n        conn.line.material.dispose();\n        astConnections.delete(key);\n      }\n    });\n    \n    // Update AST labels\n    updateASTLabels();\n  }\n  \n  function updateASTLabels() {\n    let container = document.getElementById('ast-labels');\n    if (!container) {\n      container = document.createElement('div');\n      container.id = 'ast-labels';\n      container.className = 'label-container';\n      document.body.appendChild(container);\n    }\n    container.innerHTML = '';\n    \n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    \n    astMeshes.forEach((fileData, fileName) => {\n      fileData.nodes.forEach((mesh, nodeId) => {\n        const pos = new THREE.Vector3();\n        mesh.getWorldPosition(pos);\n        const labelPos = pos.clone();\n        labelPos.y += (mesh.userData.size || 5) + 3;\n        labelPos.project(camera);\n        \n        const x = (labelPos.x * 0.5 + 0.5) * width;\n        const y = (-labelPos.y * 0.5 + 0.5) * height;\n        \n        if (labelPos.z < 1 && x > -50 && x < width + 50 && y > -50 && y < height + 50) {\n          const d = mesh.userData;\n          const distToCamera = camera.position.distanceTo(pos);\n          const proximityScale = Math.max(0.4, Math.min(2, 120 / distToCamera));\n          const opacity = Math.max(0.5, Math.min(1, 250 / distToCamera));\n          \n          // Only show labels for important nodes or when zoomed in\n          const important = ['FunctionDeclaration', 'ClassDeclaration', 'MethodDefinition', 'VariableDeclaration', 'ImportDeclaration', 'ExportNamedDeclaration'];\n          if (distToCamera > 150 && !important.includes(d.type)) return;\n          \n          const color = '#' + (d.baseColor || 0x666666).toString(16).padStart(6, '0');\n          \n          const label = document.createElement('div');\n          label.className = 'proc-label ast-label';\n          label.style.left = x + 'px';\n          label.style.top = y + 'px';\n          label.style.opacity = opacity;\n          label.style.transform = 'translate(-50%, -100%) scale(' + proximityScale + ')';\n          label.innerHTML = \n            '<div class=\"name\" style=\"color:' + color + ';font-size:9px;\">' + (d.name || d.type) + '</div>' +\n            '<div class=\"info\" style=\"color:' + scheme.foregroundMuted + ';font-size:7px;\">' + d.type + '</div>';\n          container.appendChild(label);\n        }\n      });\n    });\n  }\n  \n  // Animation hook - call from main animation loop\n  let time = 0;\n  function animateAST() {\n    time += 0.016;\n    \n    // Animate AST nodes\n    astMeshes.forEach((fileData) => {\n      fileData.nodes.forEach((mesh) => {\n        const d = mesh.userData;\n        if (!d.targetPos) return;\n        \n        // Smooth movement to target\n        mesh.position.x += (d.targetPos.x - mesh.position.x) * 0.08;\n        mesh.position.y += (d.targetPos.y - mesh.position.y) * 0.08;\n        mesh.position.z += (d.targetPos.z - mesh.position.z) * 0.08;\n        \n        // Gentle pulse\n        const pulse = 1 + Math.sin(time * 0.8 + d.pulsePhase) * 0.1;\n        mesh.scale.setScalar((d.size / 6) * pulse);\n      });\n    });\n    \n    // Update connections\n    astConnections.forEach(conn => {\n      const fileName = conn.fileName;\n      const fileData = astMeshes.get(fileName);\n      if (!fileData) return;\n      \n      const childMesh = fileData.nodes.get(conn.childId);\n      const parentMesh = fileData.nodes.get(conn.parentId);\n      if (childMesh && parentMesh) {\n        updateConnectionMesh(conn, childMesh.position, parentMesh.position);\n      }\n    });\n    \n    // Update labels\n    updateASTLabels();\n  }\n  \n  // Expose API\n  window.ASTTreeViz = {\n    updateASTVisualization,\n    animateAST,\n    astMeshes,\n    astConnections,\n    getNodeColor,\n  };\n  \n  console.log('üå≥ AST Tree Visualization loaded');\n})();\n";
