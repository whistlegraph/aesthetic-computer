<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AC Pane</title>
  <link rel="stylesheet" href="../node_modules/@xterm/xterm/css/xterm.css">
  <style>
    /* Theme color variables - changes based on system light/dark mode */
    :root {
      /* Dark mode (default) - purple theme */
      --ac-border: rgba(136, 68, 255, 0.25);
      --ac-border-solid: rgba(136, 68, 255, 0.4);
      --ac-border-hover: rgba(136, 68, 255, 0.5);
      --ac-border-active: rgba(136, 68, 255, 0.7);
      --ac-accent: rgba(136, 68, 255, 0.6);
      --ac-accent-glow: rgba(136, 68, 255, 0.5);
      --ac-shadow-inner: rgba(136, 68, 255, 0.2);
      --ac-tab-back: rgba(60, 40, 100, 0.6);
      --ac-tab-back-hover: rgba(80, 50, 130, 0.8);
      --ac-tab-back-accent: rgba(100, 60, 160, 0.6);
      --ac-tab-back-accent-hover: rgba(140, 90, 200, 1);
      --ac-front-bg: #111;
      --ac-back-bg: #0a0a12;
      --ac-text: #fff;
      --ac-text-muted: #888;
    }
    
    /* Light mode - golden/sand theme (matching legal pad yellow) */
    @media (prefers-color-scheme: light) {
      :root {
        /* Using #c8a050 (200, 160, 80) as the base golden color */
        --ac-border: rgba(200, 160, 80, 0.35);
        --ac-border-solid: rgba(200, 160, 80, 0.5);
        --ac-border-hover: rgba(200, 160, 80, 0.65);
        --ac-border-active: rgba(200, 160, 80, 0.85);
        --ac-accent: rgba(200, 160, 80, 0.6);
        --ac-accent-glow: rgba(200, 160, 80, 0.5);
        --ac-shadow-inner: rgba(200, 160, 80, 0.25);
        --ac-tab-back: rgba(200, 160, 80, 0.4);
        --ac-tab-back-hover: rgba(200, 160, 80, 0.6);
        --ac-tab-back-accent: rgba(200, 160, 80, 0.5);
        --ac-tab-back-accent-hover: rgba(200, 160, 80, 0.9);
        --ac-front-bg: #fcf7c5;
        --ac-back-bg: #f5f0c0;
        --ac-text: #281e5a;
        --ac-text-muted: #666;
      }
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { 
      width: 100%; 
      height: 100%; 
      overflow: hidden;
      background: transparent;
      font-family: system-ui, sans-serif;
      user-select: none;
      -webkit-user-select: none;
      perspective: 1500px;
    }
    
    /* 
     * 3D FLIP LAYOUT:
     * - Everything flips together like a physical card
     * - Desktop shows through during flip (transparent)
     * - Thick border frames the content
     * - Side tabs and mode tags flip too (blank backsides)
     */
    
    /* Perspective container - static, provides 3D context */
    .flip-perspective {
      position: fixed;
      top: 40px;  /* Extra space at top for flip animation headroom */
      left: 30px;  /* Extra space for wider flip tabs */
      right: 30px;  /* Extra space for wider flip tabs */
      bottom: 56px;  /* Extra space at bottom for mode tags + flip headroom */
      perspective: 1200px;
      perspective-origin: center center;
    }
    
    /* The flipping card - this actually rotates in 3D */
    .flip-card {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      transition: transform 0.7s cubic-bezier(0.4, 0, 0.2, 1);
      /* Rotation angle set via JS inline style */
    }
    
    /* Shared face styles - positioned in 3D space */
    .card-face {
      position: absolute;
      inset: 0;
      border: 6px solid var(--ac-border);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
                  inset 0 0 0 1px var(--ac-shadow-inner);
      background: transparent;
      /* No transition - JS controls the swap at midpoint */
    }
    
    /* Front face - webview - active and interactive when not flipped */
    .card-front {
      z-index: 1;
      opacity: 1;
      filter: none;
      background: var(--ac-front-bg);
    }
    
    /* Midflip class applied by JS at exact midpoint */
    body.midflip .card-front {
      z-index: 3;
      opacity: 0.15;
      filter: blur(2px);
      pointer-events: none;
    }

    .card-front webview {
      width: 100%;
      height: 100%;
      border: none;
    }
    
    /* Back face - terminal - ghost ON TOP when not flipped */
    .card-back {
      z-index: 3;
      transform: rotateY(180deg);
      opacity: 0.15;
      filter: blur(2px);
      pointer-events: none;
      background: var(--ac-back-bg);
    }
    
    /* Midflip class - back becomes active */
    body.midflip .card-back {
      z-index: 1;
      opacity: 1;
      filter: none;
      pointer-events: auto;
    }
    
    #terminal-container {
      width: 100%;
      height: 100%;
      padding: 12px;
    }
    
    .xterm { height: 100%; }
    .xterm-viewport { padding-top: 0 !important; }
    
    /* Flip tabs - attached to card edges, swap appearance on flip */
    .flip-tab {
      position: absolute;
      z-index: 250;
      width: 26px;
      top: 50%;
      height: 80px;
      cursor: pointer;
      transform: translateY(-50%);
      /* Don't set app-region here - we need click events on the parent */
    }

    .flip-tab:hover {
      cursor: pointer;
    }

    /* Tab front face - visible when not flipped */
    .flip-tab .tab-front {
      position: absolute;
      inset: 0;
      background: var(--ac-border-solid);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .flip-tab .tab-front::after {
      content: '';
      width: 3px;
      height: 30px;
      background: var(--ac-accent);
      border-radius: 2px;
      transition: all 0.2s ease;
      pointer-events: none; /* Don't block parent clicks */
    }
    
    .flip-tab:hover .tab-front {
      background: var(--ac-border-hover);
    }
    
    .flip-tab:hover .tab-front::after {
      background: var(--ac-border-active);
      height: 50px;
      box-shadow: 0 0 12px var(--ac-accent-glow);
    }
    
    /* Tab back face - visible when flipped */
    .flip-tab .tab-back {
      position: absolute;
      inset: 0;
      background: var(--ac-tab-back);
      opacity: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .flip-tab .tab-back::after {
      content: '';
      width: 3px;
      height: 30px;
      background: var(--ac-tab-back-accent);
      border-radius: 2px;
      transition: all 0.2s ease;
      pointer-events: none; /* Don't block parent clicks */
    }
    
    /* Hover effect for back tab */
    .flip-tab:hover .tab-back {
      background: var(--ac-tab-back-hover);
    }
    
    .flip-tab:hover .tab-back::after {
      background: var(--ac-tab-back-accent-hover);
      height: 50px;
      box-shadow: 0 0 12px var(--ac-accent-glow);
    }
    
    /* When midflip, swap front/back visibility */
    body.midflip .flip-tab .tab-front {
      opacity: 0;
    }
    
    body.midflip .flip-tab .tab-back {
      opacity: 1;
    }
    
    /* Left tab - on left edge */
    .flip-tab.left {
      left: -26px;
    }
    
    .flip-tab.left .tab-front,
    .flip-tab.left .tab-back {
      border-radius: 6px 0 0 6px;
    }
    
    /* Right tab - on right edge */
    .flip-tab.right {
      right: -26px;
    }
    
    .flip-tab.right .tab-front,
    .flip-tab.right .tab-back {
      border-radius: 0 6px 6px 0;
    }

    /* Volume control - integrated into top-right corner of frame */
    .volume-control {
      position: absolute;
      right: 0;
      top: -26px;
      z-index: 240;
      height: 26px;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 6px;
      padding: 4px 12px 4px 10px;
      border-radius: 10px 10px 0 0;
      background: var(--ac-border-solid);
      border: 1px solid var(--ac-border);
      border-bottom: none;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
    }

    body.midflip .volume-control {
      background: var(--ac-tab-back);
      border-color: var(--ac-border-solid);
    }

    .volume-icon {
      font-size: 12px;
      opacity: 0.7;
    }

    .volume-value {
      font-size: 11px;
      color: var(--ac-text);
      min-width: 20px;
      text-align: right;
    }

    #volume-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 72px;
      height: 4px;
      background: var(--ac-border-solid);
      border-radius: 2px;
      cursor: pointer;
    }

    #volume-slider::-webkit-slider-runnable-track {
      height: 4px;
      background: transparent;
      border-radius: 2px;
    }

    #volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: var(--ac-accent);
      border: 1px solid var(--ac-border-active);
      box-shadow: 0 0 8px var(--ac-accent-glow);
      margin-top: -4px;
    }

    #volume-slider::-moz-range-track {
      height: 4px;
      background: transparent;
      border-radius: 2px;
    }

    #volume-slider::-moz-range-thumb {
      width: 11px;
      height: 11px;
      border-radius: 50%;
      background: var(--ac-accent);
      border: 1px solid var(--ac-border-active);
      box-shadow: 0 0 8px var(--ac-accent-glow);
    }

    /* Backend controls - appears on backend side (counter-rotated to fix mirroring) */
    .backend-controls {
      position: absolute;
      z-index: 100;
      bottom: -32px;
      left: 50%;
      transform: translateX(-50%) rotateY(180deg);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
      display: flex;
      gap: 4px;
    }

    body.midflip .backend-controls {
      opacity: 1;
      pointer-events: auto;
    }

    .backend-controls button {
      font-size: 16px;
      font-weight: 700;
      padding: 4px 16px 6px 16px;
      border-radius: 0 0 6px 6px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .backend-controls button.start-btn {
      background: var(--ac-border-hover);
      color: var(--ac-text);
    }

    .backend-controls button.start-btn:hover {
      background: var(--ac-border-active);
      box-shadow: 0 2px 12px var(--ac-accent-glow);
    }

    .backend-controls button.start-btn:disabled {
      background: var(--ac-border);
      color: var(--ac-text-muted);
      cursor: not-allowed;
    }

    .backend-controls button.stop-btn {
      background: var(--ac-accent);
      color: var(--ac-text);
    }

    .backend-controls button.stop-btn:hover {
      background: var(--ac-border-active);
      box-shadow: 0 2px 12px var(--ac-accent-glow);
    }

    .backend-controls button.stop-btn:disabled {
      background: var(--ac-border);
      color: var(--ac-text-muted);
      cursor: not-allowed;
    }


    /* Resize handles on the card border edge */
    .resize-handle {
      position: fixed;
      z-index: 600;
      /* Debug: background: rgba(255,0,0,0.2); */
    }
    
    /* Positions aligned with flip-perspective: top: 40px, left/right: 30px, bottom: 56px */
    .resize-handle.top {
      top: 34px; left: 24px; right: 24px; height: 12px;
      cursor: n-resize;
    }
    
    .resize-handle.bottom {
      bottom: 50px; left: 24px; right: 24px; height: 12px;
      cursor: s-resize;
    }
    
    /* Left side - split into top and bottom sections, leaving gap for flip tab */
    .resize-handle.left-top {
      left: 24px; top: 46px; height: calc(50% - 90px); width: 12px;
      cursor: w-resize;
    }
    
    .resize-handle.left-bottom {
      left: 24px; bottom: 62px; height: calc(50% - 90px); width: 12px;
      cursor: w-resize;
    }
    
    /* Right side - split into top and bottom sections, leaving gap for flip tab */
    .resize-handle.right-top {
      right: 24px; top: 46px; height: calc(50% - 90px); width: 12px;
      cursor: e-resize;
    }
    
    .resize-handle.right-bottom {
      right: 24px; bottom: 62px; height: calc(50% - 90px); width: 12px;
      cursor: e-resize;
    }
    
    .resize-handle.top-left {
      top: 34px; left: 24px; width: 16px; height: 16px;
      cursor: nw-resize;
    }
    
    .resize-handle.top-right {
      top: 34px; right: 24px; width: 16px; height: 16px;
      cursor: ne-resize;
    }
    
    .resize-handle.bottom-left {
      bottom: 50px; left: 24px; width: 16px; height: 16px;
      cursor: sw-resize;
    }
    
    .resize-handle.bottom-right {
      bottom: 50px; right: 24px; width: 16px; height: 16px;
      cursor: se-resize;
    }
    
    /* Overlay to capture mouse during resize drag */
    .resize-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      cursor: inherit;
      display: none;
    }
    
    /* Backend welcome screen */
    .backend-welcome {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, #0a0a18 0%, #12081f 50%, #0a0a18 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 10;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
    }
    
    .backend-welcome.hidden {
      display: none;
    }
    
    .backend-welcome h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: #f0f;
      text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }
    
    .backend-welcome .subtitle {
      font-size: 11px;
      color: #888;
      margin-bottom: 24px;
    }
    
    .backend-welcome .hint-text {
      font-size: 10px;
      color: #666;
      margin-top: 16px;
      padding: 8px 16px;
      background: rgba(136, 68, 255, 0.1);
      border-radius: 4px;
    }
    
    .backend-welcome .info-section {
      width: 100%;
      max-width: 400px;
      margin-bottom: 20px;
    }
    
    .backend-welcome .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 11px;
    }
    
    .backend-welcome .info-label {
      color: #666;
    }
    
    .backend-welcome .info-value {
      color: #aaa;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 10px;
    }
    
    .backend-welcome .info-value.success {
      color: #0f0;
    }
    
    .backend-welcome .info-value.warning {
      color: #ff9500;
    }
    
    .backend-welcome .info-value.error {
      color: #f55;
    }
    
    .backend-welcome .info-value.loading {
      color: #888;
    }
    
    .backend-welcome .info-value.loading::after {
      content: '';
      display: inline-block;
      width: 4px;
      height: 4px;
      margin-left: 6px;
      background: #888;
      border-radius: 50%;
      animation: pulse 1s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.3; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1.2); }
    }
    
    .backend-welcome .start-button {
      background: linear-gradient(180deg, #8844ff 0%, #6622dd 100%);
      color: #fff;
      border: none;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 16px rgba(136, 68, 255, 0.4);
      margin-top: 8px;
    }
    
    .backend-welcome .start-button:hover {
      background: linear-gradient(180deg, #9955ff 0%, #7733ee 100%);
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(136, 68, 255, 0.5);
    }
    
    .backend-welcome .start-button:active {
      transform: translateY(0);
    }
    
    .backend-welcome .start-button:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
      box-shadow: none;
    }
    
    .backend-welcome .start-button.secondary {
      background: linear-gradient(180deg, #333 0%, #222 100%);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      margin-top: 8px;
      padding: 10px 24px;
      font-size: 12px;
    }
    
    .backend-welcome .start-button.secondary:hover {
      background: linear-gradient(180deg, #444 0%, #333 100%);
    }
    
    .backend-welcome .button-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .resize-overlay.active {
      display: block;
    }
    
    /* Spinner cursor during swivel animation */
    body.swiveling,
    body.swiveling * {
      cursor: wait !important;
    }
    
    /* Disable pointer events on content during resize */
    body.resizing .view,
    body.resizing webview {
      pointer-events: none !important;
    }

  </style>
</head>
<body>
  <!-- Overlay to capture mouse during resize -->
  <div class="resize-overlay" id="resize-overlay"></div>
  
  <!-- Resize handles on the card border (split on sides to avoid flip tabs) -->
  <div class="resize-handle top" data-resize="top"></div>
  <div class="resize-handle bottom" data-resize="bottom"></div>
  <div class="resize-handle left-top" data-resize="left"></div>
  <div class="resize-handle left-bottom" data-resize="left"></div>
  <div class="resize-handle right-top" data-resize="right"></div>
  <div class="resize-handle right-bottom" data-resize="right"></div>
  <div class="resize-handle top-left" data-resize="top-left"></div>
  <div class="resize-handle top-right" data-resize="top-right"></div>
  <div class="resize-handle bottom-left" data-resize="bottom-left"></div>
  <div class="resize-handle bottom-right" data-resize="bottom-right"></div>
  
  <!-- Perspective container -->
  <div class="flip-perspective">
    <!-- The flipping card with front and back faces -->
    <div class="flip-card">
      <!-- Flip tabs - inside card so they swivel with it -->
      <div class="flip-tab left" data-flip>
        <div class="tab-front"></div>
        <div class="tab-back"></div>
      </div>
      <div class="flip-tab right" data-flip>
        <div class="tab-front"></div>
        <div class="tab-back"></div>
      </div>

      <div class="volume-control" aria-label="Master volume">
        <span class="volume-icon">üîä</span>
        <input id="volume-slider" type="range" min="0" max="1" step="0.01" value="0.25" />
        <div class="volume-value" id="volume-value">25</div>
      </div>
      
      <!-- Shutdown button - visible on backend side -->
      <div class="backend-controls">
        <button id="start-container-btn" class="start-btn">‚ñ∂</button>
        <button id="stop-container-btn" class="stop-btn">‚èπ</button>
      </div>
      
      <!-- Front face: AC Webview -->
      <div class="card-face card-front">
        <webview id="front-webview" src="https://aesthetic.computer/prompt?desktop" allowpopups preload="../webview-preload.js"></webview>
      </div>
    
    <!-- Back face: Terminal -->
    <div class="card-face card-back">
      <!-- Welcome screen before terminal starts -->
      <div class="backend-welcome" id="backend-welcome">
        <h1>‚ö° AC Pane</h1>
        <div class="subtitle">Development Environment</div>
        
        <div class="info-section">
          <div class="info-row">
            <span class="info-label">üìÅ Repository</span>
            <span class="info-value loading" id="info-repo">checking</span>
          </div>
          <div class="info-row">
            <span class="info-label">üë§ Git User</span>
            <span class="info-value loading" id="info-git-user">checking</span>
          </div>
          <div class="info-row">
            <span class="info-label">üê≥ Docker</span>
            <span class="info-value loading" id="info-docker">checking</span>
          </div>
          <div class="info-row">
            <span class="info-label">üì¶ Container</span>
            <span class="info-value loading" id="info-container">checking</span>
          </div>
        </div>
        
        <div class="hint-text">Use the START button below to launch the devcontainer</div>
      </div>
      
      <div id="terminal-container"></div>
    </div>
  </div>
  </div> <!-- close flip-perspective -->

  <script>
    const { Terminal } = require('@xterm/xterm');
    const { FitAddon } = require('@xterm/addon-fit');
    const { WebglAddon } = require('@xterm/addon-webgl');
    const { ipcRenderer } = require('electron');
    
    const flipCard = document.querySelector('.flip-card');
    const webviewEl = document.getElementById('front-webview');
    const flipTabs = document.querySelectorAll('.flip-tab');
    const volumeSlider = document.getElementById('volume-slider');
    const volumeValue = document.getElementById('volume-value');
    let showingTerminal = false;
    let webviewReady = false;
    let pendingMasterVolume = null;

    const DEFAULT_MASTER_VOLUME = 0.25;
    const VOLUME_STORAGE_KEY = 'ac-master-volume';
    
    function clampVolume(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return DEFAULT_MASTER_VOLUME;
      return Math.min(1, Math.max(0, numeric));
    }

    function updateVolumeUI(value) {
      const clamped = clampVolume(value);
      volumeSlider.value = clamped.toString();
      volumeValue.textContent = Math.round(clamped * 100).toString();
      return clamped;
    }

    function sendMasterVolume(value) {
      const clamped = clampVolume(value);
      console.log('[volume] Sending master volume:', clamped);
      if (typeof webviewEl?.executeJavaScript !== 'function') {
        pendingMasterVolume = clamped;
        return false;
      }
      const code = `(() => {
        const v = ${clamped};
        console.log('[AC] setMasterVolume called with:', v);
        if (window.AC && typeof window.AC.setMasterVolume === 'function') {
          const result = window.AC.setMasterVolume(v);
          console.log('[AC] setMasterVolume result:', result);
          return { success: true, method: 'AC.setMasterVolume', result };
        }
        if (typeof window.acSetMasterVolume === 'function') {
          const result = window.acSetMasterVolume(v);
          console.log('[AC] acSetMasterVolume result:', result);
          return { success: true, method: 'acSetMasterVolume', result };
        }
        console.warn('[AC] No volume setter found. AC:', window.AC);
        return { success: false, AC: !!window.AC };
      })()`;
      webviewEl.executeJavaScript(code, true)
        .then(result => console.log('[volume] executeJavaScript result:', result))
        .catch(err => console.error('[volume] executeJavaScript error:', err));
      pendingMasterVolume = null;
      return true;
    }

    function syncMasterVolume() {
      const clamped = clampVolume(volumeSlider.value);
      sessionStorage.setItem(VOLUME_STORAGE_KEY, String(clamped));
      if (!webviewReady) {
        pendingMasterVolume = clamped;
        return;
      }
      sendMasterVolume(clamped);
    }

    // Initialize per-window volume
    const storedVolume = sessionStorage.getItem(VOLUME_STORAGE_KEY);
    if (storedVolume !== null) {
      updateVolumeUI(storedVolume);
    } else {
      updateVolumeUI(DEFAULT_MASTER_VOLUME);
      sessionStorage.setItem(VOLUME_STORAGE_KEY, String(DEFAULT_MASTER_VOLUME));
    }
    syncMasterVolume();
    
    
    // Extract piece name from URL
    function extractPieceName(url) {
      try {
        const parsed = new URL(url);
        const pathname = parsed.pathname;
        // Remove leading slash and get first segment
        const piece = pathname.replace(/^\//, '').split('/')[0] || 'prompt';
        return piece;
      } catch (e) {
        return 'prompt';
      }
    }
    
    // Track navigation and update tray title
    webviewEl.addEventListener('did-navigate', (e) => {
      const piece = extractPieceName(e.url);
      console.log('[flip] Navigated to piece:', piece);
      ipcRenderer.invoke('set-current-piece', piece);
      syncMasterVolume();
    });
    
    webviewEl.addEventListener('did-navigate-in-page', (e) => {
      if (e.isMainFrame) {
        const piece = extractPieceName(e.url);
        console.log('[flip] In-page navigation to piece:', piece);
        ipcRenderer.invoke('set-current-piece', piece);
        syncMasterVolume();
      }
    });

    webviewEl.addEventListener('dom-ready', () => {
      console.log('[volume] dom-ready - syncing volume')
      webviewReady = true;
      if (pendingMasterVolume !== null) {
        sendMasterVolume(pendingMasterVolume);
      }
      syncMasterVolume();
      // Retry after AC has had time to boot
      setTimeout(() => {
        console.log('[volume] Retry sync after 2s delay');
        syncMasterVolume();
      }, 2000);
      setTimeout(() => {
        console.log('[volume] Retry sync after 5s delay');
        syncMasterVolume();
      }, 5000);
    });
    
    // Handle IPC from main process to open devtools
    ipcRenderer.on('open-devtools', () => {
      console.log('[flip] Received open-devtools from main');
      webviewEl.openDevTools();
    });
    
    // Handle context menu on webview (right-click)
    webviewEl.addEventListener('context-menu', (e) => {
      console.log('[flip] Webview context-menu event', e.params);
      e.preventDefault();
      showContextMenu(e.params.x, e.params.y);
    });
    
    // Handle IPC messages from webview preload (the primary communication channel)
    webviewEl.addEventListener('ipc-message', (e) => {
      const channel = e.channel;
      const args = e.args?.[0] || {};
      console.log('[flip] ipc-message from webview:', channel, args);
      
      if (channel === 'ac-open-window') {
        const { url, index = 0, total = 1 } = args;
        console.log('[flip] Opening new window via ipc-message:', url, index, total);
        ipcRenderer.invoke('ac-open-window', { url, index, total });
      } else if (channel === 'ac-close-window') {
        console.log('[flip] Closing window via ipc-message');
        ipcRenderer.invoke('ac-close-window');
      }
    });
    
    // Handle window.open() from webview (fallback for older code paths)
    // Note: Main process also handles this via setWindowOpenHandler
    webviewEl.addEventListener('new-window', (e) => {
      console.log('[flip] new-window event received:', e?.url, e);
      if (e?.preventDefault) e.preventDefault();
      const url = e?.url || '';
      if (url.startsWith('ac://close')) {
        console.log('[flip] Handling ac://close - invoking ac-close-window');
        ipcRenderer.invoke('ac-close-window');
        return;
      }
      
      // Check if this is an external URL that should open in the system browser
      try {
        const urlObj = new URL(url);
        const isExternal = !urlObj.hostname.includes('aesthetic.computer') &&
                          !urlObj.hostname.includes('localhost') &&
                          !urlObj.hostname.includes('127.0.0.1') &&
                          !url.startsWith('ac://');
        
        if (isExternal) {
          console.log('[flip] Opening external URL in system browser:', url);
          ipcRenderer.invoke('open-external-url', url);
          return;
        }
      } catch (err) {
        console.warn('[flip] Failed to parse URL:', url, err.message);
      }
      
      console.log('[flip] Opening new window with url:', url);
      ipcRenderer.invoke('ac-open-window', { url, index: 0 });
    });
    
    // Listen for postMessage from webview (legacy fallback)
    window.addEventListener('message', (e) => {
      if (e.data?.type === 'ac-open-window') {
        console.log('[flip] Received ac-open-window postMessage:', e.data);
        ipcRenderer.invoke('ac-open-window', { 
          url: e.data.url, 
          index: e.data.index || 0, 
          total: e.data.total || 1 
        });
      } else if (e.data?.type === 'ac-close-window') {
        console.log('[flip] Received ac-close-window postMessage');
        ipcRenderer.invoke('ac-close-window');
      }
    });
    
    // Listen for navigate commands from main process (for new windows)
    ipcRenderer.on('navigate', (event, url) => {
      console.log('[flip] Received navigate command:', url);
      if (url && webviewEl) {
        webviewEl.src = url;
      }
    });
    
    // Also try did-create-window (Electron 22+)
    webviewEl.addEventListener('did-create-window', (e) => {
      console.log('[flip] did-create-window event:', e);
    });
    
    // And will-navigate for debugging
    webviewEl.addEventListener('will-navigate', (e) => {
      console.log('[flip] will-navigate:', e?.url);
    });
    
    // Mark this as the main window and set initial piece
    ipcRenderer.invoke('set-main-window');
    ipcRenderer.invoke('set-current-piece', 'prompt');
    
    volumeSlider.addEventListener('input', () => {
      updateVolumeUI(volumeSlider.value);
      syncMasterVolume();
    });
    
    // Container control button handlers
    const startContainerBtn = document.getElementById('start-container-btn');
    const stopContainerBtn = document.getElementById('stop-container-btn');
    const welcomeScreen = document.getElementById('backend-welcome');
    
    async function updateContainerButtons() {
      const isRunning = await ipcRenderer.invoke('check-container');
      startContainerBtn.disabled = isRunning;
      stopContainerBtn.disabled = !isRunning;
    }
    
    // Show a big centered message in the terminal
    function showTerminalMessage(message, color = '\x1b[35m') {
      term.clear();
      const rows = term.rows;
      const cols = term.cols;
      const midRow = Math.floor(rows / 2);
      const padding = Math.floor((cols - message.length) / 2);
      
      // Move to middle and print centered message
      for (let i = 0; i < midRow - 1; i++) {
        term.writeln('');
      }
      term.writeln(color + ' '.repeat(Math.max(0, padding)) + message + '\x1b[0m');
    }
    
    startContainerBtn.addEventListener('click', async () => {
      console.log('[flip] Start devcontainer requested');
      startContainerBtn.disabled = true;
      startContainerBtn.textContent = '‚è≥';
      
      // Clear terminal and show starting message immediately
      welcomeScreen.classList.add('hidden');
      fitTerminal();
      showTerminalMessage('‚ñ∂ STARTING...', '\x1b[35m\x1b[1m');
      
      try {
        await ipcRenderer.invoke('start-flip-devcontainer');
        startContainerBtn.textContent = '‚ñ∂';
        await updateContainerButtons();
      } catch (err) {
        console.error('[flip] Failed to start devcontainer:', err);
        showTerminalMessage('‚úó START FAILED', '\x1b[31m\x1b[1m');
        startContainerBtn.textContent = '‚ñ∂';
        startContainerBtn.disabled = false;
      }
    });
    
    stopContainerBtn.addEventListener('click', async () => {
      console.log('[flip] Stop container requested (aggressive)');
      stopContainerBtn.disabled = true;
      stopContainerBtn.textContent = '‚è≥';
      
      // Show stopping message immediately
      showTerminalMessage('‚èπ STOPPING...', '\x1b[35m\x1b[1m');
      
      try {
        await ipcRenderer.invoke('stop-container-aggressive');
        showTerminalMessage('‚èπ STOPPED', '\x1b[90m');
        stopContainerBtn.textContent = '‚èπ';
        await updateContainerButtons();
      } catch (err) {
        console.error('[flip] Failed to stop container:', err);
        showTerminalMessage('‚úó STOP FAILED', '\x1b[31m\x1b[1m');
        stopContainerBtn.textContent = '‚èπ';
        stopContainerBtn.disabled = false;
      }
    });
    
    // Update button states periodically
    updateContainerButtons();
    setInterval(updateContainerButtons, 5000);
    
    // Listen for global flip shortcut from main process
    ipcRenderer.on('toggle-flip', () => {
      toggle();
    });
    
    // Listen for navigate messages (from new window requests)
    ipcRenderer.on('navigate', (event, url) => {
      console.log('[flip] Navigate to:', url);
      if (url && typeof url === 'string') {
        webviewEl.src = url;
      }
    });
    
    // ========== Zoom Handling ==========
    let frontZoom = 1.0;
    let terminalFontSize = 10;
    
    ipcRenderer.on('zoom-in', () => {
      if (showingTerminal) {
        // Zoom terminal by increasing font size
        terminalFontSize = Math.min(terminalFontSize + 2, 32);
        term.options.fontSize = terminalFontSize;
        fitTerminal();
        console.log('[flip] Terminal font size:', terminalFontSize);
      } else {
        // Zoom webview
        frontZoom = Math.min(frontZoom + 0.1, 3.0);
        webviewEl.setZoomFactor(frontZoom);
        console.log('[flip] Webview zoom:', frontZoom);
      }
    });
    
    ipcRenderer.on('zoom-out', () => {
      if (showingTerminal) {
        // Zoom terminal by decreasing font size
        terminalFontSize = Math.max(terminalFontSize - 2, 6);
        term.options.fontSize = terminalFontSize;
        fitTerminal();
        console.log('[flip] Terminal font size:', terminalFontSize);
      } else {
        // Zoom webview
        frontZoom = Math.max(frontZoom - 0.1, 0.3);
        webviewEl.setZoomFactor(frontZoom);
        console.log('[flip] Webview zoom:', frontZoom);
      }
    });
    
    ipcRenderer.on('zoom-reset', () => {
      if (showingTerminal) {
        terminalFontSize = 10;
        term.options.fontSize = terminalFontSize;
        fitTerminal();
        console.log('[flip] Terminal font size reset to:', terminalFontSize);
      } else {
        frontZoom = 1.0;
        webviewEl.setZoomFactor(frontZoom);
        console.log('[flip] Webview zoom reset to:', frontZoom);
      }
    });
    
    // ========== Terminal Setup ==========
    const terminalContainer = document.getElementById('terminal-container');
    
    // Theme definitions for terminal
    const darkTermTheme = {
      background: '#0a0a12',
      foreground: '#eee',
      cursor: '#f0f',
      cursorAccent: '#0a0a12',
      selectionBackground: 'rgba(255, 0, 255, 0.3)',
      black: '#1a1a2e',
      red: '#ff5555',
      green: '#50fa7b',
      yellow: '#f1fa8c',
      blue: '#6272a4',
      magenta: '#ff79c6',
      cyan: '#8be9fd',
      white: '#f8f8f2',
    };
    
    const lightTermTheme = {
      background: '#f5f0c0',
      foreground: '#281e5a',
      cursor: '#387adf',
      cursorAccent: '#f5f0c0',
      selectionBackground: 'rgba(56, 122, 223, 0.3)',
      black: '#281e5a',
      red: '#cc0000',
      green: '#006400',
      yellow: '#996600',
      blue: '#387adf',
      magenta: '#8844ff',
      cyan: '#0077aa',
      white: '#fcf7c5',
    };
    
    // Detect current color scheme
    function isDarkMode() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches;
    }
    
    const term = new Terminal({
      cursorBlink: true,
      cursorStyle: 'block',
      fontSize: 10,
      fontFamily: "'Menlo', 'DejaVu Sans Mono', 'Consolas', 'Liberation Mono', monospace",
      theme: isDarkMode() ? darkTermTheme : lightTermTheme,
      allowTransparency: true,
      scrollback: 5000,
      fastScrollModifier: 'alt',
      fastScrollSensitivity: 5,
      drawBoldTextInBrightColors: true,
    });
    
    // Listen for color scheme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
      console.log('[flip] Color scheme changed to:', e.matches ? 'dark' : 'light');
      term.options.theme = e.matches ? darkTermTheme : lightTermTheme;
    });
    
    const fitAddon = new FitAddon();
    term.loadAddon(fitAddon);
    term.open(terminalContainer);
    
    // Load WebGL2 renderer for better performance
    try {
      const webglAddon = new WebglAddon();
      webglAddon.onContextLoss(() => {
        console.warn('[flip] WebGL context lost, disposing addon');
        webglAddon.dispose();
      });
      term.loadAddon(webglAddon);
      console.log('[flip] WebGL2 renderer loaded successfully');
    } catch (e) {
      console.warn('[flip] WebGL2 renderer failed to load, using canvas fallback:', e.message);
    }
    
    // Fit terminal to container and send initial size to PTY
    function fitTerminal() {
      fitAddon.fit();
      console.log('[flip] Terminal fit:', term.cols, 'x', term.rows);
      ipcRenderer.send('flip-pty-resize', term.cols, term.rows);
    }
    
    // Initial fit - wait for layout to stabilize, then fit multiple times
    function initialFit() {
      // Force container dimensions to be calculated
      terminalContainer.style.display = 'block';
      terminalContainer.offsetHeight; // Force reflow
      
      fitTerminal();
    }
    
    // Wait for window to fully load and layout to settle
    if (document.readyState === 'complete') {
      setTimeout(initialFit, 50);
      setTimeout(fitTerminal, 200);
      setTimeout(fitTerminal, 500);
    } else {
      window.addEventListener('load', () => {
        setTimeout(initialFit, 50);
        setTimeout(fitTerminal, 200);
        setTimeout(fitTerminal, 500);
      });
    }
    
    // Also fit when the flip card becomes visible (showing backend)
    const flipObserver = new MutationObserver(() => {
      if (showingTerminal) {
        requestAnimationFrame(() => {
          fitTerminal();
        });
      }
    });
    flipObserver.observe(flipCard, { attributes: true, attributeFilter: ['style'] });
    
    // Resize handling
    const resizeObserver = new ResizeObserver(() => {
      fitTerminal();
    });
    resizeObserver.observe(terminalContainer);
    
    // PTY communication
    ipcRenderer.on('flip-pty-data', (event, data) => {
      term.write(data);
    });
    
    // Respond to size requests from main process
    ipcRenderer.on('request-terminal-size', () => {
      // Force a fit and send current dimensions
      fitAddon.fit();
      ipcRenderer.send('flip-pty-resize', term.cols, term.rows);
    });
    
    term.onData((data) => {
      ipcRenderer.send('flip-pty-input', data);
    });
    
    // ========== Welcome Screen Logic ==========
    const infoRepo = document.getElementById('info-repo');
    const infoGitUser = document.getElementById('info-git-user');
    const infoDocker = document.getElementById('info-docker');
    const infoContainer = document.getElementById('info-container');
    
    let systemInfo = {
      repoPath: null,
      gitUser: null,
      dockerAvailable: false,
      containerExists: false
    };
    
    async function gatherSystemInfo() {
      // Get repo path
      try {
        const repo = await ipcRenderer.invoke('get-repo-path');
        if (repo) {
          systemInfo.repoPath = repo.path;
          infoRepo.textContent = repo.name;
          infoRepo.classList.remove('loading');
          infoRepo.classList.add('success');
        } else {
          infoRepo.textContent = 'Not found';
          infoRepo.classList.remove('loading');
          infoRepo.classList.add('warning');
        }
      } catch (e) {
        infoRepo.textContent = 'Error';
        infoRepo.classList.remove('loading');
        infoRepo.classList.add('error');
      }
      
      // Get git user
      try {
        const gitUser = await ipcRenderer.invoke('get-git-user');
        if (gitUser && gitUser.name) {
          systemInfo.gitUser = gitUser;
          infoGitUser.textContent = gitUser.name;
          infoGitUser.classList.remove('loading');
          infoGitUser.classList.add('success');
        } else {
          infoGitUser.textContent = 'Not configured';
          infoGitUser.classList.remove('loading');
          infoGitUser.classList.add('warning');
        }
      } catch (e) {
        infoGitUser.textContent = 'Error';
        infoGitUser.classList.remove('loading');
        infoGitUser.classList.add('error');
      }
      
      // Check Docker
      try {
        const dockerOk = await ipcRenderer.invoke('check-docker');
        systemInfo.dockerAvailable = dockerOk;
        if (dockerOk) {
          infoDocker.textContent = 'Running';
          infoDocker.classList.remove('loading');
          infoDocker.classList.add('success');
        } else {
          infoDocker.textContent = 'Not running';
          infoDocker.classList.remove('loading');
          infoDocker.classList.add('warning');
        }
      } catch (e) {
        infoDocker.textContent = 'Error';
        infoDocker.classList.remove('loading');
        infoDocker.classList.add('error');
      }
      
      // Check container exists
      try {
        const containerOk = await ipcRenderer.invoke('check-container-exists');
        systemInfo.containerExists = containerOk;
        if (containerOk) {
          infoContainer.textContent = 'Ready';
          infoContainer.classList.remove('loading');
          infoContainer.classList.add('success');
        } else {
          infoContainer.textContent = 'Not found';
          infoContainer.classList.remove('loading');
          infoContainer.classList.add('warning');
        }
      } catch (e) {
        infoContainer.textContent = 'Error';
        infoContainer.classList.remove('loading');
        infoContainer.classList.add('error');
      }
    }
    
    // Start gathering info immediately
    gatherSystemInfo();

    // ========== Toggle Logic ==========
    let rotationAngle = 0; // Track cumulative rotation
    let midflipTimeout = null;
    let swivelingTimeout = null;
    
    function toggle(direction = 'right') {
      console.log('[flip] toggle() called, direction:', direction, 'rotation was:', rotationAngle);
      
      // Clear any pending timeouts
      if (midflipTimeout) {
        clearTimeout(midflipTimeout);
      }
      if (swivelingTimeout) {
        clearTimeout(swivelingTimeout);
      }
      
      // Show spinner cursor during swivel
      document.body.classList.add('swiveling');
      
      // Always rotate 180deg in the specified direction (continuous spin)
      // Right tab = clockwise (positive), Left tab = counter-clockwise (negative)
      if (direction === 'right') {
        rotationAngle += 180;
      } else {
        rotationAngle -= 180;
      }
      
      // Apply rotation directly to flip-card
      flipCard.style.transform = `rotateY(${rotationAngle}deg)`;
      
      // Determine which side will be showing after flip completes
      const normalized = ((rotationAngle % 360) + 360) % 360;
      const willShowTerminal = (normalized > 90 && normalized < 270);
      
      // Swap translucency when card is edge-on (90¬∞)
      // With cubic-bezier(0.4, 0, 0.2, 1) over 700ms, 90¬∞ is reached around 260ms
      midflipTimeout = setTimeout(() => {
        showingTerminal = willShowTerminal;
        document.body.classList.toggle('midflip', showingTerminal);
        document.body.classList.toggle('flipped', showingTerminal);
        console.log('[flip] Edge-on reached - swapping translucency, showingTerminal:', showingTerminal);
      }, 260);
      
      // Remove spinner cursor when swivel completes
      swivelingTimeout = setTimeout(() => {
        document.body.classList.remove('swiveling');
      }, 700);
      
      console.log('[flip] Will show', willShowTerminal ? 'terminal' : 'webview', 'rotation:', rotationAngle, 'normalized:', normalized);
      
      // After flip completes, fit terminal and focus if showing terminal
      if (willShowTerminal) {
        setTimeout(() => {
          fitTerminal();
          term.focus();
        }, 700);
      }
    }
    
    // Flip tabs - click to flip, native drag to move window (PaperWM/Wayland compatible)
    // Inner elements have -webkit-app-region: drag for native window dragging
    console.log('[flip] Found flip tabs:', flipTabs.length);
    flipTabs.forEach(tab => {
      // Use mousedown/mouseup to detect clicks (click event doesn't fire with app-region children)
      let mouseDownTime = 0;
      let mouseDownPos = { x: 0, y: 0 };

      tab.addEventListener('mousedown', (e) => {
        mouseDownTime = Date.now();
        mouseDownPos = { x: e.clientX, y: e.clientY };
      });

      tab.addEventListener('mouseup', (e) => {
        const timeDiff = Date.now() - mouseDownTime;
        const moveDiff = Math.hypot(e.clientX - mouseDownPos.x, e.clientY - mouseDownPos.y);

        // If mouse was down for less than 300ms and didn't move much, treat as click
        if (timeDiff < 300 && moveDiff < 10) {
          e.preventDefault();
          e.stopPropagation();

          // Base direction on SCREEN position, not tab class
          const windowCenter = window.innerWidth / 2;
          const direction = (e.clientX > windowCenter) ? 'right' : 'left';

          console.log('[flip] Flip tab clicked at x:', e.clientX, 'center:', windowCenter, 'direction:', direction);
          toggle(direction);
        }
      });
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Tab to toggle flip
      if (e.key === 'Tab') {
        console.log('[flip] Tab key pressed');
        e.preventDefault();
        toggle();
      }
      // Cmd+Shift+I or Ctrl+Shift+I to open webview devtools (check both cases)
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && (e.key === 'i' || e.key === 'I')) {
        e.preventDefault();
        console.log('[flip] Opening webview DevTools via keyboard');
        if (webviewEl.isDevToolsOpened()) {
          webviewEl.closeDevTools();
        } else {
          webviewEl.openDevTools();
        }
      }
      // F12 also opens devtools (Windows standard)
      if (e.key === 'F12') {
        e.preventDefault();
        console.log('[flip] Opening webview DevTools via F12');
        if (webviewEl.isDevToolsOpened()) {
          webviewEl.closeDevTools();
        } else {
          webviewEl.openDevTools();
        }
      }
    });
    
    // Context menu for DevTools
    document.addEventListener('contextmenu', (e) => {
      // Show custom context menu
      e.preventDefault();
      showContextMenu(e.clientX, e.clientY);
    });
    
    // Custom context menu
    function showContextMenu(x, y) {
      // Remove any existing menu
      const existing = document.getElementById('custom-context-menu');
      if (existing) existing.remove();
      
      const menu = document.createElement('div');
      menu.id = 'custom-context-menu';
      menu.style.cssText = `
        position: fixed;
        left: ${x}px;
        top: ${y}px;
        background: rgba(30, 30, 40, 0.95);
        border: 1px solid var(--ac-border);
        border-radius: 6px;
        padding: 4px 0;
        min-width: 160px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.4);
        z-index: 10000;
        font-size: 12px;
        backdrop-filter: blur(8px);
      `;
      
      const menuItems = [
        { label: 'üîß Open DevTools', action: () => webviewEl.openDevTools() },
        { label: 'üîÑ Reload Page', action: () => webviewEl.reload() },
        { label: 'üìã Copy URL', action: () => navigator.clipboard.writeText(webviewEl.src) },
        { type: 'separator' },
        { label: 'üîä Reset Volume', action: () => { updateVolumeUI(DEFAULT_MASTER_VOLUME); syncMasterVolume(); } },
      ];
      
      menuItems.forEach(item => {
        if (item.type === 'separator') {
          const sep = document.createElement('div');
          sep.style.cssText = 'height: 1px; background: var(--ac-border); margin: 4px 8px;';
          menu.appendChild(sep);
        } else {
          const menuItem = document.createElement('div');
          menuItem.textContent = item.label;
          menuItem.style.cssText = `
            padding: 6px 12px;
            cursor: pointer;
            color: var(--ac-text);
          `;
          menuItem.addEventListener('mouseenter', () => {
            menuItem.style.background = 'var(--ac-border-hover)';
          });
          menuItem.addEventListener('mouseleave', () => {
            menuItem.style.background = 'transparent';
          });
          menuItem.addEventListener('click', () => {
            item.action();
            menu.remove();
          });
          menu.appendChild(menuItem);
        }
      });
      
      document.body.appendChild(menu);
      
      // Close menu on click outside
      const closeMenu = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }
      };
      setTimeout(() => document.addEventListener('click', closeMenu), 0);
    }
    
    // Window resize
    window.addEventListener('resize', () => {
      fitAddon.fit();
      ipcRenderer.send('flip-pty-resize', term.cols, term.rows);
    });
    
    // ========== Custom Resize Handles ==========
    const resizeOverlay = document.getElementById('resize-overlay');
    
    document.querySelectorAll('[data-resize]').forEach(handle => {
      handle.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const direction = handle.dataset.resize;
        
        // Get cursor style for this direction
        const cursorStyle = window.getComputedStyle(handle).cursor;
        
        // Show overlay and set body class to disable pointer events on content
        resizeOverlay.style.cursor = cursorStyle;
        resizeOverlay.classList.add('active');
        document.body.classList.add('resizing');
        
        const startX = e.screenX;
        const startY = e.screenY;
        const startBounds = {
          x: window.screenX,
          y: window.screenY,
          width: window.outerWidth,
          height: window.outerHeight
        };
        
        const onMouseMove = (e) => {
          const dx = e.screenX - startX;
          const dy = e.screenY - startY;
          
          let newX = startBounds.x;
          let newY = startBounds.y;
          let newWidth = startBounds.width;
          let newHeight = startBounds.height;
          
          if (direction.includes('left')) {
            newX = startBounds.x + dx;
            newWidth = startBounds.width - dx;
          }
          if (direction.includes('right')) {
            newWidth = startBounds.width + dx;
          }
          if (direction.includes('top')) {
            newY = startBounds.y + dy;
            newHeight = startBounds.height - dy;
          }
          if (direction.includes('bottom')) {
            newHeight = startBounds.height + dy;
          }
          
          // Minimum size
          if (newWidth < 400) { newWidth = 400; newX = startBounds.x + startBounds.width - 400; }
          if (newHeight < 300) { newHeight = 300; newY = startBounds.y + startBounds.height - 300; }
          
          ipcRenderer.send('resize-window', { x: newX, y: newY, width: newWidth, height: newHeight });
        };
        
        const onMouseUp = () => {
          // Hide overlay and restore pointer events
          resizeOverlay.classList.remove('active');
          document.body.classList.remove('resizing');
          
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    });
    
    // ========== Alt + Scroll to Drag Window ==========
    let scrollDragActive = false;
    let scrollDragStart = { x: 0, y: 0 };
    
    document.addEventListener('wheel', (e) => {
      // Alt + scroll (two-finger drag with alt) moves the window
      if (e.altKey) {
        e.preventDefault();
        
        // Use deltaX and deltaY to move window
        const currentX = window.screenX;
        const currentY = window.screenY;
        
        // Invert and scale the delta for natural dragging feel
        const newX = currentX - e.deltaX;
        const newY = currentY - e.deltaY;
        
        ipcRenderer.send('move-window', { x: Math.round(newX), y: Math.round(newY) });
      }
    }, { passive: false });
  </script>
</body>
</html>
