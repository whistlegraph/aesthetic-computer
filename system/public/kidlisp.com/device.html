<!DOCTYPE html>
<!-- KidLisp.com Device Mode - Optimized for FF1 and display devices -->
<!-- URL format: device.kidlisp.com/codeId -->
<!-- Loads KidLisp $code URLs with default density=1 for 4K displays -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>KidLisp.com ¬∑ Device</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <link rel="icon" type="image/png"
    href="https://pals-aesthetic-computer.sfo3.cdn.digitaloceanspaces.com/painting-2023.7.29.20.39.png" />
  <!-- Google Fonts - Noto Sans Mono (Monaco-like) and Comic Relief (kidlisp branding) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Relief:wght@400;700&family=Noto+Sans+Mono:wght@400;700&display=swap" rel="stylesheet">
  <!-- QR Code library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <!-- üöÄ Eager source fetch - starts immediately before DOM loads -->
  <script>
    (function() {
      // Parse codeId from URL immediately
      const pathname = window.location.pathname;
      const hostname = window.location.hostname;
      const pathParts = pathname.split('/').filter(p => p);
      let codeId = null;
      
      if (hostname === 'device.kidlisp.com') {
        codeId = pathParts[0] || null;
      } else if (pathname.startsWith('/device.kidlisp.com/')) {
        codeId = pathParts[1] || null;
      } else if (pathParts[0] === 'kidlisp.com' && pathParts[1] === 'device') {
        codeId = pathParts[2] || null;
      }
      
      if (codeId) {
        const pieceCode = codeId.startsWith('$') ? codeId.slice(1) : codeId;
        const dev = hostname === 'localhost' || hostname === 'local.aesthetic.computer';
        const apiUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
        const url = `${apiUrl}/api/store-kidlisp?code=${pieceCode}`;
        
        // Start fetch immediately - store promise globally for later use
        window.__eagerSourceFetch = fetch(url, { credentials: 'omit' })
          .then(r => r.ok ? r.json() : null)
          .catch(() => null);
        console.log('üöÄ Eager source fetch started for:', pieceCode);
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      /* UI scale for DOM elements - independent of piece rendering density */
      /* Default to 20 for good visibility on FF1/device displays (increased for 4K TVs) */
      --ui-scale: 20;
    }
    
    #display-iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: none;
      background: #000;
      z-index: 1;
    }
    
    /* Boot screen - now handled by iframe's boot animation */
    #boot-screen {
      display: none;
    }

    /* KidLisp source overlay - shows during loading */
    #source-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 15;
      pointer-events: auto;
      touch-action: manipulation;
      transition: opacity 0.5s ease;
    }
    
    /* Source code always visible with piece info */
    #source-overlay {
      /* Always visible - no hidden state */
    }
    
    /* Source code display - top left */
    #source-code {
      position: absolute;
      top: calc(var(--ui-scale, 8) * 3px);
      left: calc(var(--ui-scale, 8) * 3px);
      right: calc(var(--ui-scale, 8) * 3px);
      bottom: calc(var(--ui-scale, 8) * 22px);
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--ui-scale, 8) * 2.5px);
      line-height: 1.5;
      color: #fff;
      overflow: hidden;
      /* Harsh shadow matching stats for visibility on complex animations */
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
      white-space: pre-wrap;
      word-break: break-word;
      -webkit-mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
      mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
      transition: opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    #source-code-inner {
      /* For scrolling long code */
      transition: opacity 0.25s ease;
    }
    
    /* Hide UI elements during scramble animation - only show code */
    #qr-wrap,
    #piece-handle,
    #piece-hits,
    #piece-when,
    .ff1-module {
      transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    #source-overlay.scrambling #qr-wrap,
    #source-overlay.scrambling #piece-handle,
    #source-overlay.scrambling #piece-hits,
    #source-overlay.scrambling #piece-when,
    #source-overlay.scrambling .ff1-module {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Slide animations for overlay elements during playback */
    /* QR slides to bottom-right corner */
    #source-overlay.slid-out #qr-wrap,
    #source-overlay.tap-hidden #qr-wrap {
      transform: translate(120%, 120%);
      opacity: 0;
      pointer-events: none;
    }
    
    /* Stats slide to bottom-left corner */
    #source-overlay.slid-out #piece-info,
    #source-overlay.tap-hidden #piece-info {
      transform: translate(-120%, 120%);
      opacity: 0;
      pointer-events: none;
    }
    
    /* Source code slides to top-left corner */
    #source-overlay.slid-out #source-code,
    #source-overlay.tap-hidden #source-code {
      transform: translate(-50%, -120%);
      opacity: 0;
    }
    
    /* Hover override - when user hovers, reveal all elements even if slid-out */
    #source-overlay.slid-out.hover-reveal #qr-wrap,
    #source-overlay.slid-out.hover-reveal #piece-info,
    #source-overlay.slid-out.hover-reveal #source-code,
    #source-overlay.tap-hidden.hover-reveal #qr-wrap,
    #source-overlay.tap-hidden.hover-reveal #piece-info,
    #source-overlay.tap-hidden.hover-reveal #source-code {
      transform: translate(0, 0);
      opacity: 1;
      pointer-events: auto;
    }
    
    #source-code-inner.scrolling {
      animation: codeScroll var(--scroll-duration, 12s) ease-in-out infinite;
      animation-delay: 2s;
    }
    
    @keyframes codeScroll {
      0%, 15% { transform: translateY(0); }
      85%, 100% { transform: translateY(var(--scroll-distance, 0)); }
    }
    
    /* QR code and label - bottom right (like give.aesthetic.computer) */
    #qr-wrap {
      position: absolute;
      bottom: calc(var(--ui-scale, 8) * 3px);
      right: calc(var(--ui-scale, 8) * 3px);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      z-index: 24;
      pointer-events: auto;
      cursor: pointer;
      transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      padding-right: calc(var(--ui-scale, 8) * 0.5px);
      padding-bottom: calc(var(--ui-scale, 8) * 0.5px);
    }
    
    #qr-wrap:hover {
      transform: scale(1.08);
    }
    
    #qr-wrap:active {
      transform: scale(0.98);
    }
    
    #code-label {
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--ui-scale, 8) * 2.5px);
      font-weight: 400;
      color: #fff;
      background: #000;
      padding: calc(var(--ui-scale, 8) * 0.25px) calc(var(--ui-scale, 8) * 0.5px);
      padding-bottom: calc(var(--ui-scale, 8) * 0.75px); /* Extra space below label */
      line-height: 1;
      text-transform: none; /* Keep original case */
      /* Gray offset shadow matching QR container */
      box-shadow: calc(var(--ui-scale, 8) * 0.5px) calc(var(--ui-scale, 8) * 0.5px) 0 rgba(64, 64, 64, 0.8);
    }
    
    #code-label .code-dollar {
      color: #fff;
    }
    
    #code-label .code-name {
      color: #fff;
    }
    
    #qr-container {
      background: #fff;
      padding: calc(var(--ui-scale, 8) * 0.25px);
      line-height: 0;
      width: calc(var(--ui-scale, 8) * 10px);
      height: calc(var(--ui-scale, 8) * 10px);
      /* Gray offset hard shadow like disk.mjs pixel-rendered QR codes */
      box-shadow: calc(var(--ui-scale, 8) * 0.5px) calc(var(--ui-scale, 8) * 0.5px) 0 rgba(64, 64, 64, 0.8);
    }
    
    #qr-container svg {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }
    
    /* Handle and hits info - bottom left (device replaces disk.mjs overlay) */
    #piece-info {
      position: absolute;
      bottom: calc(var(--ui-scale, 8) * 3px);
      left: calc(var(--ui-scale, 8) * 3px);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--ui-scale, 8) * 2.5px);
      line-height: 1.4;
      z-index: 16;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      transition: opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    #piece-handle {
      color: rgb(255, 107, 157);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    #piece-handle:hover {
      opacity: 0.7;
    }
    
    #piece-hits {
      color: rgb(255, 217, 61);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    #piece-when {
      color: rgb(180, 180, 180);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    /* FF1 module - self-contained box for FF1 cast functionality */
    /* In playlist mode, includes title and position; always includes copy button */
    .ff1-module {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0;
      margin-top: 0;
      padding: 0;
      background: transparent;
      border: none;
      border-radius: 0;
      pointer-events: auto;
      transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      z-index: 10;
    }

    .ff1-module.overlap-fade {
      opacity: 0;
      pointer-events: none;
    }

    .ff1-module.overlap-fade .ff1-playlist-title,
    .ff1-module.overlap-fade .ff1-playlist-position,
    .ff1-module.overlap-fade .piece-ff1-copy .ff1-cmd {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: block;
      max-width: 100%;
    }
    
    /* Playlist header inside FF1 module (only shown in slideshow mode) */
    .ff1-playlist-header {
      display: none;
      width: 100%;
      padding-bottom: calc(var(--ui-scale, 8) * 0.3px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      margin-bottom: calc(var(--ui-scale, 8) * 0.2px);
    }
    
    .ff1-playlist-header.visible {
      display: block;
    }
    
    .ff1-playlist-title {
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Noto Sans Mono', monospace;
      font-size: calc(var(--ui-scale, 8) * 2px);
      font-weight: bold;
      line-height: 1.2;
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    .ff1-playlist-position {
      color: rgba(255, 215, 0, 0.9);
      font-family: 'Noto Sans Mono', monospace;
      font-size: calc(var(--ui-scale, 8) * 1.8px);
      margin-top: calc(var(--ui-scale, 8) * 0.15px);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    /* FF1 CLI copy button inside module */
    .piece-ff1-copy {
      display: flex;
      align-items: center;
      gap: calc(var(--ui-scale, 8) * 0.5px);
      margin: 0;
      padding: calc(var(--ui-scale, 8) * 0.25px) 0;
      background: transparent;
      border: none;
      border-radius: 0;
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Noto Sans Mono', monospace;
      font-size: calc(var(--ui-scale, 8) * 2.5px);
      cursor: pointer;
      transition: all 0.15s ease;
      pointer-events: auto;
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
      width: 100%;
    }
    
    .piece-ff1-copy:hover {
      opacity: 0.8;
    }
    
    .piece-ff1-copy:active {
      transform: scale(0.98);
    }
    
    .ff1-module.copied .piece-ff1-copy {
      color: rgba(100, 255, 100, 0.9);
    }

    .ff1-module.overlap-fade {
      opacity: 1;
    }
    
    .piece-ff1-copy .ff1-icon {
      height: calc(var(--ui-scale, 8) * 3px);
      width: auto;
      margin-right: calc(var(--ui-scale, 8) * 0.5px);
      filter: invert(1) drop-shadow(1px 1px 0 #000) drop-shadow(-1px -1px 0 #000) drop-shadow(1px -1px 0 #000) drop-shadow(-1px 1px 0 #000) drop-shadow(2px 2px 0 #000);
    }
    
    .piece-ff1-copy .ff1-cmd {
      color: rgba(255, 255, 255, 0.8);
      white-space: nowrap;
    }

    .piece-ff1-copy .ff1-quote {
      color: rgba(255, 255, 255, 0.9);
    }

    .piece-ff1-copy .ff1-url {
      color: cyan;
    }
    
    /* KidLisp syntax highlighting */
    .hl-comment { color: #6272a4; font-style: italic; }
    .hl-string { color: orange; }
    .hl-number { color: lime; }
    .hl-keyword { color: pink; }
    .hl-api { color: cyan; }
    .hl-color { /* inline style sets actual color */ }
    .hl-timing { color: #ffb86c; font-weight: bold; }
    .hl-paren { color: #888; }
    .hl-code-ref { color: limegreen; font-weight: bold; }
    .hl-code-id { color: lime; }
    .hl-paint-ref { color: magenta; font-weight: bold; }
    .hl-paint-id { color: orange; }
    .hl-fade { font-weight: bold; }
    .hl-fade-sep { color: mediumseagreen; }
    .hl-fade-dir { color: cyan; }
    .hl-fade-colon { color: lime; }

    /* Scramble coloring: start white, then transition to target color */
    .scramble-char {
      color: #fff;
      transition: color 4s ease var(--color-delay, 0s);
    }

    #source-code-inner.scramble-coloring .scramble-char {
      color: var(--target-color, #fff);
    }

    /* Hide overlay until boot starts (avoid initial flicker) */
    body.booting #source-overlay {
      opacity: 0;
    }

    /* Reduce ghosting during scramble */
    #source-overlay.scrambling #source-code,
    #source-overlay.scrambling #source-code .scramble-char {
      text-shadow: none;
    }
    
    /* Rainbow animation */
    @keyframes rainbowCycle {
      0% { color: red; }
      14% { color: orange; }
      28% { color: yellow; }
      42% { color: lime; }
      57% { color: cyan; }
      71% { color: blue; }
      85% { color: magenta; }
      100% { color: red; }
    }
    
    .hl-rainbow {
      animation: rainbowCycle 2s linear infinite;
      font-weight: bold;
    }
    
    .hl-rainbow-0 { animation-delay: 0s; }
    .hl-rainbow-1 { animation-delay: -0.28s; }
    .hl-rainbow-2 { animation-delay: -0.56s; }
    .hl-rainbow-3 { animation-delay: -0.84s; }
    .hl-rainbow-4 { animation-delay: -1.12s; }
    .hl-rainbow-5 { animation-delay: -1.40s; }
    .hl-rainbow-6 { animation-delay: -1.68s; }
    
    /* Zebra animation */
    @keyframes zebraCycle {
      0%, 49% { color: white; }
      50%, 100% { color: #333; }
    }
    
    .hl-zebra {
      animation: zebraCycle 1s steps(1) infinite;
      font-weight: bold;
    }
    
    .hl-zebra-0 { animation-delay: 0s; }
    .hl-zebra-1 { animation-delay: -0.5s; }
    
    /* Timing blink animation */
    @keyframes hl-timing-blink {
      0%, 90% { opacity: 1; }
      95% { opacity: 0.4; color: lime; }
      100% { opacity: 1; }
    }
    
    .hl-timing-active {
      animation: hl-timing-blink var(--timing-duration, 1s) ease-in-out infinite;
    }

    /* Error display */
    #error-screen {
      display: none;
      position: absolute;
      inset: 0;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #111;
      z-index: 20;
    }
    
    #error-screen.visible {
      display: flex;
    }
    
    .error-text {
      color: rgb(255, 100, 100);
      font-family: monospace;
      font-size: 14px;
      text-align: center;
      max-width: 80%;
    }

    /* YouTube-style progress bar for playlist mode */
    #progress-bar {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%; /* Full width of screen */
      height: 1px; /* Thin line, overridden by JS based on density */
      background: #000; /* Black background */
      z-index: 100;
      margin: 0;
      padding: 0;
      transition: opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      opacity: 0;
    }

    #progress-bar.visible {
      display: block;
    }

    #progress-bar.fading-in {
      opacity: 1;
      transition: opacity 2s ease;
    }
    
    #progress-bar.hidden-mid {
      opacity: 0;
    }

    #progress-bar.force-visible {
      opacity: 1 !important;
    }

    #progress-bar.force-hidden {
      opacity: 0 !important;
    }

    #progress-fill {
      height: 100%;
      width: 0%;
      /* White fill over black background - looks like it's filling in */
      background: #fff;
      transition: width 0.25s linear, background-color 0.2s ease;
    }
    
    /* Blinking red at end */
    @keyframes blinkRed {
      0%, 50% { background: #ff3333; }
      51%, 100% { background: #990000; }
    }
    
    #progress-fill.ending {
      animation: blinkRed 0.5s ease-in-out infinite;
    }

    /* FPS meter - top right (hidden by default) */
    #fps-meter {
      display: none;
      position: fixed;
      top: 0;
      right: 0;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--ui-scale, 8) * 1.5px);
      color: lime;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      z-index: 99999;
      pointer-events: none;
      text-align: right;
      padding: calc(var(--ui-scale, 8) * 0.5px);
    }

    /* Playlist info overlay - DEPRECATED, now consolidated into bottom-left piece-info */
    #playlist-info {
      display: none !important; /* Hidden - all info moved to bottom-left piece-info */
    }
    
    #playlist-info.visible {
      display: none !important;
    }
    
    #playlist-title,
    #playlist-position,
    #ff1-cast-btn {
      display: none !important; /* Unused - bottom-left handles this now */
    }

    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       MOBILE RESPONSIVE STYLES - 9x16 portrait aspect ratio
       Targets phones in portrait mode to prevent element overlapping
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
    @media (max-aspect-ratio: 10/16) and (max-width: 600px) {
      :root {
        /* Mobile layout spacing and dimensions */
        --mobile-spacing: 8px;
        --mobile-qr-size: 48px;
        --mobile-qr-padding: 2px;
        /* Height reserved for bottom overlays (QR + label + piece info area) */
        --mobile-bottom-reserve: 100px;
        /* 
         * Total width for QR section to prevent piece-info overlap:
         * QR container (48px) + inner padding (2px * 2) + right margin (8px) + gap from piece-info (8px * 2)
         */
        --mobile-qr-total-width: calc(var(--mobile-qr-size) + var(--mobile-qr-padding) * 2 + var(--mobile-spacing) * 3);
      }
      
      /* Source code - smaller on mobile */
      #source-code {
        top: var(--mobile-spacing);
        left: var(--mobile-spacing);
        right: var(--mobile-spacing);
        bottom: var(--mobile-bottom-reserve); /* Leave room for bottom overlays */
        font-size: 10px;
      }
      
      /* QR wrap - smaller and repositioned for mobile */
      #qr-wrap {
        bottom: var(--mobile-spacing);
        right: var(--mobile-spacing);
      }
      
      #code-label {
        font-size: 10px;
        padding: var(--mobile-qr-padding) 4px;
      }
      
      #qr-container {
        width: var(--mobile-qr-size);
        height: var(--mobile-qr-size);
        padding: var(--mobile-qr-padding);
      }
      
      /* Piece info - smaller on mobile */
      #piece-info {
        bottom: var(--mobile-spacing);
        left: var(--mobile-spacing);
        font-size: 10px;
        max-width: calc(100% - var(--mobile-qr-total-width)); /* Prevent overlap with QR */
      }
      
      /* FF1 module - compact on mobile */
      .ff1-module {
        margin-top: 6px;
        padding: 4px 8px;
        gap: 3px;
      }
      
      .ff1-playlist-header {
        padding-bottom: 3px;
        margin-bottom: 2px;
      }
      
      .ff1-playlist-title {
        font-size: 9px;
      }
      
      .ff1-playlist-position {
        font-size: 8px;
      }
      
      /* FF1 copy button - compact on mobile */
      .piece-ff1-copy {
        padding: 2px 0;
        font-size: 9px;
        gap: 4px;
      }
      
      .piece-ff1-copy .ff1-icon {
        height: 12px;
      }
      
      .piece-ff1-copy .ff1-cmd {
        /* Full command always visible */
      }
      
      /* Progress bar - thinner on mobile */
      #progress-bar {
        height: 2px;
      }
      
      /* FPS meter - smaller on mobile */
      #fps-meter {
        font-size: 10px;
        padding: 4px;
      }
    }

  </style>
</head>
<body>
  <!-- Boot animation now handled by iframe's acBootCanvas with device mode -->
  
  <!-- KidLisp source overlay with syntax highlighting and QR -->
  <div id="source-overlay" class="scrambling">
    <div id="source-code"><div id="source-code-inner"></div></div>
    <div id="qr-wrap">
      <div id="code-label"></div>
      <div id="qr-container"></div>
    </div>
    <div id="piece-info">
      <div id="piece-handle"></div>
      <div id="piece-hits"></div>
      <div id="piece-when"></div>
      <div id="ff1-module" class="ff1-module">
        <div id="ff1-playlist-header" class="ff1-playlist-header">
          <div id="ff1-playlist-title" class="ff1-playlist-title"></div>
          <div id="ff1-playlist-position" class="ff1-playlist-position"></div>
        </div>
        <button id="piece-ff1-copy" class="piece-ff1-copy" title="Copy FF1 CLI command">
          <img src="https://assets.aesthetic.computer/kidlisp.com/feralfile-logo.png" alt="" class="ff1-icon">
          <span class="ff1-cmd">ff1 play ...</span>
        </button>
      </div>
    </div>
  </div>
  
  <div id="error-screen">
    <div class="error-text" id="error-text"></div>
  </div>
  
  <iframe id="display-iframe"></iframe>
  
  <!-- YouTube-style progress bar for playlist mode -->
  <div id="progress-bar">
    <div id="progress-fill"></div>
  </div>
  
  <!-- FPS meter for performance comparison -->
  <div id="fps-meter">FPS: --</div>
  
  <!-- DEPRECATED: Playlist info overlay - kept for backwards compatibility but hidden via CSS -->
  <!-- All playlist info is now in the #ff1-module inside #piece-info -->
  <div id="playlist-info">
    <div id="playlist-title"></div>
    <div id="playlist-position"></div>
    <button id="ff1-cast-btn" title="Copy FF1 CLI command to cast this playlist">
      <img src="https://assets.aesthetic.computer/kidlisp.com/feralfile-logo.png" alt="FF1" class="ff1-logo">
      <span class="ff1-text">Copy FF1 Command</span>
    </button>
  </div>
  
  <script>
    // FPS meter - calculated locally from iframe's frame timing
    (function() {
      const meter = document.getElementById('fps-meter');
      const iframe = document.getElementById('display-iframe');
      let frameCount = 0;
      let lastTime = performance.now();
      let currentFps = 0;
      
      // Listen for FPS reports from the iframe (if supported)
      window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'ac:fps-report') {
          currentFps = e.data.fps;
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
        }
      });
      
      // Fallback: calculate FPS from local animation frame
      function updateFps() {
        frameCount++;
        const now = performance.now();
        const elapsed = now - lastTime;
        
        if (elapsed >= 1000) {
          currentFps = Math.round(frameCount * 1000 / elapsed);
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
          frameCount = 0;
          lastTime = now;
        }
        
        requestAnimationFrame(updateFps);
      }
      
      // Start FPS counting after iframe loads
      iframe.addEventListener('load', () => {
        setTimeout(() => {
          updateFps();
          // Also request FPS from iframe in case it reports its own
          iframe.contentWindow?.postMessage({ type: 'ac:request-fps' }, '*');
        }, 500);
      });
    })();
  </script>
  
  <script>
    // üîì KidLisp Scramble/Decode Animation for Device Mode
    // Shows scrambled code during boot, reveals when piece starts running
    // Each character has its own rhythm seeded by its original source character
    (function() {
      const SCRAMBLE_CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';
      const SCRAMBLE_CHARS_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      const SCRAMBLE_CHARS_OTHER = '0123456789(),-=+*/<>:;\"\'.!?@#$%^&_~`[]{}|';
      
      let isScrambling = false;
      let scrambleAnimationFrame = null;
      let scrambleIntervalId = null;
      const SCRAMBLE_FPS = 12; // Slower base rate (12fps)
      const SCRAMBLE_INTERVAL = 1000 / SCRAMBLE_FPS;
      let pendingSource = null;
      let pendingHighlightedHtml = null;
      let decodeResolver = null;
      let waitingForDecode = false;
      let currentBootMessage = ''; // Current boot message to weave into scramble
      let scrambleColorTimeout = null;

      // Detect slideshow/playlist mode early to skip legacy initial scramble
      const scrambleParams = new URLSearchParams(window.location.search);
      const hasPlaylist = !!(scrambleParams.get('playlist_url') || scrambleParams.get('slideshow'));
      
      const HL_COLOR_MAP = {
        'hl-comment': '#6272a4',
        'hl-string': 'orange',
        'hl-number': 'lime',
        'hl-keyword': 'pink',
        'hl-api': 'cyan',
        'hl-timing': '#ffb86c',
        'hl-paren': '#888',
        'hl-code-ref': 'limegreen',
        'hl-code-id': 'lime',
        'hl-paint-ref': 'magenta',
        'hl-paint-id': 'orange',
        'hl-fade-sep': 'mediumseagreen',
        'hl-fade-dir': 'cyan',
        'hl-fade-colon': 'lime',
      };
      
      // Per-character state for seeded rhythms
      let charStates = []; // { lastChange: timestamp, interval: ms, currentChar: string }
      let charColors = []; // Per-character target colors based on syntax highlight
      let globalTick = 0;

      function scheduleScrambleColoring(inner) {
        if (!inner) return;
        inner.classList.remove('scramble-coloring');
        if (scrambleColorTimeout) {
          clearTimeout(scrambleColorTimeout);
        }
        scrambleColorTimeout = setTimeout(() => {
          inner.classList.add('scramble-coloring');
        }, 0);
      }
      
      // Expose setter for boot message
      window.setBootMessage = function(msg) {
        // Clean up the message
        if (msg?.startsWith?.('ready:')) {
          currentBootMessage = '';  // Clear on ready
        } else if (msg?.includes?.('(')) {
          // Strip timing info
          currentBootMessage = msg.replace(/\s*\([^)]+\)\s*/g, '').toLowerCase();
        } else {
          currentBootMessage = (msg || '').toLowerCase();
        }
      };
      
      // Get a seeded "random" value from a character (deterministic per char)
      function charSeed(char) {
        return char.charCodeAt(0);
      }
      
      function escapeHtmlChar(char) {
        if (char === '&') return '&amp;';
        if (char === '<') return '&lt;';
        if (char === '>') return '&gt;';
        return char;
      }
      
      function buildColorMapFromHighlightedHtml(highlightedHtml) {
        if (!highlightedHtml) return [];
        const temp = document.createElement('div');
        temp.innerHTML = highlightedHtml;
        const colors = [];
        const walker = document.createTreeWalker(temp, NodeFilter.SHOW_TEXT, null);
        let node = walker.nextNode();
        while (node) {
          let color = null;
          let el = node.parentElement;
          while (el) {
            if (!color && el.classList?.contains('hl-color')) {
              const style = el.getAttribute('style') || '';
              const match = style.match(/color\s*:\s*([^;]+)/i);
              if (match) color = match[1];
            }
            if (!color && el.classList) {
              for (const cls of el.classList) {
                if (HL_COLOR_MAP[cls]) {
                  color = HL_COLOR_MAP[cls];
                  break;
                }
              }
            }
            if (color) break;
            el = el.parentElement;
          }
          const text = node.textContent || '';
          for (let i = 0; i < text.length; i++) {
            colors.push(color);
          }
          node = walker.nextNode();
        }
        return colors;
      }
      
      // Scramble a character (preserve whitespace and casing)
      function getScrambledChar(original) {
        if (original === '\n' || original === ' ' || original === '\t') return original;
        // Preserve casing
        if (original >= 'a' && original <= 'z') {
          return SCRAMBLE_CHARS_LOWER[Math.floor(Math.random() * SCRAMBLE_CHARS_LOWER.length)];
        }
        if (original >= 'A' && original <= 'Z') {
          return SCRAMBLE_CHARS_UPPER[Math.floor(Math.random() * SCRAMBLE_CHARS_UPPER.length)];
        }
        // For numbers and symbols, use other chars
        return SCRAMBLE_CHARS_OTHER[Math.floor(Math.random() * SCRAMBLE_CHARS_OTHER.length)];
      }
      
      // Initialize per-character states from source
      function initCharStates(source, highlightedHtml) {
        const chars = source.split('');
        charColors = buildColorMapFromHighlightedHtml(highlightedHtml);
        if (charColors.length !== chars.length) {
          charColors = new Array(chars.length).fill(null);
        }
        charStates = chars.map((char, idx) => {
          if (char === '\n' || char === ' ' || char === '\t') {
            return { isWhitespace: true, char: char };
          }
          // Seed interval from character code: range 100ms to 600ms
          const seed = charSeed(char);
          const interval = 100 + ((seed * 7 + idx * 3) % 500);
          return {
            isWhitespace: false,
            original: char,
            currentChar: getScrambledChar(char),
            interval: interval,
            lastChange: performance.now() - Math.random() * interval, // Stagger start times
            tickOffset: (seed + idx) % 20, // Phase offset for visual variety
            color: charColors[idx] || null,
          };
        });
      }
      
      // Build scrambled HTML using per-character rhythm and syntax colors
      function buildScrambledTextWithRhythm(source) {
        const now = performance.now();
        globalTick++;
        
        // Initialize states if needed
        if (charStates.length !== source.length) {
          initCharStates(source, pendingHighlightedHtml);
        }
        
        const result = charStates.map((state, idx) => {
          if (state.isWhitespace) return escapeHtmlChar(state.char);
          
          // Check if this character should change based on its own rhythm
          const elapsed = now - state.lastChange;
          if (elapsed >= state.interval) {
            state.currentChar = getScrambledChar(state.original);
            state.lastChange = now;
          }
          
          const char = escapeHtmlChar(state.currentChar);
          const colorDelayMs = 200 + ((state.original.charCodeAt(0) * 5 + idx * 7) % 1800);
          const colorDelay = (colorDelayMs / 1000).toFixed(2);
          const colorStyle = state.color
            ? ` style="--target-color: ${state.color}; --color-delay: ${colorDelay}s;"`
            : ` style="--color-delay: ${colorDelay}s;"`;
          return `<span class="scramble-char"${colorStyle}>${char}</span>`;
        });
        
        // Weave boot message into random positions
        if (currentBootMessage && currentBootMessage.length > 0) {
          // Find all line boundaries
          const lines = [];
          let lineStart = 0;
          for (let i = 0; i < result.length; i++) {
            if (result[i] === '\n') {
              if (i - lineStart > currentBootMessage.length + 4) {
                lines.push({ start: lineStart, end: i });
              }
              lineStart = i + 1;
            }
          }
          if (result.length - lineStart > currentBootMessage.length + 4) {
            lines.push({ start: lineStart, end: result.length });
          }
          
          // Insert into ~30% of lines
          if (lines.length > 0) {
            const shuffled = [...lines].sort(() => Math.random() - 0.5);
            const insertCount = Math.max(1, Math.floor(shuffled.length * 0.3));
            
            for (let n = 0; n < insertCount; n++) {
              const line = shuffled[n];
              const lineLength = line.end - line.start;
              const insertPos = line.start + Math.floor(Math.random() * (lineLength - currentBootMessage.length - 2)) + 1;
              
              for (let i = 0; i < currentBootMessage.length; i++) {
                const targetIdx = insertPos + i;
                if (targetIdx < result.length && result[targetIdx] !== '\n') {
                  result[targetIdx] = currentBootMessage[i];
                }
              }
            }
          }
        }
        
        return result.join('');
      }
      
      // Show scrambled placeholder immediately on page load with continuous animation
      // Uses eager-fetched source for correct length, with per-character rhythm
      let initialScrambleFrame = null;
      let initialScrambleActive = true;
      let eagerSource = null; // Will be set from eager fetch
      let lastScrambleRenderTime = 0;
      (function showInitialScramble() {
        const inner = document.getElementById('source-code-inner');
        const overlay = document.getElementById('source-overlay');
        if (!inner) return;
        if (hasPlaylist) return;
        document.body.classList.add('booting');
        
        // Add scrambling class to hide QR/stats during initial load
        if (overlay) overlay.classList.add('scrambling');
        scheduleScrambleColoring(inner);
        
        // Check if eager fetch completed - use that source for scrambling
        if (window.__eagerSourceFetch) {
          window.__eagerSourceFetch.then(data => {
            if (data?.source && initialScrambleActive) {
              eagerSource = data.source;
              initCharStates(eagerSource, null); // Initialize per-character rhythms
              console.log('üöÄ Eager source ready for scramble:', eagerSource.length, 'chars');
            }
          });
        }
        
        // Use requestAnimationFrame for smoother per-character updates
        function animateInitialScramble() {
          if (!initialScrambleActive) return;
          // Use eager source if available, otherwise show nothing (waiting)
          const now = performance.now();
          if (eagerSource && now - lastScrambleRenderTime >= 33) {
            inner.innerHTML = buildScrambledTextWithRhythm(eagerSource);
            document.body.classList.remove('booting');
            lastScrambleRenderTime = now;
          }
          initialScrambleFrame = requestAnimationFrame(animateInitialScramble);
        }
        animateInitialScramble();
      })();
      
      // Stop initial scramble when real scramble starts
      function stopInitialScramble() {
        initialScrambleActive = false;
        if (initialScrambleFrame) {
          cancelAnimationFrame(initialScrambleFrame);
          initialScrambleFrame = null;
        }
        document.body.classList.remove('booting');
      }
      
      // Global stop function for slideshow mode to cancel any scramble
      window.stopScrambleAnimation = function() {
        stopInitialScramble();
        isScrambling = false;
        waitingForDecode = false;
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
          scrambleAnimationFrame = null;
        }
        if (scrambleIntervalId) {
          clearInterval(scrambleIntervalId);
          scrambleIntervalId = null;
        }
        // Remove scrambling class to show QR/stats
        const overlay = document.getElementById('source-overlay');
        if (overlay) overlay.classList.remove('scrambling');
        const inner = document.getElementById('source-code-inner');
        if (inner) inner.classList.remove('scramble-coloring');
      };
      
      // Start scramble animation - keeps scrambling until signaled
      window.startScrambleAnimation = function(source, highlightedHtml) {
        const inner = document.getElementById('source-code-inner');
        const overlay = document.getElementById('source-overlay');
        if (!inner || !source) return;
        
        // Stop the initial placeholder scramble
        stopInitialScramble();
        
        // Add scrambling class to hide QR/stats during scramble
        if (overlay) overlay.classList.add('scrambling');
        scheduleScrambleColoring(inner);
        
        pendingSource = source;
        pendingHighlightedHtml = highlightedHtml;
        isScrambling = true;
        waitingForDecode = true;
        
        // Initialize per-character rhythms for the source
        initCharStates(source, highlightedHtml);
        
        console.log('üì∫ Starting scramble animation with per-character rhythm...');
        
        // Use requestAnimationFrame for smooth per-character rhythm updates
        let lastScrambleFrameTime = 0;
        function scrambleLoop() {
          if (!isScrambling || !waitingForDecode) return;
          
          const now = performance.now();
          // Show scrambled plain text with per-character rhythm (throttled to ~30fps)
          if (now - lastScrambleFrameTime >= 33) {
            inner.innerHTML = buildScrambledTextWithRhythm(pendingSource);
            lastScrambleFrameTime = now;
          }
          
          scrambleAnimationFrame = requestAnimationFrame(scrambleLoop);
        }
        scrambleLoop();

        // Start color transition after a short delay (start whiter)
        setTimeout(() => {
          if (isScrambling && waitingForDecode) {
            inner.classList.add('scramble-coloring');
          }
        }, 600);
        
        // Return promise that resolves when decode is triggered
        return new Promise(resolve => {
          decodeResolver = resolve;
        });
      };
      
      // Signal to start decoding (called when piece starts running)
      window.signalDecode = function() {
        if (!waitingForDecode || !pendingSource) return;
        
        console.log('üì∫ Signal received - starting decode animation');
        waitingForDecode = false;
        
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
        }
        if (scrambleIntervalId) {
          clearInterval(scrambleIntervalId);
          scrambleIntervalId = null;
        }
        
        // Start reveal animation
        revealCode();
      };
      
      // Reveal animation - characters reveal individually based on their seeded timing
      function revealCode() {
        const inner = document.getElementById('source-code-inner');
        if (!inner || !pendingSource) {
          finalize();
          return;
        }
        
        const chars = pendingSource.split('');
        const revealStartTime = performance.now();
        const revealDuration = 800; // Total reveal time in ms

        // Keep scramble coloring active during reveal to avoid white flash
        inner.classList.add('scramble-coloring');
        
        // Each character has a reveal time based on its seed
        const revealTimes = chars.map((char, idx) => {
          if (char === '\n' || char === ' ' || char === '\t') return 0; // Whitespace reveals instantly
          const seed = char.charCodeAt(0);
          // Stagger reveals: seed determines when in the reveal window this char appears
          // Mix in position for variety, but keep some randomness
          const positionFactor = idx / chars.length;
          const seedFactor = (seed % 100) / 100;
          // Combine: mostly position-based (left to right feel) with seed variation
          return (positionFactor * 0.7 + seedFactor * 0.3) * revealDuration;
        });
        
        const settled = new Array(chars.length).fill(false);
        
        function animateReveal() {
          if (!isScrambling) {
            finalize();
            return;
          }
          
          const now = performance.now();
          const elapsed = now - revealStartTime;
          
          // Safety: Force complete if exceeded duration
          if (elapsed > revealDuration * 1.5) {
            finalize();
            return;
          }
          
          // Build current HTML - each char reveals at its own time
          const currentHtml = chars.map((char, i) => {
            if (char === '\n' || char === ' ' || char === '\t') return escapeHtmlChar(char);

            const targetColor = charColors[i] || null;
            const colorDelayMs = 200 + ((char.charCodeAt(0) * 5 + i * 7) % 1800);
            const colorDelay = (colorDelayMs / 1000).toFixed(2);
            const colorStyle = targetColor
              ? ` style="--target-color: ${targetColor}; --color-delay: ${colorDelay}s;"`
              : ` style="--color-delay: ${colorDelay}s;"`;

            // Check if this character should be revealed yet
            if (elapsed >= revealTimes[i]) {
              settled[i] = true;
              return `<span class="scramble-char"${colorStyle}>${escapeHtmlChar(char)}</span>`;
            }

            // Still scrambling - use the charStates rhythm if available
            if (charStates[i] && !charStates[i].isWhitespace) {
              const state = charStates[i];
              const stateElapsed = now - state.lastChange;
              if (stateElapsed >= state.interval) {
                state.currentChar = getScrambledChar(state.original);
                state.lastChange = now;
              }
              return `<span class="scramble-char"${colorStyle}>${escapeHtmlChar(state.currentChar)}</span>`;
            }

            return `<span class="scramble-char"${colorStyle}>${escapeHtmlChar(getScrambledChar(char))}</span>`;
          }).join('');

          inner.innerHTML = currentHtml;
          
          // Check if done
          if (settled.every(s => s)) {
            finalize();
            return;
          }
          
          requestAnimationFrame(animateReveal);
        }
        
        requestAnimationFrame(animateReveal);
      }
      
      // Finalize - show highlighted code and setup scrolling
      function finalize() {
        const inner = document.getElementById('source-code-inner');
        const codeEl = document.getElementById('source-code');
        
        if (inner && pendingHighlightedHtml) {
          // Crossfade into highlighted code to avoid a white flash
          inner.style.opacity = '0';
          inner.innerHTML = pendingHighlightedHtml;
          requestAnimationFrame(() => {
            inner.style.opacity = '1';
          });
          
          // Setup scrolling for long code
          requestAnimationFrame(() => {
            const containerHeight = codeEl.clientHeight;
            const contentHeight = inner.scrollHeight;
            
            if (contentHeight > containerHeight + 20) {
              const scrollDistance = contentHeight - containerHeight + 20;
              inner.classList.add('scrolling');
              inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
              const scrollDuration = 12 + (scrollDistance / 150);
              inner.style.setProperty('--scroll-duration', `${scrollDuration}s`);
            }
          });
          
          // Apply timing durations to timing elements
          inner.querySelectorAll('.hl-timing-active[data-duration]').forEach(el => {
            const duration = parseFloat(el.dataset.duration) || 1;
            const clampedDuration = Math.max(0.1, Math.min(duration, 10));
            el.style.setProperty('--timing-duration', clampedDuration + 's');
          });
        }
        
        // Remove scrambling class to show QR/stats
        const overlay = document.getElementById('source-overlay');
        if (overlay) overlay.classList.remove('scrambling');
        
        isScrambling = false;
        pendingSource = null;
        pendingHighlightedHtml = null;
        
        if (decodeResolver) {
          decodeResolver();
          decodeResolver = null;
        }
      }
      
      // Stop scramble immediately
      window.stopScramble = function() {
        isScrambling = false;
        waitingForDecode = false;
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
        }
        finalize();
      };
      
      // Listen for boot-log messages from iframe
      window.addEventListener('message', (e) => {
        if (e.data?.type === 'boot-log') {
          const msg = e.data.message;
          console.log('üì∫ Boot log:', msg);
          
          // Feed the boot message to the scramble animation (woven into text)
          window.setBootMessage?.(msg);
          
          // Signal decode when piece starts running
          // "loaded" is sent when the piece finishes loading
          if (msg === 'loaded' || msg === 'running boot' || msg?.includes?.('running')) {
            window.signalDecode?.();
          }
        }
      });
    })();
  </script>
  
  <script>
    // Calculate smart default density based on screen resolution
    // 4K (3840x2160+) ‚Üí density 8 (larger pixels for viewing distance)
    // Everything else ‚Üí density 4 (good default for most displays)
    function getSmartDensity() {
      const screenWidth = window.screen.width * (window.devicePixelRatio || 1);
      const screenHeight = window.screen.height * (window.devicePixelRatio || 1);
      const maxDim = Math.max(screenWidth, screenHeight);
      
      if (maxDim >= 3840) return 8;  // 4K+
      return 4;                       // Default for all other resolutions
    }
    
    // Calculate smart UI scale based on density and screen characteristics
    // UI scale should be proportional to density for visual consistency
    // On native 4K (dpr=1), we need extra scaling since browser doesn't auto-scale
    function getSmartUIScale(density) {
      const dpr = window.devicePixelRatio || 1;
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const maxDim = Math.max(screenWidth, screenHeight);
      const hostname = window.location.hostname;
      
      // Base multiplier: density * 1.5 gives good proportional sizing
      const baseScale = density * 1.5;
      
      // Device subdomains (device.kidlisp.com, top.kidlisp.com) are typically
      // displayed on 4K TVs/displays viewed from a distance - use larger UI
      // BUT only if the screen is actually 4K resolution
      const isDeviceSubdomain = hostname === 'device.kidlisp.com' || 
                                hostname === 'top.kidlisp.com' ||
                                window.location.pathname.startsWith('/device.kidlisp.com') ||
                                window.location.pathname.startsWith('/top.kidlisp.com');
      
      // Check if this is a 4K-class display (3840x2160 or similar)
      // FF1 reports CSS pixels 1920x1200 which is 4K scaled by dpr=2
      // Native 4K would be 3840+ with dpr=1
      const is4KDisplay = (maxDim >= 3840 && dpr === 1) || 
                          (maxDim >= 1920 && screenHeight >= 1080 && dpr >= 2);
      
      if (isDeviceSubdomain && is4KDisplay) {
        // FF1/device mode on 4K: 4x multiplier for comfortable TV viewing distance
        return Math.round(baseScale * 4);
      } else if (isDeviceSubdomain) {
        // Device subdomain but NOT 4K (e.g., laptop testing) - use 2x for readability
        return Math.round(baseScale * 2);
      }
      
      // For native 4K/high-res with dpr=1, apply additional multiplier
      if (dpr === 1 && maxDim >= 3840) return Math.round(baseScale * 20);  // 4K native
      if (dpr === 1 && maxDim >= 2560) return Math.round(baseScale * 10);  // 1440p native
      return Math.round(baseScale);                                         // Retina/scaled displays
    }
    
    // Get density from URL params, fallback to smart density
    const urlParams = new URLSearchParams(window.location.search);
    let densityParam = parseInt(urlParams.get('density')) || getSmartDensity();
    
    // Set CSS custom property for density-based sizing (for piece rendering)
    document.documentElement.style.setProperty('--density', densityParam);
    
    // Set UI scale - can be explicit via ?ui_scale=X or derived from density
    // UI scale is proportional to density for visual consistency
    const uiScale = parseInt(urlParams.get('ui_scale')) || getSmartUIScale(densityParam);
    document.documentElement.style.setProperty('--ui-scale', uiScale);
    console.log('üì∫ UI Scale:', uiScale, '(density=' + densityParam + ', dpr=' + (window.devicePixelRatio || 1) + ', screen=' + window.screen.width + 'x' + window.screen.height + ')');
    
    // Listen for density changes from iframe (Cmd+/- keyboard controls)
    window.addEventListener('message', (e) => {
      // Accept both message formats: 'ac:density-change' (new) and 'ac-density-change' (legacy)
      if ((e.data?.type === 'ac:density-change' || e.data?.type === 'ac-density-change') && typeof e.data.density === 'number') {
        densityParam = e.data.density;
        document.documentElement.style.setProperty('--density', densityParam);
        // Update UI scale proportionally when density changes
        const newUiScale = getSmartUIScale(densityParam);
        document.documentElement.style.setProperty('--ui-scale', newUiScale);
        // Update progress bar height (1.5x density for medium thickness)
        const progressBar = document.getElementById('progress-bar');
        if (progressBar) progressBar.style.height = `${Math.max(2, Math.round(1.5 * densityParam))}px`;
        console.log('üì∫ Density updated from iframe:', densityParam, '‚Üí UI Scale:', newUiScale);
      }
    });
    
    // Default display parameters for FF1 and display devices
    // (getSmartDensity is defined earlier in the density setup script)
    const DEVICE_DEFAULTS = {
      density: getSmartDensity(), // Smart density based on screen resolution
      device: true,   // Device mode - auto-enables audio, combines tv+nogap+noauth
      tv: true,       // Non-interactive TV mode
      nogap: true,    // Borderless / no gap
      nolabel: true,  // Hide labels
      noauth: true,   // No auth prompts
      popout: true,   // Popout mode
      perf: false     // Performance/FPS HUD (opt-in)
    };
    
    // Parse URL and query params
    const params = new URLSearchParams(window.location.search);
    const pathname = window.location.pathname;
    const hostname = window.location.hostname;
    
    // UI elements
    const iframe = document.getElementById('display-iframe');
    const errorScreen = document.getElementById('error-screen');
    const errorText = document.getElementById('error-text');
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SOCKLOGS - Remote console log forwarding via WebSocket
    // When ?socklogs is present, hijack console and send logs to session-server
    // Use 'ac-ff1 logs' to view logs from CLI
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const socklogsEnabled = params.has('socklogs');
    let socklogsWs = null;
    let socklogsQueue = []; // Buffer logs before connection established
    const socklogsDeviceId = `ff1-${Date.now().toString(36)}`; // Unique device ID
    
    if (socklogsEnabled) {
      console.log('üîå SockLogs enabled - connecting to session-server...');
      // TODO: Once SSL is configured on production origin, this will work via Cloudflare
      // For now, socklogs only works in local dev mode
      const sessionUrl = dev 
        ? 'wss://localhost:8889/socklogs?role=device&deviceId=' + socklogsDeviceId
        : 'wss://session-server.aesthetic.computer/socklogs?role=device&deviceId=' + socklogsDeviceId;
      
      try {
        socklogsWs = new WebSocket(sessionUrl);
        
        socklogsWs.onopen = () => {
          console.log('üîå SockLogs connected:', socklogsDeviceId);
          // Flush queued logs
          for (const entry of socklogsQueue) {
            socklogsWs.send(JSON.stringify(entry));
          }
          socklogsQueue = [];
        };
        
        socklogsWs.onclose = () => {
          console.log('üîå SockLogs disconnected');
          socklogsWs = null;
        };
        
        socklogsWs.onerror = (e) => {
          console.warn('üîå SockLogs error:', e);
        };
        
        // Hijack console methods
        const originalConsole = {};
        ['log', 'warn', 'error', 'info', 'debug'].forEach(method => {
          originalConsole[method] = console[method].bind(console);
          console[method] = (...args) => {
            // Call original
            originalConsole[method](...args);
            
            // Format message
            const message = args.map(a => {
              try {
                return typeof a === 'object' ? JSON.stringify(a) : String(a);
              } catch {
                return String(a);
              }
            }).join(' ');
            
            const entry = {
              type: 'log',
              level: method,
              message,
              timestamp: Date.now(),
              url: window.location.href
            };
            
            // Send or queue
            if (socklogsWs?.readyState === WebSocket.OPEN) {
              socklogsWs.send(JSON.stringify(entry));
            } else {
              socklogsQueue.push(entry);
              if (socklogsQueue.length > 100) socklogsQueue.shift(); // Limit queue
            }
          };
        });
        
        // Capture errors
        window.addEventListener('error', (e) => {
          const entry = {
            type: 'log',
            level: 'error',
            message: `[UNCAUGHT] ${e.message} at ${e.filename}:${e.lineno}`,
            timestamp: Date.now(),
            url: window.location.href
          };
          if (socklogsWs?.readyState === WebSocket.OPEN) {
            socklogsWs.send(JSON.stringify(entry));
          } else {
            socklogsQueue.push(entry);
          }
        });
        
        // Capture unhandled promise rejections
        window.addEventListener('unhandledrejection', (e) => {
          const entry = {
            type: 'log',
            level: 'error',
            message: `[UNHANDLED REJECTION] ${e.reason}`,
            timestamp: Date.now(),
            url: window.location.href
          };
          if (socklogsWs?.readyState === WebSocket.OPEN) {
            socklogsWs.send(JSON.stringify(entry));
          } else {
            socklogsQueue.push(entry);
          }
        });
        
      } catch (e) {
        console.warn('üîå SockLogs setup failed:', e);
      }
    }
    
    // Boot logging (console only, no DOM log)
    function addLog(msg, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${msg}`);
    }
    
    // Determine display mode and URL
    const dev = hostname === 'localhost' || hostname === 'local.aesthetic.computer';
    const aestheticUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
    
    // Check if this is an FF1/device subdomain (top.kidlisp.com, device.kidlisp.com)
    const isDeviceSubdomain = hostname === 'device.kidlisp.com' || hostname === 'top.kidlisp.com';
    const isTopPlaylist = hostname === 'top.kidlisp.com' || pathname.startsWith('/top.kidlisp.com');
    
    const logDevice = (...args) => {
      console.log('üì∫ DEVICE:', ...args);
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '));
    };
    
    // Known playlist shortcuts (for nice URLs like /playlist/top100)
    const KNOWN_PLAYLISTS = {
      'top100': '6e53465e-976f-4e93-89ff-c58b6d434fa7',
      'colors': '4b872517-e4d8-4433-af8b-a9a4a8204cc9',
      'chords': '49f0ee0e-0303-4192-9cb2-aa3c5abb64b5',
    };
    const FEED_URL = 'https://feed.aesthetic.computer';
    
    // Parse codeId or playlist path:
    // device.kidlisp.com/codeId
    // device.kidlisp.com/playlist/top100 (short playlist URL)
    // top.kidlisp.com (auto-loads top100 playlist)
    // localhost:8888/kidlisp.com/device/codeId
    // localhost:8888/device.kidlisp.com/codeId
    // localhost:8888/top.kidlisp.com
    let codeId = null;
    let slideshowShortcut = null;  // Will be set if using /playlist/xxx path
    const pathParts = pathname.split('/').filter(p => p);
    
    console.log('üì∫ Routing debug:', { hostname, pathname, pathParts });
    
    // top.kidlisp.com auto-loads top100 playlist
    if (hostname === 'top.kidlisp.com') {
      slideshowShortcut = 'top100';
      console.log('üì∫ Matched top.kidlisp.com, set slideshowShortcut:', slideshowShortcut);
    } else if (pathname.startsWith('/top.kidlisp.com')) {
      // Local dev: localhost:8888/top.kidlisp.com
      slideshowShortcut = 'top100';
    } else if (hostname === 'device.kidlisp.com') {
      // Production: device.kidlisp.com/codeId or /playlist/top100
      if (pathParts[0] === 'playlist' && pathParts[1]) {
        slideshowShortcut = pathParts[1].toLowerCase();
      } else {
        codeId = pathParts[0] || null;
      }
    } else if (pathname.startsWith('/device.kidlisp.com/')) {
      // Local dev: localhost:8888/device.kidlisp.com/codeId or /playlist/top100
      if (pathParts[1] === 'playlist' && pathParts[2]) {
        slideshowShortcut = pathParts[2].toLowerCase();
      } else {
        codeId = pathParts[1] || null;
      }
    } else if (pathParts[0] === 'kidlisp.com' && pathParts[1] === 'device') {
      // Local dev: localhost:8888/kidlisp.com/device/codeId
      codeId = pathParts[2] || null;
    }
    
    // Ensure $ prefix on codeId (device.kidlisp.com/roz ‚Üí $roz)
    if (codeId && !codeId.startsWith('$')) {
      codeId = '$' + codeId;
    }
    
    // Allow param overrides of defaults
    const density = params.get('density') ?? DEVICE_DEFAULTS.density;
    const device = params.get('device') ?? DEVICE_DEFAULTS.device;
    const tv = params.get('tv') ?? DEVICE_DEFAULTS.tv;
    const nogap = params.get('nogap') ?? DEVICE_DEFAULTS.nogap;
    const nolabel = params.get('nolabel') ?? DEVICE_DEFAULTS.nolabel;
    const noauth = params.get('noauth') ?? DEVICE_DEFAULTS.noauth;
    const popout = params.get('popout') ?? DEVICE_DEFAULTS.popout;
    const perf = params.get('perf') ?? DEVICE_DEFAULTS.perf;
    
    // Playlist mode params (for DP-1 playlist progress bar)
    const isPlaylist = params.get('playlist') === 'true';
    const playlistDuration = parseInt(params.get('duration')) || 60; // seconds
    
    // Slideshow mode params (for full DP-1 playlist client)
    // playlist_url: URL to a DP-1 playlist JSON (e.g., feed.aesthetic.computer/api/v1/playlists/{id})
    // start_index: Which item to start from (0-based, default 0)
    // OR use short path: /playlist/top100, /playlist/colors, /playlist/chords
    let playlistUrl = params.get('playlist_url');
    const startIndex = parseInt(params.get('start_index')) || 0;
    
    // Resolve slideshow shortcut to full playlist URL
    console.log('üì∫ Before playlist resolution:', { slideshowShortcut, KNOWN_PLAYLISTS, hasKey: slideshowShortcut ? KNOWN_PLAYLISTS[slideshowShortcut] : null });
    if (slideshowShortcut && KNOWN_PLAYLISTS[slideshowShortcut]) {
      playlistUrl = `${FEED_URL}/api/v1/playlists/${KNOWN_PLAYLISTS[slideshowShortcut]}`;
      console.log('üì∫ Resolved playlist shortcut:', slideshowShortcut, '‚Üí', playlistUrl);
    }
    
    // Flag to indicate we're in slideshow mode (skip scramble animation)
    const slideshowMode = !!playlistUrl;
    
    // Slideshow state (populated when playlist_url is provided)
    let slideshowPlaylist = null;  // The fetched DP-1 playlist
    let slideshowIndex = startIndex;  // Current item index
    let slideshowTimer = null;  // Timer for auto-advance
    
    // Build query string for display params
    function buildDisplayParams() {
      const p = new URLSearchParams();
      if (density !== null) p.set('density', density);
      if (device) p.set('device', 'true');
      if (tv) p.set('tv', 'true');
      if (nogap) p.set('nogap', 'true');
      if (nolabel) p.set('nolabel', 'true');
      if (noauth) p.set('noauth', 'true');
      if (popout) p.set('popout', 'true');
      if (perf) p.set('perf', 'true');
      p.set('noboot', 'true'); // Skip boot animation for clean device display
      p.set('t', Date.now()); // Cache bust
      return p.toString();
    }
    
    function showError(msg) {
      errorText.textContent = msg;
      errorScreen.classList.add('visible');
    }
    
    // Initialize display
    function init() {
      logDevice('init', { codeId, density, dev, hostname, pathname, playlistUrl });
      
      // Check if we're in slideshow mode (playlist_url param provided)
      if (playlistUrl) {
        initSlideshow();
        return;
      }
      
      if (!codeId) {
        showError('Usage: device.kidlisp.com/{codeId} or ?playlist_url=...');
        return;
      }
      
      // Set page title (codeId already includes $ prefix)
      document.title = `KidLisp.com ¬∑ ${codeId}`;
      
      // Build the codeId URL with display params
      // codeId (e.g. "$zo5") loads the stored kidlisp code from MongoDB
      iframe.src = `${aestheticUrl}/${codeId}?${buildDisplayParams()}`;
      
      logDevice('iframe src', { src: iframe.src });
      
      // Handle iframe load
      iframe.addEventListener('load', () => {
        logDevice('iframe loaded');
        // Source overlay stays visible always - shows code and QR
      });
      
      // Listen for iframe errors
      iframe.addEventListener('error', (e) => {
        addLog(`iframe error: ${e.message || 'unknown'}`, 'error');
      });
      
      // Progress bar will be started when piece is ready (not on iframe load)
      // See window.addEventListener('message', ...) for boot-log 'ready' handler
      console.log('üì∫ Playlist mode:', isPlaylist, 'duration:', playlistDuration);
      console.log('üì∫ Waiting for piece ready before starting progress bar...');
      
      // Fetch and display KidLisp source code with syntax highlighting
      fetchAndDisplaySource(codeId);
      
      // Setup the FF1 CLI copy button for single pieces
      setupFF1CopyButton(codeId);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SLIDESHOW MODE - Full DP-1 playlist client
    // Fetches playlist from playlist_url and auto-advances through items
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async function initSlideshow() {
      console.log('üì∫ Initializing slideshow mode with URL:', playlistUrl);
      
      // Get the FF1 module elements (playlist info is now inside the FF1 module)
      const playlistTitle = document.getElementById('ff1-playlist-title');
      const playlistPosition = document.getElementById('ff1-playlist-position');
      
      if (playlistTitle) playlistTitle.textContent = 'Loading playlist...';
      
      // Setup FF1 copy button for playlist mode (also shows playlist header)
      setupFF1CopyButtonForPlaylist();
      
      try {
        // Fetch the DP-1 playlist
        const response = await fetch(playlistUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch playlist: ${response.status}`);
        }
        
        slideshowPlaylist = await response.json();
        console.log('üì∫ Playlist loaded:', slideshowPlaylist.title, 'with', slideshowPlaylist.items?.length, 'items');
        
        if (!slideshowPlaylist.items || slideshowPlaylist.items.length === 0) {
          showError('Playlist is empty');
          return;
        }
        
        // Update playlist title in FF1 module
        if (playlistTitle) playlistTitle.textContent = slideshowPlaylist.title || 'Untitled Playlist';
        
        // Clamp start index to valid range
        if (slideshowIndex >= slideshowPlaylist.items.length) {
          slideshowIndex = 0;
        }
        
        // Set page title
        document.title = `KidLisp.com ¬∑ ${slideshowPlaylist.title || 'Slideshow'}`;
        
        // Start playing from the start index
        playCurrentItem();
        
      } catch (e) {
        console.error('üì∫ Failed to load playlist:', e);
        showError(`Failed to load playlist: ${e.message}`);
      }
    }
    
    function playCurrentItem() {
      if (!slideshowPlaylist || !slideshowPlaylist.items) return;
      
      const item = slideshowPlaylist.items[slideshowIndex];
      if (!item) {
        console.log('üì∫ No more items, looping to start');
        slideshowIndex = 0;
        playCurrentItem();
        return;
      }
      
      console.log('üì∫ Playing item', slideshowIndex + 1, '/', slideshowPlaylist.items.length, ':', item.title);
      
      // Reset progress bar flag for new piece
      progressBarStarted = false;
      
      // Update position display in FF1 module
      const playlistPosition = document.getElementById('ff1-playlist-position');
      if (playlistPosition) playlistPosition.textContent = `${slideshowIndex + 1} / ${slideshowPlaylist.items.length}`;
      
      // Get the source URL from the item
      // DP-1 items have a 'source' field with the display URL
      let itemUrl = item.source || item.url || '';
      
      // Always convert to aesthetic.computer URL for the iframe
      // device.kidlisp.com URLs should NOT be used directly - they'd load another device.html!
      if (itemUrl.includes('device.kidlisp.com')) {
        // Extract the code from device.kidlisp.com URL and convert to aesthetic.computer
        const deviceMatch = itemUrl.match(/device\.kidlisp\.com\/(\$?[a-z0-9_-]+)/i);
        if (deviceMatch) {
          const rawCode = deviceMatch[1];
          const code = rawCode.startsWith('$') ? rawCode : `$${rawCode}`;
          itemUrl = `${aestheticUrl}/${code}?${buildDisplayParams()}`;
        }
      } else if (!itemUrl.includes('aesthetic.computer')) {
        // It's some other URL, add display params
        const separator = itemUrl.includes('?') ? '&' : '?';
        itemUrl = `${itemUrl}${separator}${buildDisplayParams()}`;
      } else {
        // It's already aesthetic.computer, ensure display params
        const separator = itemUrl.includes('?') ? '&' : '?';
        itemUrl = `${itemUrl}${separator}${buildDisplayParams()}`;
      }
      
      // Load the item in the iframe
      iframe.src = itemUrl;
      
      // Get duration from item or playlist defaults
      const duration = item.duration || slideshowPlaylist.defaults?.duration || 24;
      
      // Clear any existing timer
      if (slideshowTimer) {
        clearTimeout(slideshowTimer);
      }
      
      // Progress bar will be started when piece is ready (not immediately)
      // Store duration for when ready message arrives
      window.pendingSlideshowDuration = duration;
      console.log('üì∫ Waiting for piece ready before starting slideshow progress bar...');
      
      // Try to extract codeId from URL for source display
      const codeMatch = itemUrl.match(/\/(\$[a-z0-9]+)/i) || itemUrl.match(/device\.kidlisp\.com\/(\$?[a-z0-9]+)/i);
      
      // Clear previous piece info before loading new
      document.getElementById('piece-handle').textContent = '';
      document.getElementById('piece-hits').textContent = '';
      document.getElementById('piece-when').textContent = '';
      
      if (codeMatch) {
        let extractedCodeId = codeMatch[1];
        if (!extractedCodeId.startsWith('$')) extractedCodeId = '$' + extractedCodeId;
        fetchAndDisplaySource(extractedCodeId);
      } else {
        // Clear source display for non-kidlisp items
        document.getElementById('source-code-inner').innerHTML = '';
      }
      
      // Set timer to advance to next item
      slideshowTimer = setTimeout(() => {
        slideshowIndex++;
        playCurrentItem();
      }, duration * 1000);
    }
    
    function startSlideshowProgressBar(duration) {
      const progressBar = document.getElementById('progress-bar');
      const progressFill = document.getElementById('progress-fill');
      const overlay = document.getElementById('source-overlay');
      
      // Set height based on density (1.5x for medium thickness)
      const barHeight = Math.max(2, Math.round(1.5 * densityParam));
      progressBar.style.height = `${barHeight}px`;
      progressBar.classList.add('visible');
      progressBar.classList.add('fading-in');
      
      // Reset progress and clear any ending state
      progressFill.style.width = '0%';
      progressFill.classList.remove('ending');
      progressBar.classList.remove('hidden-mid');
      setTimeout(() => progressBar.classList.remove('fading-in'), 2000);
      if (overlay) overlay.classList.remove('slid-out');
      
      const startTime = Date.now();
      const durationMs = duration * 1000;
      
      function updateProgress() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(100, (elapsed / durationMs) * 100);
        currentProgressPercent = progress;
        progressFill.style.width = `${progress}%`;
        
        // Slide overlay elements based on progress:
        // First 1/6 (0-16.7%): show elements
        // Middle 4/6 (16.7%-83.3%): slide off
        // Last 1/6 (83.3%-100%): bring back
        if (overlay) {
          const shouldSlideOut = progress > 16.67 && progress < 83.33;
          if (shouldSlideOut && !overlay.classList.contains('slid-out')) {
            overlay.classList.add('slid-out');
          } else if (!shouldSlideOut && overlay.classList.contains('slid-out')) {
            overlay.classList.remove('slid-out');
          }
        }
        
        // Hide progress bar during middle section (same timing as slide out)
        const shouldHideBar = progress > 16.67 && progress < 83.33;
        if (shouldHideBar && !progressBar.classList.contains('hidden-mid')) {
          progressBar.classList.add('hidden-mid');
        } else if (!shouldHideBar && progressBar.classList.contains('hidden-mid')) {
          progressBar.classList.remove('hidden-mid');
        }
        
        // Blink red towards the end (last 10%)
        const shouldBlink = progress > 90;
        if (shouldBlink && !progressFill.classList.contains('ending')) {
          progressFill.classList.add('ending');
        } else if (!shouldBlink && progressFill.classList.contains('ending')) {
          progressFill.classList.remove('ending');
        }

        updateFF1Overlap();
        
        if (progress < 100) {
          requestAnimationFrame(updateProgress);
        }
      }
      
      requestAnimationFrame(updateProgress);
    }
    
    // Fetch KidLisp source from API (uses eager fetch if available)
    async function fetchAndDisplaySource(codeId) {
      console.log('üì∫ fetchAndDisplaySource called with:', codeId);
      // Strip $ prefix if present for API call
      const pieceCode = codeId.startsWith('$') ? codeId.slice(1) : codeId;
      const displayCode = codeId.startsWith('$') ? codeId : '$' + codeId;
      
      // Always generate QR code and label first (even before source loads)
      generateQRAndLabel(displayCode);
      
      try {
        // Use eager fetch result if available, otherwise fetch now
        let data = null;
        if (window.__eagerSourceFetch) {
          console.log('üì∫ Using eager-fetched source');
          data = await window.__eagerSourceFetch;
        }
        
        // Fallback to regular fetch if eager fetch failed or wasn't available
        if (!data) {
          const apiUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
          const url = `${apiUrl}/api/store-kidlisp?code=${pieceCode}`;
          console.log('üì∫ Fetching source from:', url);
          const response = await fetch(url, { credentials: 'omit' });
          console.log('üì∫ Source fetch response:', response.status, response.statusText);
          if (response.ok) {
            data = await response.json();
          }
        }
        
        if (data) {
          console.log('üì∫ Source data:', data);
          if (data.source) {
            displaySourceCode(data.source);
          } else {
            console.log('üì∫ No source in response');
          }
          // Display handle and hits
          displayPieceInfo(data);
        } else {
          console.log('üì∫ Source fetch failed or no data');
        }
      } catch (e) {
        console.log('üì∫ Could not fetch source:', e);
      }
    }
    
    // Display syntax-highlighted source code with scramble animation
    function displaySourceCode(source) {
      const codeEl = document.getElementById('source-code');
      const inner = document.getElementById('source-code-inner');
      if (!inner || !source) return;
      
      // Generate highlighted HTML
      const highlightedHtml = highlightKidlisp(source);
      
      // In slideshow mode, skip scramble - show highlighted code immediately
      if (slideshowMode) {
        // Stop any running scramble animation
        if (window.stopScrambleAnimation) window.stopScrambleAnimation();
        inner.innerHTML = highlightedHtml;
        document.body.classList.remove('booting');
        // Reset scrolling classes
        inner.classList.remove('scrolling');
        inner.style.removeProperty('--scroll-distance');
        inner.style.removeProperty('--scroll-duration');
        // Setup fresh scrolling for this source
        setupScrolling(codeEl, inner);
        return;
      }
      
      // Start scramble animation - will decode when piece starts running
      if (window.startScrambleAnimation) {
        window.startScrambleAnimation(source, highlightedHtml);
      } else {
        // Fallback: show highlighted code immediately
        inner.innerHTML = highlightedHtml;
        setupScrolling(codeEl, inner);
      }
    }
    
    // Setup scrolling for long code (called after decode finishes)
    function setupScrolling(codeEl, inner) {
      requestAnimationFrame(() => {
        const containerHeight = codeEl.clientHeight;
        const contentHeight = inner.scrollHeight;
        
        if (contentHeight > containerHeight + 20) {
          const scrollDistance = contentHeight - containerHeight + 20;
          inner.classList.add('scrolling');
          inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
          const scrollDuration = 12 + (scrollDistance / 150);
          inner.style.setProperty('--scroll-duration', `${scrollDuration}s`);
        }
      });
      
      // Apply timing durations to timing elements
      inner.querySelectorAll('.hl-timing-active[data-duration]').forEach(el => {
        const duration = parseFloat(el.dataset.duration) || 1;
        const clampedDuration = Math.max(0.1, Math.min(duration, 10));
        el.style.setProperty('--timing-duration', clampedDuration + 's');
      });
    }
    
    // Generate QR code pointing to kidlisp.com/$piece
    function generateQRAndLabel(displayCode) {
      console.log('üì∫ generateQRAndLabel called with:', displayCode);
      const labelEl = document.getElementById('code-label');
      const qrContainer = document.getElementById('qr-container');
      const qrWrap = document.getElementById('qr-wrap');
      
      // Build label with colored $ and code
      if (labelEl) {
        const dollar = displayCode[0] === '$' ? '$' : '';
        const code = displayCode.startsWith('$') ? displayCode.slice(1) : displayCode;
        labelEl.innerHTML = `<span class="code-dollar">${dollar}</span><span class="code-name">${code}</span>`;
        console.log('üì∫ Label set:', dollar + code);
      }
      
      // Generate QR code pointing to kidlisp.com (NOT aesthetic.computer)
      const qrUrl = `https://kidlisp.com/${displayCode}`;
      
      // Make QR wrap clickable to open the URL
      if (qrWrap) {
        qrWrap.onclick = () => window.open(qrUrl, '_blank');
        qrWrap.title = qrUrl;
      }
      
      if (qrContainer && typeof qrcode !== 'undefined') {
        try {
          console.log('üì∫ Generating QR for:', qrUrl);
          const qrGen = qrcode(0, 'L');
          qrGen.addData(qrUrl);
          qrGen.make();
          const svg = qrGen.createSvgTag(2, 0);
          qrContainer.innerHTML = svg;
          const svgEl = qrContainer.querySelector('svg');
          if (svgEl) {
            // Size is set by CSS using --density variable
            svgEl.style.display = 'block';
            svgEl.style.width = '100%';
            svgEl.style.height = '100%';
            console.log('üì∫ QR SVG created');
          }
        } catch (e) {
          console.error('üì∫ QR generation error:', e);
        }
      } else {
        console.log('üì∫ QR container not found or qrcode lib not loaded');
      }
    }
    
    // Display handle and hits info
    function displayPieceInfo(data) {
      const handleEl = document.getElementById('piece-handle');
      const hitsEl = document.getElementById('piece-hits');
      const whenEl = document.getElementById('piece-when');
      
      if (handleEl) {
        if (data.handle) {
          handleEl.textContent = data.handle;
          handleEl.style.color = 'rgb(255, 107, 157)';
          handleEl.style.cursor = 'pointer';
          handleEl.onclick = () => {
            // Open aesthetic.computer chat with handle prefilled
            window.open(`https://aesthetic.computer/prompt~${encodeURIComponent('@' + data.handle)}`, '_blank');
          };
          handleEl.title = `Chat with ${data.handle}`;
          console.log('üì∫ Handle:', data.handle);
        } else {
          handleEl.textContent = 'anonymous';
          handleEl.style.color = 'rgb(150, 150, 150)';
          handleEl.style.cursor = 'default';
          handleEl.onclick = null;
          handleEl.title = '';
          console.log('üì∫ Handle: anonymous');
        }
      }
      
      if (hitsEl && typeof data.hits === 'number') {
        hitsEl.textContent = data.hits.toLocaleString() + ' hits';
        console.log('üì∫ Hits:', data.hits);
      }
      
      if (whenEl && data.when) {
        const date = new Date(data.when);
        const formatted = date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
        whenEl.textContent = formatted;
        console.log('üì∫ When:', formatted);
      }

      // Re-check overlap after stats update
      requestAnimationFrame(updateFF1Overlap);
    }

    function updateFF1Overlap() {
      const ff1Module = document.getElementById('ff1-module');
      const qrWrap = document.getElementById('qr-wrap');
      if (!ff1Module || !qrWrap) return;

      const ff1Rect = ff1Module.getBoundingClientRect();
      const qrRect = qrWrap.getBoundingClientRect();
      const uiScaleValue = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ui-scale')) || 10;
      const margin = Math.max(12, uiScaleValue * 1.5);

      const expanded = {
        left: qrRect.left - margin,
        right: qrRect.right + margin,
        top: qrRect.top - margin,
        bottom: qrRect.bottom + margin,
      };

      const overlap = !(
        ff1Rect.right < expanded.left ||
        ff1Rect.left > expanded.right ||
        ff1Rect.bottom < expanded.top ||
        ff1Rect.top > expanded.bottom
      );

      ff1Module.classList.toggle('overlap-fade', overlap);
    }

    window.addEventListener('resize', () => requestAnimationFrame(updateFF1Overlap));
    
    // Track current FF1 CLI command (shared between single and playlist modes)
    let currentFF1Command = '';
    let ff1ButtonInitialized = false;
    
    // Initialize FF1 button click handler (only once)
    function formatFF1Command(cmd) {
      const match = cmd.match(/ff1 play\s+"(.+)"/i);
      if (!match) return cmd;
      const url = match[1]
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      return `ff1 play <span class="ff1-quote">"</span><span class="ff1-url">${url}</span><span class="ff1-quote">"</span>`;
    }

    function initFF1Button() {
      if (ff1ButtonInitialized) return;
      
      const copyBtn = document.getElementById('piece-ff1-copy');
      const ff1Module = document.getElementById('ff1-module');
      if (!copyBtn) return;
      
      copyBtn.addEventListener('click', async () => {
        if (!currentFF1Command) return;
        
        const cmdSpan = copyBtn.querySelector('.ff1-cmd');
        try {
          await navigator.clipboard.writeText(currentFF1Command);
          if (ff1Module) ff1Module.classList.add('copied');
          if (cmdSpan) cmdSpan.textContent = 'COPIED TO CLIPBOARD';
          
          setTimeout(() => {
            if (ff1Module) ff1Module.classList.remove('copied');
            if (cmdSpan) cmdSpan.innerHTML = formatFF1Command(currentFF1Command);
          }, 2000);
        } catch (e) {
          console.error('üì∫ Failed to copy:', e);
          alert('FF1 CLI Command:\n\n' + currentFF1Command);
        }
      });
      
      ff1ButtonInitialized = true;
    }
    
    // Setup the FF1 CLI copy button for single pieces
    function setupFF1CopyButton(pieceCodeId) {
      // Skip if we're in slideshow mode - playlist setup handles FF1 button
      if (slideshowMode) return;
      
      initFF1Button();
      
      const copyBtn = document.getElementById('piece-ff1-copy');
      if (!copyBtn) return;
      
      // Hide playlist header (not in playlist mode)
      const playlistHeader = document.getElementById('ff1-playlist-header');
      if (playlistHeader) playlistHeader.classList.remove('visible');
      
      // Build the device URL for the CLI command (official FF1 CLI format)
      const cleanCode = pieceCodeId.startsWith('$') ? pieceCodeId.slice(1) : pieceCodeId;
      const deviceUrl = `https://device.kidlisp.com/${cleanCode}`;
      currentFF1Command = `ff1 play "${deviceUrl}"`;
      
      // Update button text to show the actual command
      const cmdSpan = copyBtn.querySelector('.ff1-cmd');
      if (cmdSpan) {
        cmdSpan.innerHTML = formatFF1Command(currentFF1Command);
        cmdSpan.title = currentFF1Command;
      }
      
      console.log('üì∫ FF1 copy button setup with command:', currentFF1Command);
    }
    
    // Setup the FF1 CLI copy button for slideshow/playlist mode
    // Shows the slideshow URL instead of individual piece URLs
    // Also shows playlist title/position inside the FF1 module
    function setupFF1CopyButtonForPlaylist() {
      initFF1Button();
      
      const copyBtn = document.getElementById('piece-ff1-copy');
      const playlistHeader = document.getElementById('ff1-playlist-header');
      if (!copyBtn) return;
      
      // Show the playlist header inside the FF1 module
      if (playlistHeader) {
        playlistHeader.classList.add('visible');
      }
      
      // Build the playlist URL for the CLI command (official FF1 CLI format)
      // Use the short path if we're in a known playlist, otherwise use full URL
      let slideshowUrl;
      if (slideshowShortcut) {
        slideshowUrl = `https://device.kidlisp.com/playlist/${slideshowShortcut}`;
      } else {
        // Fall back to full playlist_url encoded
        slideshowUrl = `https://device.kidlisp.com/?playlist_url=${encodeURIComponent(playlistUrl)}`;
      }
      const cliCmd = `ff1 play "${slideshowUrl}"`;
      currentFF1Command = cliCmd;
      
      // Update button text to show the actual command
      const cmdSpan = copyBtn.querySelector('.ff1-cmd');
      if (cmdSpan) {
        cmdSpan.innerHTML = formatFF1Command(cliCmd);
        cmdSpan.title = cliCmd;
      }
      
      console.log('üì∫ FF1 copy button setup for playlist with command:', cliCmd);
    }
    
    // KidLisp syntax highlighter (matches kidlisp.com/give.aesthetic.computer)
    function highlightKidlisp(code) {
      if (!code) return '';
      // Escape HTML first
      let html = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // CSS color map
      const cssColors = {
        aliceblue: [240, 248, 255], aqua: [0, 255, 255], aquamarine: [127, 255, 212],
        azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0],
        blue: [0, 0, 255], brown: [165, 42, 42], chartreuse: [127, 255, 0],
        coral: [255, 127, 80], crimson: [220, 20, 60], cyan: [0, 255, 255],
        darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgreen: [0, 100, 0],
        darkgray: [169, 169, 169], darkgrey: [169, 169, 169], darkmagenta: [139, 0, 139],
        darkorange: [255, 140, 0], darkred: [139, 0, 0], darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255],
        gold: [255, 215, 0], gray: [128, 128, 128], grey: [128, 128, 128],
        green: [0, 128, 0], greenyellow: [173, 255, 47], hotpink: [255, 105, 180],
        indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140],
        lavender: [230, 230, 250], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255],
        lightgray: [211, 211, 211], lightgrey: [211, 211, 211], lightgreen: [144, 238, 144],
        lightpink: [255, 182, 193], lightskyblue: [135, 206, 250], lightyellow: [255, 255, 224],
        lime: [0, 255, 0], limegreen: [50, 205, 50], magenta: [255, 0, 255],
        maroon: [128, 0, 0], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250], mistyrose: [255, 228, 225], navy: [0, 0, 128],
        olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0],
        orangered: [255, 69, 0], orchid: [218, 112, 214], palegreen: [152, 251, 152],
        pink: [255, 192, 203], plum: [221, 160, 221], purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153], red: [255, 0, 0], royalblue: [65, 105, 225],
        salmon: [250, 128, 114], seagreen: [46, 139, 87], sienna: [160, 82, 45],
        silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205],
        slategray: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127],
        steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128],
        thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208],
        violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255],
        yellow: [255, 255, 0], yellowgreen: [154, 205, 50]
      };
      
      // Rainbow text helper
      function rainbowText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-rainbow hl-rainbow-${i % 7}">${char}</span>`
        ).join('');
      }
      
      // Zebra text helper
      function zebraText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-zebra hl-zebra-${i % 2}">${char}</span>`
        ).join('');
      }
      
      // Fade text helper
      function fadeText(fadeStr) {
        const parts = fadeStr.split(':');
        if (parts.length < 2) return `<span class="hl-fade">${fadeStr}</span>`;
        const colors = parts[1].split('-');
        const direction = parts[2] || '';
        
        let result = '<span class="hl-fade" style="color: #ffb86c;">fade</span><span class="hl-fade-colon">:</span>';
        colors.forEach((c, i) => {
          const rgb = cssColors[c.toLowerCase()];
          if (rgb) {
            result += `<span class="hl-color" style="color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})">${c}</span>`;
          } else if (c === 'rainbow') {
            result += rainbowText(c);
          } else if (c === 'zebra') {
            result += zebraText(c);
          } else {
            result += `<span class="hl-fade">${c}</span>`;
          }
          if (i < colors.length - 1) result += '<span class="hl-fade-sep">-</span>';
        });
        if (direction) {
          result += `<span class="hl-fade-colon">:</span><span class="hl-fade-dir">${direction}</span>`;
        }
        return result;
      }
      
      // Code reference helper ($code)
      function codeRefText(codeRef) {
        const dollar = codeRef[0];
        const id = codeRef.slice(1);
        return `<span class="hl-code-ref">${dollar}</span><span class="hl-code-id">${id}</span>`;
      }
      
      // Paint reference helper (#painting)
      function paintRefText(paintRef) {
        const hash = paintRef[0];
        const id = paintRef.slice(1);
        return `<span class="hl-paint-ref">${hash}</span><span class="hl-paint-id">${id}</span>`;
      }
      
      // Token placeholders
      const tokens = [];
      function token(match, cls, style) {
        const idx = tokens.length;
        const styleAttr = style ? ` style="${style}"` : '';
        tokens.push(`<span class="${cls}"${styleAttr}>${match}</span>`);
        return `\x01T${idx}T\x01`;
      }
      
      function tokenRaw(html) {
        const idx = tokens.length;
        tokens.push(html);
        return `\x01T${idx}T\x01`;
      }
      
      // Apply syntax highlighting (order matters)
      
      // $code references
      html = html.replace(/(\$[0-9A-Za-z]+)/g, m => tokenRaw(codeRefText(m)));
      
      // #painting references
      html = html.replace(/(#[0-9A-Fa-f]{1,8})\b/g, m => tokenRaw(paintRefText(m)));
      
      // Fade patterns
      html = html.replace(/\b(fade:[a-z0-9-]+(?::[a-z]+)?)\b/gi, m => tokenRaw(fadeText(m)));
      
      // Rainbow keyword
      html = html.replace(/\b(rainbow)\b/g, m => tokenRaw(rainbowText(m)));
      
      // Zebra keyword
      html = html.replace(/\b(zebra)\b/g, m => tokenRaw(zebraText(m)));
      
      // Comments
      html = html.replace(/(^|\n)(;[^\n]*)/g, (m, pre, comment) => pre + token(comment, 'hl-comment'));
      
      // Timing patterns
      html = html.replace(/(^|[\s(])(\d*\.?\d+)([sf](\.{1,3}|!?))/g, (m, pre, num, suffix) => {
        const full = num + suffix;
        const unit = suffix[0];
        const duration = unit === 's' ? parseFloat(num) : parseFloat(num) / 60;
        const idx = tokens.length;
        tokens.push(`<span class="hl-timing hl-timing-active" data-duration="${duration}">${full}</span>`);
        return pre + `\x01T${idx}T\x01`;
      });
      
      // Strings
      html = html.replace(/("[^"]*")/g, m => token(m, 'hl-string'));
      
      // Numbers
      html = html.replace(/\b(\d+\.?\d*)\b/g, m => token(m, 'hl-number'));
      
      // Keywords
      const keywords = ['def', 'fn', 'if', 'cond', 'let', 'loop', 'repeat', 'later', 'tap', 'drag', 'lift', 'key', 'draw', 'frame', 'now', 'once'];
      keywords.forEach(kw => {
        html = html.replace(new RegExp(`\\b(${kw})\\b`, 'g'), m => token(m, 'hl-keyword'));
      });
      
      // API calls
      const apiCalls = ['wipe', 'ink', 'line', 'box', 'circle', 'text', 'pan', 'zoom', 'blur', 'noise', 'width', 'height', 'wiggle', 'grid', 'plot', 'stamp', 'scroll', 'contrast', 'fps'];
      apiCalls.forEach(api => {
        html = html.replace(new RegExp(`\\b(${api})\\b`, 'g'), m => token(m, 'hl-api'));
      });
      
      // Colors
      const colorNames = Object.keys(cssColors).filter(c => c !== 'rainbow' && c !== 'zebra');
      colorNames.forEach(colorName => {
        const rgb = cssColors[colorName];
        const colorStyle = `color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        html = html.replace(new RegExp(`\\b(${colorName})\\b`, 'gi'), m => token(m, 'hl-color', colorStyle));
      });
      
      // Parens
      html = html.replace(/([()])/g, m => token(m, 'hl-paren'));
      
      // Replace tokens back
      html = html.replace(/\x01T(\d+)T\x01/g, (_, idx) => tokens[parseInt(idx)]);
      return html;
    }
    
    // Progress bar elements (must be declared before init() calls startProgressBar)
    const progressBar = document.getElementById('progress-bar');
    const progressFill = document.getElementById('progress-fill');
    let progressStartTime = null;
    let currentProgressPercent = 0;
    
    function startProgressBar() {
      console.log('üì∫ startProgressBar called, densityParam:', densityParam);
      // Set height based on density (1.5x for medium thickness, min 2px)
      const barHeight = Math.max(2, Math.round(1.5 * densityParam));
      console.log('üì∫ Progress bar height:', barHeight);
      progressBar.style.height = `${barHeight}px`;
      progressBar.classList.add('visible');
      progressBar.classList.add('fading-in');
      console.log('üì∫ Progress bar visible class added');
      progressStartTime = Date.now();
      updateProgressBar();
      setTimeout(() => progressBar.classList.remove('fading-in'), 2000);
    }
    
    // Track if piece has changed (for auto-reload logic)
    let pieceHasChanged = false;
    let progressBarStarted = false;
    
    window.addEventListener('message', (e) => {
      // Listen for boot-log ready message to start progress bar
      if (e.data?.type === 'boot-log') {
        const msg = e.data.message;
        // Start progress bar when piece is fully ready (after black screen / loading)
        // "ready: ..." is the final boot message indicating piece is running
        if (msg?.startsWith?.('ready:') && !progressBarStarted) {
          progressBarStarted = true;
          console.log('üì∫ Piece ready, starting progress bar now');
          
          // Check if we're in slideshow mode with a pending duration
          if (window.pendingSlideshowDuration) {
            startSlideshowProgressBar(window.pendingSlideshowDuration);
            window.pendingSlideshowDuration = null;
          } else if (!slideshowMode) {
            // Single piece mode
            startProgressBar();
          }
        }
        pieceHasChanged = true;
      }
      // Also mark as changed on other activity signals
      if (e.data?.type === 'ready' || e.data?.type === 'ac:fps-report') {
        pieceHasChanged = true;
      }
    });
    
    function updateProgressBar() {
      if (!progressStartTime) return;
      
      const elapsed = (Date.now() - progressStartTime) / 1000;
      const progress = Math.min(100, (elapsed / playlistDuration) * 100);
      currentProgressPercent = progress;
      progressFill.style.width = `${progress}%`;
      
      // Slide overlay elements based on progress:
      // First 1/6 (0-16.7%): show elements
      // Middle 4/6 (16.7%-83.3%): slide off
      // Last 1/6 (83.3%-100%): bring back
      const overlay = document.getElementById('source-overlay');
      if (overlay) {
        const shouldSlideOut = progress > 16.67 && progress < 83.33;
        if (shouldSlideOut && !overlay.classList.contains('slid-out')) {
          overlay.classList.add('slid-out');
        } else if (!shouldSlideOut && overlay.classList.contains('slid-out')) {
          overlay.classList.remove('slid-out');
        }
      }
      
      // Hide progress bar during middle section (same timing as slide out)
      const shouldHideBar = progress > 16.67 && progress < 83.33;
      if (shouldHideBar && !progressBar.classList.contains('hidden-mid')) {
        progressBar.classList.add('hidden-mid');
      } else if (!shouldHideBar && progressBar.classList.contains('hidden-mid')) {
        progressBar.classList.remove('hidden-mid');
      }
      
      // Blink red towards the end (last 10%)
      const shouldBlink = progress > 90;
      if (shouldBlink && !progressFill.classList.contains('ending')) {
        progressFill.classList.add('ending');
      } else if (!shouldBlink && progressFill.classList.contains('ending')) {
        progressFill.classList.remove('ending');
      }

      updateFF1Overlap();
      
      if (progress < 100) {
        requestAnimationFrame(updateProgressBar);
      } else {
        // Progress bar complete - just refresh the page
        console.log('üì∫ Progress bar complete - refreshing page');
        window.location.reload();
      }
    }
    
    // Reload the current piece (soft reload - just iframe)
    function reloadPiece() {
      console.log('üì∫ Reloading piece...');
      pieceHasChanged = false;
      progressStartTime = Date.now();
      progressFill.style.width = '0%';
      iframe.src = iframe.src.replace(/&t=\d+/, '') + '&t=' + Date.now();
      requestAnimationFrame(updateProgressBar);
    }
    
    // Tap-to-toggle UI: tap empty space to hide/show overlay elements
    (function setupTapToggle() {
      const overlay = document.getElementById('source-overlay');
      if (!overlay) return;

      const isInteractiveTarget = (target) => {
        return !!target?.closest?.(
          'a, button, #qr-wrap, #piece-info, #ff1-module, #piece-ff1-copy, #progress-bar, #fps-meter'
        );
      };

      function applyManualHidden() {
        overlay.classList.add('tap-hidden');
        overlay.classList.remove('hover-reveal');
        progressBar.classList.add('force-hidden');
        progressBar.classList.remove('force-visible');
        updateFF1Overlap();
      }

      function applyManualVisible() {
        overlay.classList.remove('tap-hidden');
        overlay.classList.add('hover-reveal');
        progressBar.classList.add('force-visible');
        progressBar.classList.remove('force-hidden');
        progressBar.classList.remove('hidden-mid');
        updateFF1Overlap();
      }

      document.body.addEventListener('pointerdown', (e) => {
        if (isInteractiveTarget(e.target)) return;
        if (overlay.classList.contains('scrambling')) return;

        if (overlay.classList.contains('tap-hidden')) {
          applyManualVisible();
        } else {
          applyManualHidden();
        }
      });
    })();
    
    // Start the app
    init();
  </script>
</body>
</html>