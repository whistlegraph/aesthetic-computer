<!DOCTYPE html>
<!-- KidLisp.com Device Mode - Optimized for FF1 and display devices -->
<!-- URL format: device.kidlisp.com/codeId -->
<!-- Loads KidLisp $code URLs with default density=1 for 4K displays -->
<html>
<head>
  <meta charset="utf-8">
  <title>KidLisp.com Â· Device</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <link rel="icon" type="image/png"
    href="https://pals-aesthetic-computer.sfo3.cdn.digitaloceanspaces.com/painting-2023.7.29.20.39.png" />
  <!-- Google Fonts - JetBrains Mono -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <!-- QR Code library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'JetBrains Mono', monospace;
    }
    
    #display-iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #000;
    }
    
    /* Boot screen - now handled by iframe's boot animation */
    #boot-screen {
      display: none;
    }

    /* KidLisp source overlay - shows during loading */
    #source-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 15;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    
    /* Source code always visible with piece info */
    #source-overlay {
      /* Always visible - no hidden state */
    }
    
    /* Source code display - top left */
    #source-code {
      position: absolute;
      top: calc(var(--density, 8) * 8px);
      left: calc(var(--density, 8) * 8px);
      right: calc(var(--density, 8) * 8px);
      bottom: calc(var(--density, 8) * 40px);
      font-family: 'JetBrains Mono', monospace;
      font-size: calc(var(--density, 8) * 5px);
      line-height: 1.5;
      color: #fff;
      overflow: hidden;
      /* Sharp shadow like kidlisp.com monaco editor */
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      white-space: pre-wrap;
      word-break: break-word;
      -webkit-mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
      mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
    }
    
    #source-code-inner {
      /* For scrolling long code */
    }
    
    #source-code-inner.scrolling {
      animation: codeScroll var(--scroll-duration, 12s) ease-in-out infinite;
      animation-delay: 2s;
    }
    
    @keyframes codeScroll {
      0%, 15% { transform: translateY(0); }
      85%, 100% { transform: translateY(var(--scroll-distance, 0)); }
    }
    
    /* QR code and label - bottom right (like give.aesthetic.computer) */
    #qr-wrap {
      position: absolute;
      bottom: calc(var(--density, 8) * 8px);
      right: calc(var(--density, 8) * 8px);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      z-index: 16;
    }
    
    #code-label {
      font-family: 'JetBrains Mono', monospace;
      font-size: calc(var(--density, 8) * 5px);
      font-weight: 700;
      color: #fff;
      background: #000;
      padding: calc(var(--density, 8) * 1px) calc(var(--density, 8) * 2px);
      margin-bottom: calc(var(--density, 8) * 1px);
      line-height: 1.2;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
    }
    
    #code-label .code-dollar {
      color: #32cd32; /* limegreen */
    }
    
    #code-label .code-name {
      color: #90EE90; /* lightgreen */
    }
    
    #qr-container {
      background: #fff;
      padding: calc(var(--density, 8) * 0.5px);
      line-height: 0;
      border: calc(var(--density, 8) * 0.5px) solid #000;
    }
    
    #qr-container svg {
      display: block;
      width: calc(var(--density, 8) * 240px);
      height: calc(var(--density, 8) * 240px);
      image-rendering: pixelated;
    }
    
    /* Handle and hits info - bottom left (device replaces disk.mjs overlay) */
    #piece-info {
      position: absolute;
      bottom: calc(var(--density, 8) * 8px);
      left: calc(var(--density, 8) * 8px);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-family: 'JetBrains Mono', monospace;
      font-size: calc(var(--density, 8) * 5px);
      line-height: 1.4;
      z-index: 16;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
    }
    
    #piece-handle {
      color: rgb(255, 107, 157);
      background: rgba(0,0,0,0.7);
      padding: calc(var(--density, 8) * 1px) calc(var(--density, 8) * 2px);
    }
    
    #piece-hits {
      color: rgb(255, 217, 61);
      background: rgba(0,0,0,0.7);
      padding: calc(var(--density, 8) * 1px) calc(var(--density, 8) * 2px);
    }
    
    #piece-when {
      color: rgb(180, 180, 180);
      background: rgba(0,0,0,0.7);
      padding: calc(var(--density, 8) * 0.5px) calc(var(--density, 8) * 2px);
      font-size: calc(var(--density, 8) * 3px);
    }
    
    /* KidLisp syntax highlighting */
    .hl-comment { color: #6272a4; font-style: italic; }
    .hl-string { color: orange; }
    .hl-number { color: lime; }
    .hl-keyword { color: pink; }
    .hl-api { color: cyan; }
    .hl-color { /* inline style sets actual color */ }
    .hl-timing { color: #ffb86c; font-weight: bold; }
    .hl-paren { color: #888; }
    .hl-code-ref { color: limegreen; font-weight: bold; }
    .hl-code-id { color: lime; }
    .hl-paint-ref { color: magenta; font-weight: bold; }
    .hl-paint-id { color: orange; }
    .hl-fade { font-weight: bold; }
    .hl-fade-sep { color: mediumseagreen; }
    .hl-fade-dir { color: cyan; }
    .hl-fade-colon { color: lime; }
    
    /* Rainbow animation */
    @keyframes rainbowCycle {
      0% { color: red; }
      14% { color: orange; }
      28% { color: yellow; }
      42% { color: lime; }
      57% { color: cyan; }
      71% { color: blue; }
      85% { color: magenta; }
      100% { color: red; }
    }
    
    .hl-rainbow {
      animation: rainbowCycle 2s linear infinite;
      font-weight: bold;
    }
    
    .hl-rainbow-0 { animation-delay: 0s; }
    .hl-rainbow-1 { animation-delay: -0.28s; }
    .hl-rainbow-2 { animation-delay: -0.56s; }
    .hl-rainbow-3 { animation-delay: -0.84s; }
    .hl-rainbow-4 { animation-delay: -1.12s; }
    .hl-rainbow-5 { animation-delay: -1.40s; }
    .hl-rainbow-6 { animation-delay: -1.68s; }
    
    /* Zebra animation */
    @keyframes zebraCycle {
      0%, 49% { color: white; }
      50%, 100% { color: #333; }
    }
    
    .hl-zebra {
      animation: zebraCycle 1s steps(1) infinite;
      font-weight: bold;
    }
    
    .hl-zebra-0 { animation-delay: 0s; }
    .hl-zebra-1 { animation-delay: -0.5s; }
    
    /* Timing blink animation */
    @keyframes hl-timing-blink {
      0%, 90% { opacity: 1; }
      95% { opacity: 0.4; color: lime; }
      100% { opacity: 1; }
    }
    
    .hl-timing-active {
      animation: hl-timing-blink var(--timing-duration, 1s) ease-in-out infinite;
    }

    /* Error display */
    #error-screen {
      display: none;
      position: absolute;
      inset: 0;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #111;
      z-index: 20;
    }
    
    #error-screen.visible {
      display: flex;
    }
    
    .error-text {
      color: rgb(255, 100, 100);
      font-family: monospace;
      font-size: 14px;
      text-align: center;
      max-width: 80%;
    }

    /* YouTube-style progress bar for playlist mode */
    #progress-bar {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 16px; /* Default, overridden by JS based on density */
      background: #111; /* Solid dark background */
      z-index: 100;
    }

    #progress-bar.visible {
      display: block;
    }

    #progress-fill {
      height: 100%;
      width: 0%;
      /* Color set dynamically based on screen content */
      background: rgb(170, 150, 218); /* Fallback lavender */
      transition: width 0.25s linear, background-color 0.5s ease;
    }

    /* FPS meter - top right */
    #fps-meter {
      position: fixed;
      top: calc(var(--density, 8) * 4px);
      right: calc(var(--density, 8) * 4px);
      font-family: 'JetBrains Mono', monospace;
      font-size: calc(var(--density, 8) * 3px);
      color: lime;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      z-index: 99999;
      pointer-events: none;
      text-align: right;
    }

  </style>
</head>
<body>
  <!-- Boot animation now handled by iframe's acBootCanvas with device mode -->
  
  <!-- KidLisp source overlay with syntax highlighting and QR -->
  <div id="source-overlay">
    <div id="source-code"><div id="source-code-inner"></div></div>
    <div id="qr-wrap">
      <div id="code-label"></div>
      <div id="qr-container"></div>
    </div>
    <div id="piece-info">
      <div id="piece-handle"></div>
      <div id="piece-hits"></div>
      <div id="piece-when"></div>
    </div>
  </div>
  
  <div id="error-screen">
    <div class="error-text" id="error-text"></div>
  </div>
  
  <iframe id="display-iframe"></iframe>
  
  <!-- YouTube-style progress bar for playlist mode -->
  <div id="progress-bar">
    <div id="progress-fill"></div>
  </div>
  
  <!-- FPS meter for performance comparison -->
  <div id="fps-meter">FPS: --</div>
  
  <script>
    // FPS meter - calculated locally from iframe's frame timing
    (function() {
      const meter = document.getElementById('fps-meter');
      const iframe = document.getElementById('display-iframe');
      let frameCount = 0;
      let lastTime = performance.now();
      let currentFps = 0;
      
      // Listen for FPS reports from the iframe (if supported)
      window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'ac:fps-report') {
          currentFps = e.data.fps;
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
        }
      });
      
      // Fallback: calculate FPS from local animation frame
      function updateFps() {
        frameCount++;
        const now = performance.now();
        const elapsed = now - lastTime;
        
        if (elapsed >= 1000) {
          currentFps = Math.round(frameCount * 1000 / elapsed);
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
          frameCount = 0;
          lastTime = now;
        }
        
        requestAnimationFrame(updateFps);
      }
      
      // Start FPS counting after iframe loads
      iframe.addEventListener('load', () => {
        setTimeout(() => {
          updateFps();
          // Also request FPS from iframe in case it reports its own
          iframe.contentWindow?.postMessage({ type: 'ac:request-fps' }, '*');
        }, 500);
      });
    })();
  </script>
  
  <script>
    // Get density from URL params
    const urlParams = new URLSearchParams(window.location.search);
    const densityParam = parseInt(urlParams.get('density')) || 8;
    
    // Set CSS custom property for density-based sizing
    document.documentElement.style.setProperty('--density', densityParam);
    
    // Boot animation is now handled by the iframe's acBootCanvas with device mode
    // (black background, white/gray bars, density scaling)
    
    // Default display parameters for FF1 and 4K displays
    const DEVICE_DEFAULTS = {
      density: 8,     // Higher density = larger pixels (8x8 screen pixels per AC pixel)
      device: true,   // Device mode - auto-enables audio, combines tv+nogap+noauth
      tv: true,       // Non-interactive TV mode
      nogap: true,    // Borderless / no gap
      nolabel: true,  // Hide labels
      noauth: true,   // No auth prompts
      popout: true,   // Popout mode
      perf: false     // Performance/FPS HUD (opt-in)
    };
    
    // Parse URL and query params
    const params = new URLSearchParams(window.location.search);
    const pathname = window.location.pathname;
    const hostname = window.location.hostname;
    
    // UI elements
    const iframe = document.getElementById('display-iframe');
    const errorScreen = document.getElementById('error-screen');
    const errorText = document.getElementById('error-text');
    
    // Boot logging (console only, no DOM log)
    function addLog(msg, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${msg}`);
    }
    
    // Determine display mode and URL
    const dev = hostname === 'localhost' || hostname === 'local.aesthetic.computer';
    const aestheticUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
    
    const logDevice = (...args) => {
      console.log('ðŸ“º DEVICE:', ...args);
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '));
    };
    
    // Parse codeId from path:
    // device.kidlisp.com/codeId
    // localhost:8888/kidlisp.com/device/codeId
    // localhost:8888/device.kidlisp.com/codeId
    let codeId = null;
    const pathParts = pathname.split('/').filter(p => p);
    
    if (hostname === 'device.kidlisp.com') {
      // Production: device.kidlisp.com/codeId
      codeId = pathParts[0] || null;
    } else if (pathname.startsWith('/device.kidlisp.com/')) {
      // Local dev: localhost:8888/device.kidlisp.com/codeId
      codeId = pathParts[1] || null;
    } else if (pathParts[0] === 'kidlisp.com' && pathParts[1] === 'device') {
      // Local dev: localhost:8888/kidlisp.com/device/codeId
      codeId = pathParts[2] || null;
    }
    
    // Ensure $ prefix on codeId (device.kidlisp.com/roz â†’ $roz)
    if (codeId && !codeId.startsWith('$')) {
      codeId = '$' + codeId;
    }
    
    // Allow param overrides of defaults
    const density = params.get('density') ?? DEVICE_DEFAULTS.density;
    const device = params.get('device') ?? DEVICE_DEFAULTS.device;
    const tv = params.get('tv') ?? DEVICE_DEFAULTS.tv;
    const nogap = params.get('nogap') ?? DEVICE_DEFAULTS.nogap;
    const nolabel = params.get('nolabel') ?? DEVICE_DEFAULTS.nolabel;
    const noauth = params.get('noauth') ?? DEVICE_DEFAULTS.noauth;
    const popout = params.get('popout') ?? DEVICE_DEFAULTS.popout;
    const perf = params.get('perf') ?? DEVICE_DEFAULTS.perf;
    
    // Playlist mode params (for DP-1 playlist progress bar)
    const isPlaylist = params.get('playlist') === 'true';
    const playlistDuration = parseInt(params.get('duration')) || 60; // seconds
    
    // Build query string for display params
    function buildDisplayParams() {
      const p = new URLSearchParams();
      if (density !== null) p.set('density', density);
      if (device) p.set('device', 'true');
      if (tv) p.set('tv', 'true');
      if (nogap) p.set('nogap', 'true');
      if (nolabel) p.set('nolabel', 'true');
      if (noauth) p.set('noauth', 'true');
      if (popout) p.set('popout', 'true');
      if (perf) p.set('perf', 'true');
      p.set('t', Date.now()); // Cache bust
      return p.toString();
    }
    
    function showError(msg) {
      errorText.textContent = msg;
      errorScreen.classList.add('visible');
    }
    
    // Initialize display
    function init() {
      logDevice('init', { codeId, density, dev, hostname, pathname });
      
      if (!codeId) {
        showError('Usage: device.kidlisp.com/{codeId}');
        return;
      }
      
      // Set page title (codeId already includes $ prefix)
      document.title = `KidLisp.com Â· ${codeId}`;
      
      // Build the codeId URL with display params
      // codeId (e.g. "$zo5") loads the stored kidlisp code from MongoDB
      iframe.src = `${aestheticUrl}/${codeId}?${buildDisplayParams()}`;
      
      logDevice('iframe src', { src: iframe.src });
      
      // Handle iframe load
      iframe.addEventListener('load', () => {
        logDevice('iframe loaded');
        // Source overlay stays visible always - shows code and QR
      });
      
      // Listen for iframe errors
      iframe.addEventListener('error', (e) => {
        addLog(`iframe error: ${e.message || 'unknown'}`, 'error');
      });
      
      // Always start playlist progress bar (visible indicator of time remaining)
      console.log('ðŸ“º Playlist mode:', isPlaylist, 'duration:', playlistDuration);
      console.log('ðŸ“º Starting progress bar...');
      startProgressBar();
      
      // Fetch and display KidLisp source code with syntax highlighting
      fetchAndDisplaySource(codeId);
    }
    
    // Fetch KidLisp source from API
    async function fetchAndDisplaySource(codeId) {
      console.log('ðŸ“º fetchAndDisplaySource called with:', codeId);
      // Strip $ prefix if present for API call
      const pieceCode = codeId.startsWith('$') ? codeId.slice(1) : codeId;
      const displayCode = codeId.startsWith('$') ? codeId : '$' + codeId;
      
      // Always generate QR code and label first (even before source loads)
      generateQRAndLabel(displayCode);
      
      try {
        // Fetch source from store-kidlisp API
        const apiUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
        const url = `${apiUrl}/api/store-kidlisp?code=${pieceCode}`;
        console.log('ðŸ“º Fetching source from:', url);
        const response = await fetch(url, {
          credentials: 'omit'
        });
        console.log('ðŸ“º Source fetch response:', response.status, response.statusText);
        
        if (response.ok) {
          const data = await response.json();
          console.log('ðŸ“º Source data:', data);
          if (data.source) {
            displaySourceCode(data.source);
          } else {
            console.log('ðŸ“º No source in response');
          }
          // Display handle and hits
          displayPieceInfo(data);
        } else {
          console.log('ðŸ“º Source fetch failed:', response.status);
        }
      } catch (e) {
        console.log('ðŸ“º Could not fetch source:', e);
      }
    }
    
    // Display syntax-highlighted source code
    function displaySourceCode(source) {
      const codeEl = document.getElementById('source-code');
      const inner = document.getElementById('source-code-inner');
      if (!inner || !source) return;
      
      inner.innerHTML = highlightKidlisp(source);
      
      // Setup scrolling for long code
      requestAnimationFrame(() => {
        const containerHeight = codeEl.clientHeight;
        const contentHeight = inner.scrollHeight;
        
        if (contentHeight > containerHeight + 20) {
          const scrollDistance = contentHeight - containerHeight + 20;
          inner.classList.add('scrolling');
          inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
          const scrollDuration = 12 + (scrollDistance / 150);
          inner.style.setProperty('--scroll-duration', `${scrollDuration}s`);
        }
      });
      
      // Apply timing durations to timing elements
      inner.querySelectorAll('.hl-timing-active[data-duration]').forEach(el => {
        const duration = parseFloat(el.dataset.duration) || 1;
        const clampedDuration = Math.max(0.1, Math.min(duration, 10));
        el.style.setProperty('--timing-duration', clampedDuration + 's');
      });
    }
    
    // Generate QR code pointing to kidlisp.com/$piece
    function generateQRAndLabel(displayCode) {
      console.log('ðŸ“º generateQRAndLabel called with:', displayCode);
      const labelEl = document.getElementById('code-label');
      const qrContainer = document.getElementById('qr-container');
      
      // Build label with colored $ and code
      if (labelEl) {
        const dollar = displayCode[0] === '$' ? '$' : '';
        const code = displayCode.startsWith('$') ? displayCode.slice(1) : displayCode;
        labelEl.innerHTML = `<span class="code-dollar">${dollar}</span><span class="code-name">${code}</span>`;
        console.log('ðŸ“º Label set:', dollar + code);
      }
      
      // Generate QR code pointing to kidlisp.com (NOT aesthetic.computer)
      if (qrContainer && typeof qrcode !== 'undefined') {
        try {
          const qrUrl = `https://kidlisp.com/${displayCode}`;
          console.log('ðŸ“º Generating QR for:', qrUrl);
          const qrGen = qrcode(0, 'L');
          qrGen.addData(qrUrl);
          qrGen.make();
          const svg = qrGen.createSvgTag(2, 0);
          qrContainer.innerHTML = svg;
          const svgEl = qrContainer.querySelector('svg');
          if (svgEl) {
            // Size is set by CSS using --density variable
            svgEl.style.display = 'block';
            svgEl.style.width = '100%';
            svgEl.style.height = '100%';
            console.log('ðŸ“º QR SVG created');
          }
        } catch (e) {
          console.error('ðŸ“º QR generation error:', e);
        }
      } else {
        console.log('ðŸ“º QR container not found or qrcode lib not loaded');
      }
    }
    
    // Display handle and hits info
    function displayPieceInfo(data) {
      const handleEl = document.getElementById('piece-handle');
      const hitsEl = document.getElementById('piece-hits');
      const whenEl = document.getElementById('piece-when');
      
      if (handleEl) {
        if (data.handle) {
          handleEl.textContent = data.handle;
          console.log('ðŸ“º Handle:', data.handle);
        } else {
          handleEl.textContent = 'anonymous';
          handleEl.style.color = 'rgb(150, 150, 150)';
          console.log('ðŸ“º Handle: anonymous');
        }
      }
      
      if (hitsEl && typeof data.hits === 'number') {
        hitsEl.textContent = data.hits.toLocaleString() + ' hits';
        console.log('ðŸ“º Hits:', data.hits);
      }
      
      if (whenEl && data.when) {
        const date = new Date(data.when);
        const formatted = date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
        whenEl.textContent = formatted;
        console.log('ðŸ“º When:', formatted);
      }
    }
    
    // KidLisp syntax highlighter (matches kidlisp.com/give.aesthetic.computer)
    function highlightKidlisp(code) {
      if (!code) return '';
      // Escape HTML first
      let html = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // CSS color map
      const cssColors = {
        aliceblue: [240, 248, 255], aqua: [0, 255, 255], aquamarine: [127, 255, 212],
        azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0],
        blue: [0, 0, 255], brown: [165, 42, 42], chartreuse: [127, 255, 0],
        coral: [255, 127, 80], crimson: [220, 20, 60], cyan: [0, 255, 255],
        darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgreen: [0, 100, 0],
        darkgray: [169, 169, 169], darkgrey: [169, 169, 169], darkmagenta: [139, 0, 139],
        darkorange: [255, 140, 0], darkred: [139, 0, 0], darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255],
        gold: [255, 215, 0], gray: [128, 128, 128], grey: [128, 128, 128],
        green: [0, 128, 0], greenyellow: [173, 255, 47], hotpink: [255, 105, 180],
        indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140],
        lavender: [230, 230, 250], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255],
        lightgray: [211, 211, 211], lightgrey: [211, 211, 211], lightgreen: [144, 238, 144],
        lightpink: [255, 182, 193], lightskyblue: [135, 206, 250], lightyellow: [255, 255, 224],
        lime: [0, 255, 0], limegreen: [50, 205, 50], magenta: [255, 0, 255],
        maroon: [128, 0, 0], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250], mistyrose: [255, 228, 225], navy: [0, 0, 128],
        olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0],
        orangered: [255, 69, 0], orchid: [218, 112, 214], palegreen: [152, 251, 152],
        pink: [255, 192, 203], plum: [221, 160, 221], purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153], red: [255, 0, 0], royalblue: [65, 105, 225],
        salmon: [250, 128, 114], seagreen: [46, 139, 87], sienna: [160, 82, 45],
        silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205],
        slategray: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127],
        steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128],
        thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208],
        violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255],
        yellow: [255, 255, 0], yellowgreen: [154, 205, 50]
      };
      
      // Rainbow text helper
      function rainbowText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-rainbow hl-rainbow-${i % 7}">${char}</span>`
        ).join('');
      }
      
      // Zebra text helper
      function zebraText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-zebra hl-zebra-${i % 2}">${char}</span>`
        ).join('');
      }
      
      // Fade text helper
      function fadeText(fadeStr) {
        const parts = fadeStr.split(':');
        if (parts.length < 2) return `<span class="hl-fade">${fadeStr}</span>`;
        const colors = parts[1].split('-');
        const direction = parts[2] || '';
        
        let result = '<span class="hl-fade" style="color: #ffb86c;">fade</span><span class="hl-fade-colon">:</span>';
        colors.forEach((c, i) => {
          const rgb = cssColors[c.toLowerCase()];
          if (rgb) {
            result += `<span class="hl-color" style="color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})">${c}</span>`;
          } else if (c === 'rainbow') {
            result += rainbowText(c);
          } else if (c === 'zebra') {
            result += zebraText(c);
          } else {
            result += `<span class="hl-fade">${c}</span>`;
          }
          if (i < colors.length - 1) result += '<span class="hl-fade-sep">-</span>';
        });
        if (direction) {
          result += `<span class="hl-fade-colon">:</span><span class="hl-fade-dir">${direction}</span>`;
        }
        return result;
      }
      
      // Code reference helper ($code)
      function codeRefText(codeRef) {
        const dollar = codeRef[0];
        const id = codeRef.slice(1);
        return `<span class="hl-code-ref">${dollar}</span><span class="hl-code-id">${id}</span>`;
      }
      
      // Paint reference helper (#painting)
      function paintRefText(paintRef) {
        const hash = paintRef[0];
        const id = paintRef.slice(1);
        return `<span class="hl-paint-ref">${hash}</span><span class="hl-paint-id">${id}</span>`;
      }
      
      // Token placeholders
      const tokens = [];
      function token(match, cls, style) {
        const idx = tokens.length;
        const styleAttr = style ? ` style="${style}"` : '';
        tokens.push(`<span class="${cls}"${styleAttr}>${match}</span>`);
        return `\x01T${idx}T\x01`;
      }
      
      function tokenRaw(html) {
        const idx = tokens.length;
        tokens.push(html);
        return `\x01T${idx}T\x01`;
      }
      
      // Apply syntax highlighting (order matters)
      
      // $code references
      html = html.replace(/(\$[0-9A-Za-z]+)/g, m => tokenRaw(codeRefText(m)));
      
      // #painting references
      html = html.replace(/(#[0-9A-Fa-f]{1,8})\b/g, m => tokenRaw(paintRefText(m)));
      
      // Fade patterns
      html = html.replace(/\b(fade:[a-z0-9-]+(?::[a-z]+)?)\b/gi, m => tokenRaw(fadeText(m)));
      
      // Rainbow keyword
      html = html.replace(/\b(rainbow)\b/g, m => tokenRaw(rainbowText(m)));
      
      // Zebra keyword
      html = html.replace(/\b(zebra)\b/g, m => tokenRaw(zebraText(m)));
      
      // Comments
      html = html.replace(/(^|\n)(;[^\n]*)/g, (m, pre, comment) => pre + token(comment, 'hl-comment'));
      
      // Timing patterns
      html = html.replace(/(^|[\s(])(\d*\.?\d+)([sf](\.{1,3}|!?))/g, (m, pre, num, suffix) => {
        const full = num + suffix;
        const unit = suffix[0];
        const duration = unit === 's' ? parseFloat(num) : parseFloat(num) / 60;
        const idx = tokens.length;
        tokens.push(`<span class="hl-timing hl-timing-active" data-duration="${duration}">${full}</span>`);
        return pre + `\x01T${idx}T\x01`;
      });
      
      // Strings
      html = html.replace(/("[^"]*")/g, m => token(m, 'hl-string'));
      
      // Numbers
      html = html.replace(/\b(\d+\.?\d*)\b/g, m => token(m, 'hl-number'));
      
      // Keywords
      const keywords = ['def', 'fn', 'if', 'cond', 'let', 'loop', 'repeat', 'later', 'tap', 'drag', 'lift', 'key', 'draw', 'frame', 'now', 'once'];
      keywords.forEach(kw => {
        html = html.replace(new RegExp(`\\b(${kw})\\b`, 'g'), m => token(m, 'hl-keyword'));
      });
      
      // API calls
      const apiCalls = ['wipe', 'ink', 'line', 'box', 'circle', 'text', 'pan', 'zoom', 'blur', 'noise', 'width', 'height', 'wiggle', 'grid', 'plot', 'stamp', 'scroll', 'contrast', 'fps'];
      apiCalls.forEach(api => {
        html = html.replace(new RegExp(`\\b(${api})\\b`, 'g'), m => token(m, 'hl-api'));
      });
      
      // Colors
      const colorNames = Object.keys(cssColors).filter(c => c !== 'rainbow' && c !== 'zebra');
      colorNames.forEach(colorName => {
        const rgb = cssColors[colorName];
        const colorStyle = `color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        html = html.replace(new RegExp(`\\b(${colorName})\\b`, 'gi'), m => token(m, 'hl-color', colorStyle));
      });
      
      // Parens
      html = html.replace(/([()])/g, m => token(m, 'hl-paren'));
      
      // Replace tokens back
      html = html.replace(/\x01T(\d+)T\x01/g, (_, idx) => tokens[parseInt(idx)]);
      return html;
    }
    
    // Progress bar elements (must be declared before init() calls startProgressBar)
    const progressBar = document.getElementById('progress-bar');
    const progressFill = document.getElementById('progress-fill');
    let progressStartTime = null;
    
    function startProgressBar() {
      console.log('ðŸ“º startProgressBar called, densityParam:', densityParam);
      // Set height based on density (2 logical pixels)
      const barHeight = 2 * densityParam;
      console.log('ðŸ“º Progress bar height:', barHeight);
      progressBar.style.height = `${barHeight}px`;
      progressBar.classList.add('visible');
      console.log('ðŸ“º Progress bar visible class added');
      progressStartTime = Date.now();
      updateProgressBar();
      
      // Listen for color updates from the iframe
      window.addEventListener('message', (e) => {
        if (e.data?.type === 'ac:screen-color' && e.data.color) {
          progressFill.style.backgroundColor = e.data.color;
        }
      });
      
      // Request colors periodically from the iframe
      requestScreenColor();
    }
    
    function requestScreenColor() {
      if (!isPlaylist) return;
      try {
        iframe.contentWindow?.postMessage({ type: 'ac:get-screen-color' }, '*');
      } catch (e) {
        // Cross-origin, ignore
      }
      // Request every 2 seconds
      setTimeout(requestScreenColor, 2000);
    }
    
    function updateProgressBar() {
      if (!progressStartTime) return;
      
      const elapsed = (Date.now() - progressStartTime) / 1000;
      const progress = Math.min(100, (elapsed / playlistDuration) * 100);
      progressFill.style.width = `${progress}%`;
      
      if (progress < 100) {
        requestAnimationFrame(updateProgressBar);
      }
    }
    
    // Start the app
    init();
  </script>
</body>
</html>