<!DOCTYPE html>
<!-- KidLisp.com Device Mode - Optimized for FF1 and display devices -->
<!-- URL format: device.kidlisp.com/codeId -->
<!-- Loads KidLisp $code URLs with default density=1 for 4K displays -->
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>KidLisp.com ¬∑ Device</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <link rel="icon" type="image/png"
    href="https://pals-aesthetic-computer.sfo3.cdn.digitaloceanspaces.com/painting-2023.7.29.20.39.png" />
  <!-- Google Fonts - Noto Sans Mono (Monaco-like) and Comic Relief (kidlisp branding) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Relief:wght@400;700&family=Noto+Sans+Mono:wght@400;700&display=swap" rel="stylesheet">
  <!-- QR Code library -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <!-- üöÄ Eager source fetch - starts immediately before DOM loads -->
  <script>
    (function() {
      // Parse codeId from URL immediately
      const pathname = window.location.pathname;
      const hostname = window.location.hostname;
      const pathParts = pathname.split('/').filter(p => p);
      let codeId = null;
      
      if (hostname === 'device.kidlisp.com') {
        codeId = pathParts[0] || null;
      } else if (pathname.startsWith('/device.kidlisp.com/')) {
        codeId = pathParts[1] || null;
      } else if (pathParts[0] === 'kidlisp.com' && pathParts[1] === 'device') {
        codeId = pathParts[2] || null;
      }
      
      if (codeId) {
        const pieceCode = codeId.startsWith('$') ? codeId.slice(1) : codeId;
        const dev = hostname === 'localhost' || hostname === 'local.aesthetic.computer';
        const apiUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
        const url = `${apiUrl}/api/store-kidlisp?code=${pieceCode}`;
        
        // Start fetch immediately - store promise globally for later use
        window.__eagerSourceFetch = fetch(url, { credentials: 'omit' })
          .then(r => r.ok ? r.json() : null)
          .catch(() => null);
        console.log('üöÄ Eager source fetch started for:', pieceCode);
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
    }
    
    #display-iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #000;
    }
    
    /* Boot screen - now handled by iframe's boot animation */
    #boot-screen {
      display: none;
    }

    /* KidLisp source overlay - shows during loading */
    #source-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 15;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    
    /* Source code always visible with piece info */
    #source-overlay {
      /* Always visible - no hidden state */
    }
    
    /* Source code display - top left */
    #source-code {
      position: absolute;
      top: calc(var(--density, 8) * 4px);
      left: calc(var(--density, 8) * 4px);
      right: calc(var(--density, 8) * 4px);
      bottom: calc(var(--density, 8) * 24px);
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--density, 8) * 2.5px);
      line-height: 1.5;
      color: #fff;
      overflow: hidden;
      /* Sharp shadow like kidlisp.com monaco editor */
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      white-space: pre-wrap;
      word-break: break-word;
      -webkit-mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
      mask-image: linear-gradient(to bottom, black 0%, black 85%, transparent 100%);
    }
    
    #source-code-inner {
      /* For scrolling long code */
    }
    
    #source-code-inner.scrolling {
      animation: codeScroll var(--scroll-duration, 12s) ease-in-out infinite;
      animation-delay: 2s;
    }
    
    @keyframes codeScroll {
      0%, 15% { transform: translateY(0); }
      85%, 100% { transform: translateY(var(--scroll-distance, 0)); }
    }
    
    /* QR code and label - bottom right (like give.aesthetic.computer) */
    #qr-wrap {
      position: absolute;
      bottom: calc(var(--density, 8) * 4px);
      right: calc(var(--density, 8) * 4px);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      z-index: 16;
    }
    
    #code-label {
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--density, 8) * 2.5px);
      font-weight: 400;
      color: #fff;
      background: #000;
      padding: calc(var(--density, 8) * 0.25px) calc(var(--density, 8) * 0.5px);
      padding-bottom: calc(var(--density, 8) * 0.75px); /* Extra space below label */
      line-height: 1;
      text-transform: none; /* Keep original case */
    }
    
    #code-label .code-dollar {
      color: #fff;
    }
    
    #code-label .code-name {
      color: #fff;
    }
    
    #qr-container {
      background: #fff;
      padding: calc(var(--density, 8) * 0.25px);
      line-height: 0;
      width: calc(var(--density, 8) * 10px);
      height: calc(var(--density, 8) * 10px);
    }
    
    #qr-container svg {
      display: block;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
    }
    
    /* Handle and hits info - bottom left (device replaces disk.mjs overlay) */
    #piece-info {
      position: absolute;
      bottom: calc(var(--density, 8) * 4px);
      left: calc(var(--density, 8) * 4px);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--density, 8) * 2.5px);
      line-height: 1.4;
      z-index: 16;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
    }
    
    #piece-handle {
      color: rgb(255, 107, 157);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    #piece-hits {
      color: rgb(255, 217, 61);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    #piece-when {
      color: rgb(180, 180, 180);
      text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
    }
    
    /* FF1 CLI copy button in piece-info */
    .piece-ff1-copy {
      display: flex;
      align-items: center;
      gap: calc(var(--density, 8) * 0.5px);
      margin-top: calc(var(--density, 8) * 1px);
      padding: calc(var(--density, 8) * 0.4px) calc(var(--density, 8) * 0.8px);
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: calc(var(--density, 8) * 0.5px);
      color: rgba(255, 255, 255, 0.9);
      font-family: 'Noto Sans Mono', monospace;
      font-size: calc(var(--density, 8) * 1.5px);
      cursor: pointer;
      transition: all 0.15s ease;
      pointer-events: auto;
      text-shadow: none;
    }
    
    .piece-ff1-copy:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
    }
    
    .piece-ff1-copy:active {
      transform: scale(0.97);
    }
    
    .piece-ff1-copy.copied {
      background: rgba(0, 200, 100, 0.3);
      border-color: rgba(0, 200, 100, 0.6);
    }
    
    .piece-ff1-copy .ff1-icon {
      height: calc(var(--density, 8) * 1.5px);
      width: auto;
      filter: invert(1);
    }
    
    .piece-ff1-copy .ff1-cmd {
      color: rgba(255, 255, 255, 0.8);
      max-width: calc(var(--density, 8) * 30px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* KidLisp syntax highlighting */
    .hl-comment { color: #6272a4; font-style: italic; }
    .hl-string { color: orange; }
    .hl-number { color: lime; }
    .hl-keyword { color: pink; }
    .hl-api { color: cyan; }
    .hl-color { /* inline style sets actual color */ }
    .hl-timing { color: #ffb86c; font-weight: bold; }
    .hl-paren { color: #888; }
    .hl-code-ref { color: limegreen; font-weight: bold; }
    .hl-code-id { color: lime; }
    .hl-paint-ref { color: magenta; font-weight: bold; }
    .hl-paint-id { color: orange; }
    .hl-fade { font-weight: bold; }
    .hl-fade-sep { color: mediumseagreen; }
    .hl-fade-dir { color: cyan; }
    .hl-fade-colon { color: lime; }
    
    /* Rainbow animation */
    @keyframes rainbowCycle {
      0% { color: red; }
      14% { color: orange; }
      28% { color: yellow; }
      42% { color: lime; }
      57% { color: cyan; }
      71% { color: blue; }
      85% { color: magenta; }
      100% { color: red; }
    }
    
    .hl-rainbow {
      animation: rainbowCycle 2s linear infinite;
      font-weight: bold;
    }
    
    .hl-rainbow-0 { animation-delay: 0s; }
    .hl-rainbow-1 { animation-delay: -0.28s; }
    .hl-rainbow-2 { animation-delay: -0.56s; }
    .hl-rainbow-3 { animation-delay: -0.84s; }
    .hl-rainbow-4 { animation-delay: -1.12s; }
    .hl-rainbow-5 { animation-delay: -1.40s; }
    .hl-rainbow-6 { animation-delay: -1.68s; }
    
    /* Zebra animation */
    @keyframes zebraCycle {
      0%, 49% { color: white; }
      50%, 100% { color: #333; }
    }
    
    .hl-zebra {
      animation: zebraCycle 1s steps(1) infinite;
      font-weight: bold;
    }
    
    .hl-zebra-0 { animation-delay: 0s; }
    .hl-zebra-1 { animation-delay: -0.5s; }
    
    /* Timing blink animation */
    @keyframes hl-timing-blink {
      0%, 90% { opacity: 1; }
      95% { opacity: 0.4; color: lime; }
      100% { opacity: 1; }
    }
    
    .hl-timing-active {
      animation: hl-timing-blink var(--timing-duration, 1s) ease-in-out infinite;
    }

    /* Error display */
    #error-screen {
      display: none;
      position: absolute;
      inset: 0;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #111;
      z-index: 20;
    }
    
    #error-screen.visible {
      display: flex;
    }
    
    .error-text {
      color: rgb(255, 100, 100);
      font-family: monospace;
      font-size: 14px;
      text-align: center;
      max-width: 80%;
    }

    /* YouTube-style progress bar for playlist mode */
    #progress-bar {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%; /* Full width of screen */
      height: 1px; /* Thin line, overridden by JS based on density */
      background: #000; /* Black background */
      z-index: 100;
      margin: 0;
      padding: 0;
    }

    #progress-bar.visible {
      display: block;
    }

    #progress-fill {
      height: 100%;
      width: 0%;
      /* White fill over black background - looks like it's filling in */
      background: #fff;
      transition: width 0.25s linear;
    }

    /* FPS meter - top right (hidden by default) */
    #fps-meter {
      display: none;
      position: fixed;
      top: 0;
      right: 0;
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--density, 8) * 1.5px);
      color: lime;
      text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
      z-index: 99999;
      pointer-events: none;
      text-align: right;
      padding: calc(var(--density, 8) * 0.5px);
    }

    /* Playlist info display - top right during slideshow mode */
    #playlist-info {
      display: none;
      position: fixed;
      top: calc(var(--density, 8) * 2px);
      right: calc(var(--density, 8) * 2px);
      font-family: 'Noto Sans Mono', 'SF Mono', 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: calc(var(--density, 8) * 2px);
      color: rgba(255, 255, 255, 0.8);
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      z-index: 99;
      pointer-events: none;
      text-align: right;
      padding: calc(var(--density, 8) * 1px);
      background: rgba(0, 0, 0, 0.3);
      border-radius: calc(var(--density, 8) * 0.5px);
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }
    
    #playlist-info.visible {
      display: block;
    }
    
    #playlist-title {
      font-weight: bold;
      margin-bottom: calc(var(--density, 8) * 0.5px);
    }
    
    #playlist-position {
      color: rgba(255, 215, 0, 0.9);
    }
    
    /* FF1 cast button */
    #ff1-cast-btn {
      display: flex;
      align-items: center;
      gap: calc(var(--density, 8) * 0.75px);
      margin-top: calc(var(--density, 8) * 1px);
      padding: calc(var(--density, 8) * 0.5px) calc(var(--density, 8) * 1px);
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: calc(var(--density, 8) * 0.5px);
      color: white;
      font-size: calc(var(--density, 8) * 1.5px);
      cursor: pointer;
      transition: all 0.15s ease;
      pointer-events: auto;
    }
    
    #ff1-cast-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    #ff1-cast-btn:active {
      transform: scale(0.95);
    }
    
    #ff1-cast-btn.copied {
      background: rgba(0, 200, 100, 0.3);
      border-color: rgba(0, 200, 100, 0.6);
    }
    
    #ff1-cast-btn .ff1-logo {
      height: calc(var(--density, 8) * 2px);
      width: auto;
      filter: invert(1);
    }
    
    #ff1-cast-btn .ff1-text {
      font-family: 'Noto Sans Mono', monospace;
    }

    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       MOBILE RESPONSIVE STYLES - 9x16 portrait aspect ratio
       Targets phones in portrait mode to prevent element overlapping
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
    @media (max-aspect-ratio: 10/16) and (max-width: 600px) {
      :root {
        /* Mobile layout spacing and dimensions */
        --mobile-spacing: 8px;
        --mobile-qr-size: 48px;
        --mobile-qr-padding: 2px;
        /* Height reserved for bottom overlays (QR + label + piece info area) */
        --mobile-bottom-reserve: 100px;
        /* 
         * Total width for QR section to prevent piece-info overlap:
         * QR container (48px) + inner padding (2px * 2) + right margin (8px) + gap from piece-info (8px * 2)
         */
        --mobile-qr-total-width: calc(var(--mobile-qr-size) + var(--mobile-qr-padding) * 2 + var(--mobile-spacing) * 3);
      }
      
      /* Source code - smaller on mobile */
      #source-code {
        top: var(--mobile-spacing);
        left: var(--mobile-spacing);
        right: var(--mobile-spacing);
        bottom: var(--mobile-bottom-reserve); /* Leave room for bottom overlays */
        font-size: 10px;
      }
      
      /* QR wrap - smaller and repositioned for mobile */
      #qr-wrap {
        bottom: var(--mobile-spacing);
        right: var(--mobile-spacing);
      }
      
      #code-label {
        font-size: 10px;
        padding: var(--mobile-qr-padding) 4px;
      }
      
      #qr-container {
        width: var(--mobile-qr-size);
        height: var(--mobile-qr-size);
        padding: var(--mobile-qr-padding);
      }
      
      /* Piece info - smaller on mobile */
      #piece-info {
        bottom: var(--mobile-spacing);
        left: var(--mobile-spacing);
        font-size: 10px;
        max-width: calc(100% - var(--mobile-qr-total-width)); /* Prevent overlap with QR */
      }
      
      /* FF1 copy button - compact on mobile */
      .piece-ff1-copy {
        margin-top: 6px;
        padding: 4px 8px;
        font-size: 9px;
        gap: 4px;
      }
      
      .piece-ff1-copy .ff1-icon {
        height: 12px;
      }
      
      .piece-ff1-copy .ff1-cmd {
        max-width: 150px;
      }
      
      /* Playlist info - compact layout for mobile slideshow */
      #playlist-info {
        top: var(--mobile-spacing);
        right: var(--mobile-spacing);
        left: var(--mobile-spacing); /* Full width on mobile */
        padding: var(--mobile-spacing);
        font-size: 12px;
        flex-direction: row;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: var(--mobile-spacing);
      }
      
      #playlist-info.visible {
        display: flex;
      }
      
      #playlist-title {
        font-size: 12px;
        margin-bottom: 0;
        flex: 1;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      #playlist-position {
        font-size: 11px;
        white-space: nowrap;
      }
      
      /* FF1 button - compact single button on mobile */
      #ff1-cast-btn {
        gap: 6px;
        margin-top: 0;
        padding: 6px 10px;
        font-size: 11px;
        border-radius: 4px;
        width: 100%;
        justify-content: center;
        order: 3; /* Put button on its own row */
        flex-basis: 100%;
      }
      
      #ff1-cast-btn .ff1-logo {
        height: 14px;
      }
      
      #ff1-cast-btn .ff1-text {
        font-size: 11px;
      }
      
      /* Progress bar - thinner on mobile */
      #progress-bar {
        height: 2px;
      }
      
      /* FPS meter - smaller on mobile */
      #fps-meter {
        font-size: 10px;
        padding: 4px;
      }
    }

  </style>
</head>
<body>
  <!-- Boot animation now handled by iframe's acBootCanvas with device mode -->
  
  <!-- KidLisp source overlay with syntax highlighting and QR -->
  <div id="source-overlay">
    <div id="source-code"><div id="source-code-inner"></div></div>
    <div id="qr-wrap">
      <div id="code-label"></div>
      <div id="qr-container"></div>
    </div>
    <div id="piece-info">
      <div id="piece-handle"></div>
      <div id="piece-hits"></div>
      <div id="piece-when"></div>
      <button id="piece-ff1-copy" class="piece-ff1-copy" title="Copy FF1 CLI command">
        <img src="https://assets.aesthetic.computer/kidlisp.com/feralfile-logo.png" alt="" class="ff1-icon">
        <span class="ff1-cmd">ac-ff1 cast ...</span>
      </button>
    </div>
  </div>
  
  <div id="error-screen">
    <div class="error-text" id="error-text"></div>
  </div>
  
  <iframe id="display-iframe"></iframe>
  
  <!-- YouTube-style progress bar for playlist mode -->
  <div id="progress-bar">
    <div id="progress-fill"></div>
  </div>
  
  <!-- FPS meter for performance comparison -->
  <div id="fps-meter">FPS: --</div>
  
  <!-- Playlist info overlay for slideshow mode -->
  <div id="playlist-info">
    <div id="playlist-title"></div>
    <div id="playlist-position"></div>
    <button id="ff1-cast-btn" title="Copy FF1 CLI command to cast this playlist">
      <img src="https://assets.aesthetic.computer/kidlisp.com/feralfile-logo.png" alt="FF1" class="ff1-logo">
      <span class="ff1-text">Copy FF1 Command</span>
    </button>
  </div>
  
  <script>
    // FPS meter - calculated locally from iframe's frame timing
    (function() {
      const meter = document.getElementById('fps-meter');
      const iframe = document.getElementById('display-iframe');
      let frameCount = 0;
      let lastTime = performance.now();
      let currentFps = 0;
      
      // Listen for FPS reports from the iframe (if supported)
      window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'ac:fps-report') {
          currentFps = e.data.fps;
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
        }
      });
      
      // Fallback: calculate FPS from local animation frame
      function updateFps() {
        frameCount++;
        const now = performance.now();
        const elapsed = now - lastTime;
        
        if (elapsed >= 1000) {
          currentFps = Math.round(frameCount * 1000 / elapsed);
          meter.innerHTML = 'FPS: ' + currentFps;
          meter.style.color = currentFps >= 30 ? 'lime' : currentFps >= 15 ? 'yellow' : 'red';
          frameCount = 0;
          lastTime = now;
        }
        
        requestAnimationFrame(updateFps);
      }
      
      // Start FPS counting after iframe loads
      iframe.addEventListener('load', () => {
        setTimeout(() => {
          updateFps();
          // Also request FPS from iframe in case it reports its own
          iframe.contentWindow?.postMessage({ type: 'ac:request-fps' }, '*');
        }, 500);
      });
    })();
  </script>
  
  <script>
    // üîì KidLisp Scramble/Decode Animation for Device Mode
    // Shows scrambled code during boot, reveals when piece starts running
    (function() {
      const SCRAMBLE_CHARS = 'abcdefghijklmnopqrstuvwxyz0123456789(),-=+*/<>:;\"\'.!?@#$%^&_~`[]{}|';
      
      let isScrambling = false;
      let scrambleAnimationFrame = null;
      let pendingSource = null;
      let pendingHighlightedHtml = null;
      let decodeResolver = null;
      let waitingForDecode = false;
      
      // Scramble a character (preserve whitespace)
      function getScrambledChar(original) {
        if (original === '\n' || original === ' ' || original === '\t') return original;
        return SCRAMBLE_CHARS[Math.floor(Math.random() * SCRAMBLE_CHARS.length)];
      }
      
      // Build scrambled version of source
      function buildScrambledText(source) {
        return source.split('').map(char => {
          if (char === '\n' || char === ' ' || char === '\t') return char;
          return getScrambledChar(char);
        }).join('');
      }
      
      // Show scrambled placeholder immediately on page load with continuous animation
      // Uses eager-fetched source for correct length
      let initialScrambleFrame = null;
      let initialScrambleActive = true;
      let eagerSource = null; // Will be set from eager fetch
      (function showInitialScramble() {
        const inner = document.getElementById('source-code-inner');
        if (!inner) return;
        
        // Check if eager fetch completed - use that source for scrambling
        if (window.__eagerSourceFetch) {
          window.__eagerSourceFetch.then(data => {
            if (data?.source && initialScrambleActive) {
              eagerSource = data.source;
              console.log('üöÄ Eager source ready for scramble:', eagerSource.length, 'chars');
            }
          });
        }
        
        // Continuous scramble animation until real source loads
        function animateInitialScramble() {
          if (!initialScrambleActive) return;
          // Use eager source if available, otherwise show nothing (waiting)
          if (eagerSource) {
            inner.textContent = buildScrambledText(eagerSource);
          }
          initialScrambleFrame = requestAnimationFrame(animateInitialScramble);
        }
        animateInitialScramble();
      })();
      
      // Stop initial scramble when real scramble starts
      function stopInitialScramble() {
        initialScrambleActive = false;
        if (initialScrambleFrame) {
          cancelAnimationFrame(initialScrambleFrame);
          initialScrambleFrame = null;
        }
      }
      
      // Global stop function for slideshow mode to cancel any scramble
      window.stopScrambleAnimation = function() {
        stopInitialScramble();
        isScrambling = false;
        waitingForDecode = false;
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
          scrambleAnimationFrame = null;
        }
      };
      
      // Start scramble animation - keeps scrambling until signaled
      window.startScrambleAnimation = function(source, highlightedHtml) {
        const inner = document.getElementById('source-code-inner');
        if (!inner || !source) return;
        
        // Stop the initial placeholder scramble
        stopInitialScramble();
        
        pendingSource = source;
        pendingHighlightedHtml = highlightedHtml;
        isScrambling = true;
        waitingForDecode = true;
        
        console.log('üì∫ Starting scramble animation...');
        
        // Scramble loop
        function scrambleLoop() {
          if (!isScrambling || !waitingForDecode) return;
          
          // Show scrambled plain text (no highlighting during scramble)
          inner.textContent = buildScrambledText(pendingSource);
          
          scrambleAnimationFrame = requestAnimationFrame(scrambleLoop);
        }
        
        scrambleLoop();
        
        // Return promise that resolves when decode is triggered
        return new Promise(resolve => {
          decodeResolver = resolve;
        });
      };
      
      // Signal to start decoding (called when piece starts running)
      window.signalDecode = function() {
        if (!waitingForDecode || !pendingSource) return;
        
        console.log('üì∫ Signal received - starting decode animation');
        waitingForDecode = false;
        
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
        }
        
        // Start reveal animation
        revealCode();
      };
      
      // Reveal animation - progressively show real code
      function revealCode() {
        const inner = document.getElementById('source-code-inner');
        if (!inner || !pendingSource) {
          finalize();
          return;
        }
        
        const chars = pendingSource.split('');
        const settled = new Array(chars.length).fill(false);
        const scrambleCounts = new Array(chars.length).fill(0);
        let currentRevealIndex = 0;
        let lastRevealTime = 0;
        const revealStartTime = performance.now();
        
        // Animation settings
        const revealDuration = 400; // Total reveal time in ms
        const scrambleIterations = 1; // Scrambles before settling
        const minCharDelay = 1;
        
        const charDelay = Math.max(minCharDelay, Math.floor(revealDuration / (chars.length * scrambleIterations)));
        
        function animateReveal() {
          if (!isScrambling) {
            finalize();
            return;
          }
          
          const now = performance.now();
          const elapsed = now - revealStartTime;
          
          // Safety: Force complete if exceeded duration
          if (elapsed > revealDuration * 1.5) {
            finalize();
            return;
          }
          
          // Reveal next character
          if (now - lastRevealTime >= charDelay && currentRevealIndex < chars.length) {
            scrambleCounts[currentRevealIndex]++;
            
            if (scrambleCounts[currentRevealIndex] >= scrambleIterations) {
              settled[currentRevealIndex] = true;
              currentRevealIndex++;
              lastRevealTime = now;
            }
          }
          
          // Build current text
          const currentText = chars.map((char, i) => {
            if (settled[i]) return char;
            if (char === '\n' || char === ' ' || char === '\t') return char;
            return getScrambledChar(char);
          }).join('');
          
          inner.textContent = currentText;
          
          // Check if done
          if (settled.every(s => s)) {
            finalize();
            return;
          }
          
          requestAnimationFrame(animateReveal);
        }
        
        requestAnimationFrame(animateReveal);
      }
      
      // Finalize - show highlighted code and setup scrolling
      function finalize() {
        const inner = document.getElementById('source-code-inner');
        const codeEl = document.getElementById('source-code');
        
        if (inner && pendingHighlightedHtml) {
          inner.innerHTML = pendingHighlightedHtml;
          
          // Setup scrolling for long code
          requestAnimationFrame(() => {
            const containerHeight = codeEl.clientHeight;
            const contentHeight = inner.scrollHeight;
            
            if (contentHeight > containerHeight + 20) {
              const scrollDistance = contentHeight - containerHeight + 20;
              inner.classList.add('scrolling');
              inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
              const scrollDuration = 12 + (scrollDistance / 150);
              inner.style.setProperty('--scroll-duration', `${scrollDuration}s`);
            }
          });
          
          // Apply timing durations to timing elements
          inner.querySelectorAll('.hl-timing-active[data-duration]').forEach(el => {
            const duration = parseFloat(el.dataset.duration) || 1;
            const clampedDuration = Math.max(0.1, Math.min(duration, 10));
            el.style.setProperty('--timing-duration', clampedDuration + 's');
          });
        }
        
        isScrambling = false;
        pendingSource = null;
        pendingHighlightedHtml = null;
        
        if (decodeResolver) {
          decodeResolver();
          decodeResolver = null;
        }
      }
      
      // Stop scramble immediately
      window.stopScramble = function() {
        isScrambling = false;
        waitingForDecode = false;
        if (scrambleAnimationFrame) {
          cancelAnimationFrame(scrambleAnimationFrame);
        }
        finalize();
      };
      
      // Listen for boot-log messages from iframe
      window.addEventListener('message', (e) => {
        if (e.data?.type === 'boot-log') {
          const msg = e.data.message;
          console.log('üì∫ Boot log:', msg);
          
          // Signal decode when piece starts running
          // "loaded" is sent when the piece finishes loading
          if (msg === 'loaded' || msg === 'running boot' || msg?.includes?.('running')) {
            window.signalDecode?.();
          }
        }
      });
    })();
  </script>
  
  <script>
    // Get density from URL params
    const urlParams = new URLSearchParams(window.location.search);
    let densityParam = parseInt(urlParams.get('density')) || 8;
    
    // Set CSS custom property for density-based sizing
    document.documentElement.style.setProperty('--density', densityParam);
    
    // Listen for density changes from iframe (Cmd+/- keyboard controls)
    window.addEventListener('message', (e) => {
      if (e.data?.type === 'ac:density-change' && typeof e.data.density === 'number') {
        densityParam = e.data.density;
        document.documentElement.style.setProperty('--density', densityParam);
        // Update progress bar height (0.5x density for thin line)
        const progressBar = document.getElementById('progress-bar');
        if (progressBar) progressBar.style.height = `${Math.max(1, Math.round(0.5 * densityParam))}px`;
        console.log('üì∫ Density updated from iframe:', densityParam);
      }
    });
    
    // Boot animation is now handled by the iframe's acBootCanvas with device mode
    // (black background, white/gray bars, density scaling)
    
    // Default display parameters for FF1 and 4K displays
    const DEVICE_DEFAULTS = {
      density: 8,     // Higher density = larger pixels (8x8 screen pixels per AC pixel)
      device: true,   // Device mode - auto-enables audio, combines tv+nogap+noauth
      tv: true,       // Non-interactive TV mode
      nogap: true,    // Borderless / no gap
      nolabel: true,  // Hide labels
      noauth: true,   // No auth prompts
      popout: true,   // Popout mode
      perf: false     // Performance/FPS HUD (opt-in)
    };
    
    // Parse URL and query params
    const params = new URLSearchParams(window.location.search);
    const pathname = window.location.pathname;
    const hostname = window.location.hostname;
    
    // UI elements
    const iframe = document.getElementById('display-iframe');
    const errorScreen = document.getElementById('error-screen');
    const errorText = document.getElementById('error-text');
    
    // Boot logging (console only, no DOM log)
    function addLog(msg, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${msg}`);
    }
    
    // Determine display mode and URL
    const dev = hostname === 'localhost' || hostname === 'local.aesthetic.computer';
    const aestheticUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
    
    const logDevice = (...args) => {
      console.log('üì∫ DEVICE:', ...args);
      addLog(args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' '));
    };
    
    // Known playlist shortcuts (for nice URLs like /slideshow/top100)
    const KNOWN_PLAYLISTS = {
      'top100': '6e53465e-976f-4e93-89ff-c58b6d434fa7',
      'colors': '4b872517-e4d8-4433-af8b-a9a4a8204cc9',
      'chords': '49f0ee0e-0303-4192-9cb2-aa3c5abb64b5',
    };
    const FEED_URL = 'https://feed.aesthetic.computer';
    
    // Parse codeId or slideshow path:
    // device.kidlisp.com/codeId
    // device.kidlisp.com/slideshow/top100 (short playlist URL)
    // localhost:8888/kidlisp.com/device/codeId
    // localhost:8888/device.kidlisp.com/codeId
    let codeId = null;
    let slideshowShortcut = null;  // Will be set if using /slideshow/xxx path
    const pathParts = pathname.split('/').filter(p => p);
    
    if (hostname === 'device.kidlisp.com') {
      // Production: device.kidlisp.com/codeId or /slideshow/top100
      if (pathParts[0] === 'slideshow' && pathParts[1]) {
        slideshowShortcut = pathParts[1].toLowerCase();
      } else {
        codeId = pathParts[0] || null;
      }
    } else if (pathname.startsWith('/device.kidlisp.com/')) {
      // Local dev: localhost:8888/device.kidlisp.com/codeId or /slideshow/top100
      if (pathParts[1] === 'slideshow' && pathParts[2]) {
        slideshowShortcut = pathParts[2].toLowerCase();
      } else {
        codeId = pathParts[1] || null;
      }
    } else if (pathParts[0] === 'kidlisp.com' && pathParts[1] === 'device') {
      // Local dev: localhost:8888/kidlisp.com/device/codeId
      codeId = pathParts[2] || null;
    }
    
    // Ensure $ prefix on codeId (device.kidlisp.com/roz ‚Üí $roz)
    if (codeId && !codeId.startsWith('$')) {
      codeId = '$' + codeId;
    }
    
    // Allow param overrides of defaults
    const density = params.get('density') ?? DEVICE_DEFAULTS.density;
    const device = params.get('device') ?? DEVICE_DEFAULTS.device;
    const tv = params.get('tv') ?? DEVICE_DEFAULTS.tv;
    const nogap = params.get('nogap') ?? DEVICE_DEFAULTS.nogap;
    const nolabel = params.get('nolabel') ?? DEVICE_DEFAULTS.nolabel;
    const noauth = params.get('noauth') ?? DEVICE_DEFAULTS.noauth;
    const popout = params.get('popout') ?? DEVICE_DEFAULTS.popout;
    const perf = params.get('perf') ?? DEVICE_DEFAULTS.perf;
    
    // Playlist mode params (for DP-1 playlist progress bar)
    const isPlaylist = params.get('playlist') === 'true';
    const playlistDuration = parseInt(params.get('duration')) || 60; // seconds
    
    // Slideshow mode params (for full DP-1 playlist client)
    // playlist_url: URL to a DP-1 playlist JSON (e.g., feed.aesthetic.computer/api/v1/playlists/{id})
    // start_index: Which item to start from (0-based, default 0)
    // OR use short path: /slideshow/top100, /slideshow/colors, /slideshow/chords
    let playlistUrl = params.get('playlist_url');
    const startIndex = parseInt(params.get('start_index')) || 0;
    
    // Resolve slideshow shortcut to full playlist URL
    if (slideshowShortcut && KNOWN_PLAYLISTS[slideshowShortcut]) {
      playlistUrl = `${FEED_URL}/api/v1/playlists/${KNOWN_PLAYLISTS[slideshowShortcut]}`;
      console.log('üì∫ Resolved slideshow shortcut:', slideshowShortcut, '‚Üí', playlistUrl);
    }
    
    // Flag to indicate we're in slideshow mode (skip scramble animation)
    const slideshowMode = !!playlistUrl;
    
    // Slideshow state (populated when playlist_url is provided)
    let slideshowPlaylist = null;  // The fetched DP-1 playlist
    let slideshowIndex = startIndex;  // Current item index
    let slideshowTimer = null;  // Timer for auto-advance
    
    // Build query string for display params
    function buildDisplayParams() {
      const p = new URLSearchParams();
      if (density !== null) p.set('density', density);
      if (device) p.set('device', 'true');
      if (tv) p.set('tv', 'true');
      if (nogap) p.set('nogap', 'true');
      if (nolabel) p.set('nolabel', 'true');
      if (noauth) p.set('noauth', 'true');
      if (popout) p.set('popout', 'true');
      if (perf) p.set('perf', 'true');
      p.set('noboot', 'true'); // Skip boot animation for clean device display
      p.set('t', Date.now()); // Cache bust
      return p.toString();
    }
    
    function showError(msg) {
      errorText.textContent = msg;
      errorScreen.classList.add('visible');
    }
    
    // Initialize display
    function init() {
      logDevice('init', { codeId, density, dev, hostname, pathname, playlistUrl });
      
      // Check if we're in slideshow mode (playlist_url param provided)
      if (playlistUrl) {
        initSlideshow();
        return;
      }
      
      if (!codeId) {
        showError('Usage: device.kidlisp.com/{codeId} or ?playlist_url=...');
        return;
      }
      
      // Set page title (codeId already includes $ prefix)
      document.title = `KidLisp.com ¬∑ ${codeId}`;
      
      // Build the codeId URL with display params
      // codeId (e.g. "$zo5") loads the stored kidlisp code from MongoDB
      iframe.src = `${aestheticUrl}/${codeId}?${buildDisplayParams()}`;
      
      logDevice('iframe src', { src: iframe.src });
      
      // Handle iframe load
      iframe.addEventListener('load', () => {
        logDevice('iframe loaded');
        // Source overlay stays visible always - shows code and QR
      });
      
      // Listen for iframe errors
      iframe.addEventListener('error', (e) => {
        addLog(`iframe error: ${e.message || 'unknown'}`, 'error');
      });
      
      // Always start playlist progress bar (visible indicator of time remaining)
      console.log('üì∫ Playlist mode:', isPlaylist, 'duration:', playlistDuration);
      console.log('üì∫ Starting progress bar...');
      startProgressBar();
      
      // Fetch and display KidLisp source code with syntax highlighting
      fetchAndDisplaySource(codeId);
      
      // Setup the FF1 CLI copy button for single pieces
      setupFF1CopyButton(codeId);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SLIDESHOW MODE - Full DP-1 playlist client
    // Fetches playlist from playlist_url and auto-advances through items
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async function initSlideshow() {
      console.log('üì∫ Initializing slideshow mode with URL:', playlistUrl);
      
      // Show playlist info overlay
      const playlistInfo = document.getElementById('playlist-info');
      const playlistTitle = document.getElementById('playlist-title');
      const playlistPosition = document.getElementById('playlist-position');
      const ff1CastBtn = document.getElementById('ff1-cast-btn');
      
      playlistTitle.textContent = 'Loading playlist...';
      playlistInfo.classList.add('visible');
      
      // Setup FF1 cast button
      ff1CastBtn.addEventListener('click', async () => {
        // Build the FF1 CLI displayPlaylist command
        const cmd = `ff1 displayPlaylist --url "${playlistUrl}"`;
        
        try {
          await navigator.clipboard.writeText(cmd);
          ff1CastBtn.classList.add('copied');
          ff1CastBtn.querySelector('.ff1-text').textContent = 'Copied!';
          
          setTimeout(() => {
            ff1CastBtn.classList.remove('copied');
            ff1CastBtn.querySelector('.ff1-text').textContent = 'Copy FF1 Command';
          }, 2000);
        } catch (e) {
          console.error('Failed to copy:', e);
          // Fallback: show the command in an alert
          alert('FF1 CLI Command:\n\n' + cmd);
        }
      });
      
      try {
        // Fetch the DP-1 playlist
        const response = await fetch(playlistUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch playlist: ${response.status}`);
        }
        
        slideshowPlaylist = await response.json();
        console.log('üì∫ Playlist loaded:', slideshowPlaylist.title, 'with', slideshowPlaylist.items?.length, 'items');
        
        if (!slideshowPlaylist.items || slideshowPlaylist.items.length === 0) {
          showError('Playlist is empty');
          return;
        }
        
        // Update playlist title
        playlistTitle.textContent = slideshowPlaylist.title || 'Untitled Playlist';
        
        // Clamp start index to valid range
        if (slideshowIndex >= slideshowPlaylist.items.length) {
          slideshowIndex = 0;
        }
        
        // Set page title
        document.title = `KidLisp.com ¬∑ ${slideshowPlaylist.title || 'Slideshow'}`;
        
        // Start playing from the start index
        playCurrentItem();
        
      } catch (e) {
        console.error('üì∫ Failed to load playlist:', e);
        showError(`Failed to load playlist: ${e.message}`);
      }
    }
    
    function playCurrentItem() {
      if (!slideshowPlaylist || !slideshowPlaylist.items) return;
      
      const item = slideshowPlaylist.items[slideshowIndex];
      if (!item) {
        console.log('üì∫ No more items, looping to start');
        slideshowIndex = 0;
        playCurrentItem();
        return;
      }
      
      console.log('üì∫ Playing item', slideshowIndex + 1, '/', slideshowPlaylist.items.length, ':', item.title);
      
      // Update position display
      const playlistPosition = document.getElementById('playlist-position');
      playlistPosition.textContent = `${slideshowIndex + 1} / ${slideshowPlaylist.items.length}`;
      
      // Get the source URL from the item
      // DP-1 items have a 'source' field with the display URL
      let itemUrl = item.source || item.url || '';
      
      // If it's a device.kidlisp.com URL, use it directly (already has display params)
      // Otherwise, build the URL ourselves
      if (!itemUrl.includes('device.kidlisp.com')) {
        // It's a raw URL, add display params
        const separator = itemUrl.includes('?') ? '&' : '?';
        itemUrl = `${itemUrl}${separator}${buildDisplayParams()}`;
      }
      
      // Load the item in the iframe
      iframe.src = itemUrl;
      
      // Get duration from item or playlist defaults
      const duration = item.duration || slideshowPlaylist.defaults?.duration || 24;
      
      // Clear any existing timer
      if (slideshowTimer) {
        clearTimeout(slideshowTimer);
      }
      
      // Start progress bar for this item
      startSlideshowProgressBar(duration);
      
      // Try to extract codeId from URL for source display
      const codeMatch = itemUrl.match(/\/(\$[a-z0-9]+)/i) || itemUrl.match(/device\.kidlisp\.com\/(\$?[a-z0-9]+)/i);
      if (codeMatch) {
        let extractedCodeId = codeMatch[1];
        if (!extractedCodeId.startsWith('$')) extractedCodeId = '$' + extractedCodeId;
        fetchAndDisplaySource(extractedCodeId);
      } else {
        // Clear source display for non-kidlisp items
        document.getElementById('source-code-inner').innerHTML = '';
        document.getElementById('piece-handle').textContent = '';
        document.getElementById('piece-hits').textContent = '';
      }
      
      // Set timer to advance to next item
      slideshowTimer = setTimeout(() => {
        slideshowIndex++;
        playCurrentItem();
      }, duration * 1000);
    }
    
    function startSlideshowProgressBar(duration) {
      const progressBar = document.getElementById('progress-bar');
      const progressFill = document.getElementById('progress-fill');
      
      // Set height based on density
      const barHeight = Math.max(1, Math.round(0.5 * densityParam));
      progressBar.style.height = `${barHeight}px`;
      progressBar.classList.add('visible');
      
      // Reset progress
      progressFill.style.width = '0%';
      
      const startTime = Date.now();
      const durationMs = duration * 1000;
      
      function updateProgress() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(100, (elapsed / durationMs) * 100);
        progressFill.style.width = `${progress}%`;
        
        if (progress < 100) {
          requestAnimationFrame(updateProgress);
        }
      }
      
      requestAnimationFrame(updateProgress);
    }
    
    // Fetch KidLisp source from API (uses eager fetch if available)
    async function fetchAndDisplaySource(codeId) {
      console.log('üì∫ fetchAndDisplaySource called with:', codeId);
      // Strip $ prefix if present for API call
      const pieceCode = codeId.startsWith('$') ? codeId.slice(1) : codeId;
      const displayCode = codeId.startsWith('$') ? codeId : '$' + codeId;
      
      // Always generate QR code and label first (even before source loads)
      generateQRAndLabel(displayCode);
      
      try {
        // Use eager fetch result if available, otherwise fetch now
        let data = null;
        if (window.__eagerSourceFetch) {
          console.log('üì∫ Using eager-fetched source');
          data = await window.__eagerSourceFetch;
        }
        
        // Fallback to regular fetch if eager fetch failed or wasn't available
        if (!data) {
          const apiUrl = dev ? 'https://localhost:8888' : 'https://aesthetic.computer';
          const url = `${apiUrl}/api/store-kidlisp?code=${pieceCode}`;
          console.log('üì∫ Fetching source from:', url);
          const response = await fetch(url, { credentials: 'omit' });
          console.log('üì∫ Source fetch response:', response.status, response.statusText);
          if (response.ok) {
            data = await response.json();
          }
        }
        
        if (data) {
          console.log('üì∫ Source data:', data);
          if (data.source) {
            displaySourceCode(data.source);
          } else {
            console.log('üì∫ No source in response');
          }
          // Display handle and hits
          displayPieceInfo(data);
        } else {
          console.log('üì∫ Source fetch failed or no data');
        }
      } catch (e) {
        console.log('üì∫ Could not fetch source:', e);
      }
    }
    
    // Display syntax-highlighted source code with scramble animation
    function displaySourceCode(source) {
      const codeEl = document.getElementById('source-code');
      const inner = document.getElementById('source-code-inner');
      if (!inner || !source) return;
      
      // Generate highlighted HTML
      const highlightedHtml = highlightKidlisp(source);
      
      // In slideshow mode, skip scramble - show highlighted code immediately
      if (slideshowMode) {
        // Stop any running scramble animation
        if (window.stopScrambleAnimation) window.stopScrambleAnimation();
        inner.innerHTML = highlightedHtml;
        // Reset scrolling classes
        inner.classList.remove('scrolling');
        inner.style.removeProperty('--scroll-distance');
        inner.style.removeProperty('--scroll-duration');
        // Setup fresh scrolling for this source
        setupScrolling(codeEl, inner);
        return;
      }
      
      // Start scramble animation - will decode when piece starts running
      if (window.startScrambleAnimation) {
        window.startScrambleAnimation(source, highlightedHtml);
      } else {
        // Fallback: show highlighted code immediately
        inner.innerHTML = highlightedHtml;
        setupScrolling(codeEl, inner);
      }
    }
    
    // Setup scrolling for long code (called after decode finishes)
    function setupScrolling(codeEl, inner) {
      requestAnimationFrame(() => {
        const containerHeight = codeEl.clientHeight;
        const contentHeight = inner.scrollHeight;
        
        if (contentHeight > containerHeight + 20) {
          const scrollDistance = contentHeight - containerHeight + 20;
          inner.classList.add('scrolling');
          inner.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
          const scrollDuration = 12 + (scrollDistance / 150);
          inner.style.setProperty('--scroll-duration', `${scrollDuration}s`);
        }
      });
      
      // Apply timing durations to timing elements
      inner.querySelectorAll('.hl-timing-active[data-duration]').forEach(el => {
        const duration = parseFloat(el.dataset.duration) || 1;
        const clampedDuration = Math.max(0.1, Math.min(duration, 10));
        el.style.setProperty('--timing-duration', clampedDuration + 's');
      });
    }
    
    // Generate QR code pointing to kidlisp.com/$piece
    function generateQRAndLabel(displayCode) {
      console.log('üì∫ generateQRAndLabel called with:', displayCode);
      const labelEl = document.getElementById('code-label');
      const qrContainer = document.getElementById('qr-container');
      
      // Build label with colored $ and code
      if (labelEl) {
        const dollar = displayCode[0] === '$' ? '$' : '';
        const code = displayCode.startsWith('$') ? displayCode.slice(1) : displayCode;
        labelEl.innerHTML = `<span class="code-dollar">${dollar}</span><span class="code-name">${code}</span>`;
        console.log('üì∫ Label set:', dollar + code);
      }
      
      // Generate QR code pointing to kidlisp.com (NOT aesthetic.computer)
      if (qrContainer && typeof qrcode !== 'undefined') {
        try {
          const qrUrl = `https://kidlisp.com/${displayCode}`;
          console.log('üì∫ Generating QR for:', qrUrl);
          const qrGen = qrcode(0, 'L');
          qrGen.addData(qrUrl);
          qrGen.make();
          const svg = qrGen.createSvgTag(2, 0);
          qrContainer.innerHTML = svg;
          const svgEl = qrContainer.querySelector('svg');
          if (svgEl) {
            // Size is set by CSS using --density variable
            svgEl.style.display = 'block';
            svgEl.style.width = '100%';
            svgEl.style.height = '100%';
            console.log('üì∫ QR SVG created');
          }
        } catch (e) {
          console.error('üì∫ QR generation error:', e);
        }
      } else {
        console.log('üì∫ QR container not found or qrcode lib not loaded');
      }
    }
    
    // Display handle and hits info
    function displayPieceInfo(data) {
      const handleEl = document.getElementById('piece-handle');
      const hitsEl = document.getElementById('piece-hits');
      const whenEl = document.getElementById('piece-when');
      
      if (handleEl) {
        if (data.handle) {
          handleEl.textContent = data.handle;
          console.log('üì∫ Handle:', data.handle);
        } else {
          handleEl.textContent = 'anonymous';
          handleEl.style.color = 'rgb(150, 150, 150)';
          console.log('üì∫ Handle: anonymous');
        }
      }
      
      if (hitsEl && typeof data.hits === 'number') {
        hitsEl.textContent = data.hits.toLocaleString() + ' hits';
        console.log('üì∫ Hits:', data.hits);
      }
      
      if (whenEl && data.when) {
        const date = new Date(data.when);
        const formatted = date.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'short', 
          day: 'numeric' 
        });
        whenEl.textContent = formatted;
        console.log('üì∫ When:', formatted);
      }
    }
    
    // Setup the FF1 CLI copy button for single pieces
    function setupFF1CopyButton(pieceCodeId) {
      const copyBtn = document.getElementById('piece-ff1-copy');
      if (!copyBtn) return;
      
      // Build the device URL for the CLI command
      const cleanCode = pieceCodeId.startsWith('$') ? pieceCodeId.slice(1) : pieceCodeId;
      const deviceUrl = `https://device.kidlisp.com/${cleanCode}`;
      const cliCmd = `ac-ff1 cast ${deviceUrl}`;
      
      // Update button text to show the actual command
      const cmdSpan = copyBtn.querySelector('.ff1-cmd');
      if (cmdSpan) {
        cmdSpan.textContent = cliCmd;
        cmdSpan.title = cliCmd;
      }
      
      // Handle click to copy
      copyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(cliCmd);
          copyBtn.classList.add('copied');
          if (cmdSpan) cmdSpan.textContent = 'Copied!';
          
          setTimeout(() => {
            copyBtn.classList.remove('copied');
            if (cmdSpan) cmdSpan.textContent = cliCmd;
          }, 2000);
        } catch (e) {
          console.error('üì∫ Failed to copy:', e);
          // Fallback: show alert with the command
          alert('FF1 CLI Command:\n\n' + cliCmd);
        }
      });
      
      console.log('üì∫ FF1 copy button setup with command:', cliCmd);
    }
    
    // KidLisp syntax highlighter (matches kidlisp.com/give.aesthetic.computer)
    function highlightKidlisp(code) {
      if (!code) return '';
      // Escape HTML first
      let html = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      // CSS color map
      const cssColors = {
        aliceblue: [240, 248, 255], aqua: [0, 255, 255], aquamarine: [127, 255, 212],
        azure: [240, 255, 255], beige: [245, 245, 220], black: [0, 0, 0],
        blue: [0, 0, 255], brown: [165, 42, 42], chartreuse: [127, 255, 0],
        coral: [255, 127, 80], crimson: [220, 20, 60], cyan: [0, 255, 255],
        darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgreen: [0, 100, 0],
        darkgray: [169, 169, 169], darkgrey: [169, 169, 169], darkmagenta: [139, 0, 139],
        darkorange: [255, 140, 0], darkred: [139, 0, 0], darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255],
        gold: [255, 215, 0], gray: [128, 128, 128], grey: [128, 128, 128],
        green: [0, 128, 0], greenyellow: [173, 255, 47], hotpink: [255, 105, 180],
        indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140],
        lavender: [230, 230, 250], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255],
        lightgray: [211, 211, 211], lightgrey: [211, 211, 211], lightgreen: [144, 238, 144],
        lightpink: [255, 182, 193], lightskyblue: [135, 206, 250], lightyellow: [255, 255, 224],
        lime: [0, 255, 0], limegreen: [50, 205, 50], magenta: [255, 0, 255],
        maroon: [128, 0, 0], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250], mistyrose: [255, 228, 225], navy: [0, 0, 128],
        olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0],
        orangered: [255, 69, 0], orchid: [218, 112, 214], palegreen: [152, 251, 152],
        pink: [255, 192, 203], plum: [221, 160, 221], purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153], red: [255, 0, 0], royalblue: [65, 105, 225],
        salmon: [250, 128, 114], seagreen: [46, 139, 87], sienna: [160, 82, 45],
        silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205],
        slategray: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127],
        steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128],
        thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208],
        violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255],
        yellow: [255, 255, 0], yellowgreen: [154, 205, 50]
      };
      
      // Rainbow text helper
      function rainbowText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-rainbow hl-rainbow-${i % 7}">${char}</span>`
        ).join('');
      }
      
      // Zebra text helper
      function zebraText(text) {
        return text.split('').map((char, i) => 
          `<span class="hl-zebra hl-zebra-${i % 2}">${char}</span>`
        ).join('');
      }
      
      // Fade text helper
      function fadeText(fadeStr) {
        const parts = fadeStr.split(':');
        if (parts.length < 2) return `<span class="hl-fade">${fadeStr}</span>`;
        const colors = parts[1].split('-');
        const direction = parts[2] || '';
        
        let result = '<span class="hl-fade" style="color: #ffb86c;">fade</span><span class="hl-fade-colon">:</span>';
        colors.forEach((c, i) => {
          const rgb = cssColors[c.toLowerCase()];
          if (rgb) {
            result += `<span class="hl-color" style="color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})">${c}</span>`;
          } else if (c === 'rainbow') {
            result += rainbowText(c);
          } else if (c === 'zebra') {
            result += zebraText(c);
          } else {
            result += `<span class="hl-fade">${c}</span>`;
          }
          if (i < colors.length - 1) result += '<span class="hl-fade-sep">-</span>';
        });
        if (direction) {
          result += `<span class="hl-fade-colon">:</span><span class="hl-fade-dir">${direction}</span>`;
        }
        return result;
      }
      
      // Code reference helper ($code)
      function codeRefText(codeRef) {
        const dollar = codeRef[0];
        const id = codeRef.slice(1);
        return `<span class="hl-code-ref">${dollar}</span><span class="hl-code-id">${id}</span>`;
      }
      
      // Paint reference helper (#painting)
      function paintRefText(paintRef) {
        const hash = paintRef[0];
        const id = paintRef.slice(1);
        return `<span class="hl-paint-ref">${hash}</span><span class="hl-paint-id">${id}</span>`;
      }
      
      // Token placeholders
      const tokens = [];
      function token(match, cls, style) {
        const idx = tokens.length;
        const styleAttr = style ? ` style="${style}"` : '';
        tokens.push(`<span class="${cls}"${styleAttr}>${match}</span>`);
        return `\x01T${idx}T\x01`;
      }
      
      function tokenRaw(html) {
        const idx = tokens.length;
        tokens.push(html);
        return `\x01T${idx}T\x01`;
      }
      
      // Apply syntax highlighting (order matters)
      
      // $code references
      html = html.replace(/(\$[0-9A-Za-z]+)/g, m => tokenRaw(codeRefText(m)));
      
      // #painting references
      html = html.replace(/(#[0-9A-Fa-f]{1,8})\b/g, m => tokenRaw(paintRefText(m)));
      
      // Fade patterns
      html = html.replace(/\b(fade:[a-z0-9-]+(?::[a-z]+)?)\b/gi, m => tokenRaw(fadeText(m)));
      
      // Rainbow keyword
      html = html.replace(/\b(rainbow)\b/g, m => tokenRaw(rainbowText(m)));
      
      // Zebra keyword
      html = html.replace(/\b(zebra)\b/g, m => tokenRaw(zebraText(m)));
      
      // Comments
      html = html.replace(/(^|\n)(;[^\n]*)/g, (m, pre, comment) => pre + token(comment, 'hl-comment'));
      
      // Timing patterns
      html = html.replace(/(^|[\s(])(\d*\.?\d+)([sf](\.{1,3}|!?))/g, (m, pre, num, suffix) => {
        const full = num + suffix;
        const unit = suffix[0];
        const duration = unit === 's' ? parseFloat(num) : parseFloat(num) / 60;
        const idx = tokens.length;
        tokens.push(`<span class="hl-timing hl-timing-active" data-duration="${duration}">${full}</span>`);
        return pre + `\x01T${idx}T\x01`;
      });
      
      // Strings
      html = html.replace(/("[^"]*")/g, m => token(m, 'hl-string'));
      
      // Numbers
      html = html.replace(/\b(\d+\.?\d*)\b/g, m => token(m, 'hl-number'));
      
      // Keywords
      const keywords = ['def', 'fn', 'if', 'cond', 'let', 'loop', 'repeat', 'later', 'tap', 'drag', 'lift', 'key', 'draw', 'frame', 'now', 'once'];
      keywords.forEach(kw => {
        html = html.replace(new RegExp(`\\b(${kw})\\b`, 'g'), m => token(m, 'hl-keyword'));
      });
      
      // API calls
      const apiCalls = ['wipe', 'ink', 'line', 'box', 'circle', 'text', 'pan', 'zoom', 'blur', 'noise', 'width', 'height', 'wiggle', 'grid', 'plot', 'stamp', 'scroll', 'contrast', 'fps'];
      apiCalls.forEach(api => {
        html = html.replace(new RegExp(`\\b(${api})\\b`, 'g'), m => token(m, 'hl-api'));
      });
      
      // Colors
      const colorNames = Object.keys(cssColors).filter(c => c !== 'rainbow' && c !== 'zebra');
      colorNames.forEach(colorName => {
        const rgb = cssColors[colorName];
        const colorStyle = `color: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        html = html.replace(new RegExp(`\\b(${colorName})\\b`, 'gi'), m => token(m, 'hl-color', colorStyle));
      });
      
      // Parens
      html = html.replace(/([()])/g, m => token(m, 'hl-paren'));
      
      // Replace tokens back
      html = html.replace(/\x01T(\d+)T\x01/g, (_, idx) => tokens[parseInt(idx)]);
      return html;
    }
    
    // Progress bar elements (must be declared before init() calls startProgressBar)
    const progressBar = document.getElementById('progress-bar');
    const progressFill = document.getElementById('progress-fill');
    let progressStartTime = null;
    
    function startProgressBar() {
      console.log('üì∫ startProgressBar called, densityParam:', densityParam);
      // Set height based on density (0.5x for thin line, min 1px)
      const barHeight = Math.max(1, Math.round(0.5 * densityParam));
      console.log('üì∫ Progress bar height:', barHeight);
      progressBar.style.height = `${barHeight}px`;
      progressBar.classList.add('visible');
      console.log('üì∫ Progress bar visible class added');
      progressStartTime = Date.now();
      updateProgressBar();
    }
    
    // Track if piece has changed (for auto-reload logic)
    let pieceHasChanged = false;
    window.addEventListener('message', (e) => {
      // Listen for boot-log, ready, or any paint frame as sign piece is running
      if (e.data?.type === 'boot-log' || e.data?.type === 'ready' || e.data?.type === 'ac:fps-report') {
        pieceHasChanged = true;
      }
    });
    
    function updateProgressBar() {
      if (!progressStartTime) return;
      
      const elapsed = (Date.now() - progressStartTime) / 1000;
      const progress = Math.min(100, (elapsed / playlistDuration) * 100);
      progressFill.style.width = `${progress}%`;
      
      if (progress < 100) {
        requestAnimationFrame(updateProgressBar);
      } else {
        // Progress bar complete - check if we should reload
        // Wait 2 seconds after progress bar completes
        setTimeout(() => {
          if (!pieceHasChanged) {
            console.log('üì∫ Page stuck - reloading after progress bar timeout');
            reloadPiece();
          } else {
            // Reset for next cycle and restart progress bar
            pieceHasChanged = false;
            progressStartTime = Date.now();
            progressFill.style.width = '0%';
            requestAnimationFrame(updateProgressBar);
          }
        }, 2000);
      }
    }
    
    // Reload the current piece (soft reload - just iframe)
    function reloadPiece() {
      console.log('üì∫ Reloading piece...');
      pieceHasChanged = false;
      progressStartTime = Date.now();
      progressFill.style.width = '0%';
      iframe.src = iframe.src.replace(/&t=\d+/, '') + '&t=' + Date.now();
      requestAnimationFrame(updateProgressBar);
    }
    
    // Start the app
    init();
  </script>
</body>
</html>