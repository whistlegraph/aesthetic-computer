<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>aesthetic.computer</title>
    <script src="/aesthetic.computer/boot.js" type="module" defer></script>
    <!-- Modulepreload hints for critical path modules -->
    <link rel="modulepreload" href="/aesthetic.computer/bios.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/parse.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/disk.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/graph.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/kidlisp.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/num.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/help.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/geo.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/pen.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/keyboard.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/loop.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/store.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/type.mjs">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/aesthetic.computer/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="og:title" content="aesthetic.computer" />
    <meta name="og:description" content="Run any piece by typing its name..." />
    <meta name="og:image" content="https://aesthetic.computer/preview/1200x630" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="aesthetic.computer" />
    <meta name="twitter:site" content="aesthetic.computer" />
    <meta name="twitter:image" content="https://aesthetic.computer/preview/800x800"/>
    <script>
      // Global error handler for fatal boot errors
      window.onerror = function(message, source, lineno, colno, error) {
        // Only show if we haven't booted yet (canvas not present)
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          const sourcePath = source ? source.replace(window.location.origin, '') : 'unknown';
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error</h2>` +
            `<strong style="color:#ffcc66;">${message}</strong>\n\n` +
            `File: ${sourcePath}\n` +
            `Line: ${lineno}, Column: ${colno}\n\n` +
            (error?.stack ? `<span style="color:#888;">${error.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
        return false;
      };
      // Also catch unhandled promise rejections
      window.onunhandledrejection = function(event) {
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error (Promise)</h2>` +
            `<strong style="color:#ffcc66;">${event.reason}</strong>\n\n` +
            (event.reason?.stack ? `<span style="color:#888;">${event.reason.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
      };
    </script>
  </head>
  <body class="native-cursor"> <!-- Hides the 2D UI on first boot. -->
  <!-- Boot Log Overlay - Single Canvas -->
  <canvas id="boot-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;pointer-events:none;margin:0;padding:0;"></canvas>
  <script>
    // üìº VHS Hacker Boot Screen - syntax highlighted code, variable sizes
    window.acBootCanvas = (function() {
      const canvas = document.getElementById('boot-canvas');
      if (!canvas) return {};
      const ctx = canvas.getContext('2d');
      let W = window.innerWidth, H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      window.addEventListener('resize', () => { W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; });
      const logoSize = 64;
      const logoX = 8, logoY = 8;
      const textX = logoX + logoSize + 14;
      const textStartY = 18;
      const lineHeight = 14;
      const maxLines = 18;
      
      // Tiny 16x16 PNG placeholder (loads instantly), then swap to full SVG
      const tinyPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR4nN2Ru0pDQRCGg3fUzk5bEVS0ELxVwQsYTRBvJ5ed3VgZVBB8g1Q+gCDIzq6IluclUktmT1Kk8mWUWT2RTcBep1nmZ//vn53NZP5XOWU3ndTlOIoHe/UE8MxJM8s9SdxuVR9nAnMneph0Up+25esECSwEAGFK3gh4SwIvnDQ5UrgXAN5v7kcJ9HUjWx/iKZwyJ6RsxMkEWPzSTY7A5psVsxaYG+fPYyTNFZ8+qaaHSRjhzcpGrSou+knKdprH70t2Ci+Z7qS56wIAj9M7DPkJskcBIAG96gHKzKdv/X5vkU+/E7B5AtxI4GnBKasSpXf5brBIqulxB/qQjZzO4/uxwe68qZep7l6EXmKNQemv+GIzE5vKHKTL87owpbbCOQK9wj1Jvc59prcSwAqnd6J4hM0pgGGsf9TrA32mACD0Pu/Dp1bNcqJ01gMEFkjYrV/Nf7s+AS1XxDy7PXOrAAAAAElFTkSuQmCC';
      const img = new Image();
      const imgFull = new Image();
      let imgFullLoaded = false;
      img.src = tinyPng; // Instant load
      imgFull.onload = () => { imgFullLoaded = true; };
      imgFull.src = '/purple-pals.svg';
      
      // Boot state
      let lines = [];
      let lineCount = 0;
      let bootProgress = 0;
      let cursorVisible = true;
      let cursorTimer = 0;
      let lastLogTime = performance.now();
      let logBurst = 0;
      const bootStartTime = performance.now();
      
      // Code stripe colors (VSCode-ish palette)
      const STRIPE_COLORS = [
        [197, 134, 192],  // purple
        [220, 220, 170],  // yellow
        [206, 145, 120],  // orange
        [181, 206, 168],  // green
        [78, 201, 176],   // teal
        [156, 220, 254],  // light blue
      ];
      
      // Simple stripe system - just colored bars, no text measurement
      let stripes = [];
      const STRIPE_MAX = 80;
      const STRIPE_SPEED = 3;
      
      let frame = 0;
      let running = true;
      
      // Pre-populate stripes for instant visual
      for (let i = 0; i < 50; i++) {
        stripes.push({
          x: Math.random() * W,
          y: H - i * 16 - Math.random() * 10,
          w: 30 + Math.random() * 120,
          h: 2 + Math.random() * 4,
          color: STRIPE_COLORS[Math.random() * STRIPE_COLORS.length | 0],
          alpha: 0.15 + Math.random() * 0.35,
          speed: STRIPE_SPEED + Math.random() * 2
        });
      }
      
      const addLine = (msg) => {
        const now = performance.now();
        const deltaMs = now - lastLogTime;
        lastLogTime = now;
        
        const speed = Math.min(1, 500 / Math.max(50, deltaMs));
        logBurst = 0.5 + speed * 0.5;
        
        if (lines.length > 0) lines[0].text = lines[0].text.replace(/_$/, '');
        lines.unshift({ text: msg + '_', time: now, burst: logBurst });
        if (lines.length > maxLines) lines.pop();
        
        lineCount++;
        bootProgress = Math.min(1, lineCount / 15);
      };
      
      const animate = () => {
        if (!running || !document.getElementById('boot-canvas')) return;
        
        const t = frame * 0.05;
        frame++;
        cursorTimer++;
        if (cursorTimer % 15 === 0) cursorVisible = !cursorVisible;
        
        logBurst *= 0.9;
        
        // Chaos INCREASES with boot progress
        const chaos = bootProgress + logBurst * 0.5;
        const colorLerp = bootProgress;
        
        // Base shake from the start
        const baseShake = 0.5 + Math.sin(t * 2) * 0.3;
        const shakeAmount = baseShake + chaos * chaos * 5 + logBurst * 4;
        const shakeX = (Math.random() - 0.5) * shakeAmount;
        const shakeY = (Math.random() - 0.5) * shakeAmount;
        
        // Spawn new stripes continuously
        const spawnCount = 1 + (chaos * 1.5) | 0;
        for (let s = 0; s < spawnCount; s++) {
          stripes.push({
            x: Math.random() * W * 0.9,
            y: H + 5,
            w: 40 + Math.random() * 150,
            h: 2 + Math.random() * 5,
            color: STRIPE_COLORS[Math.random() * STRIPE_COLORS.length | 0],
            alpha: 0.2 + Math.random() * 0.4,
            speed: STRIPE_SPEED + Math.random() * 2.5 + chaos
          });
          if (stripes.length > STRIPE_MAX) stripes.shift();
        }
        
        // Update stripe positions
        stripes.forEach(s => s.y -= s.speed);
        stripes = stripes.filter(s => s.y > -10);
        
        // === DRAW ===
        ctx.clearRect(0, 0, W, H);
        
        // Draw stripes - simple colored rectangles, very fast
        stripes.forEach(s => {
          if (s.y < 0 || s.y > H) return;
          const [r, g, b] = s.color;
          const shake = 0.5 + chaos * 2;
          ctx.globalAlpha = s.alpha * (0.5 + chaos * 0.5);
          ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
          ctx.fillRect(
            s.x + (Math.random() - 0.5) * shake,
            s.y + (Math.random() - 0.5) * shake,
            s.w, s.h
          );
        });
        ctx.globalAlpha = 1;
        
        // Draw logo with wobble; use tiny pixelated PNG until full SVG loads
        const logoShake = baseShake * 0.8 + chaos * chaos * 3;
        ctx.imageSmoothingEnabled = !imgFullLoaded; // Pixelated for tiny, smooth for full
        if (!imgFullLoaded) ctx.imageSmoothingEnabled = false; // Nearest neighbor scaling
        const logoImg = imgFullLoaded ? imgFull : img;
        ctx.drawImage(logoImg, 
          logoX + shakeX * 0.5 + (Math.random() - 0.5) * logoShake, 
          logoY + shakeY * 0.5 + (Math.random() - 0.5) * logoShake, 
          logoSize, logoSize);
        ctx.imageSmoothingEnabled = true;
        if (false) { // Placeholder circle disabled - using tiny PNG instead
          ctx.save();
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = `rgb(${140 + (Math.random()*80|0)}, ${60 + (Math.random()*40|0)}, ${150 + (Math.random()*80|0)})`;
          ctx.beginPath();
          ctx.arc(logoX + logoSize/2, logoY + logoSize/2, logoSize/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        
        // Live ms timer under logo
        const elapsedMs = performance.now() - bootStartTime;
        ctx.font = 'bold 10px "Courier New", monospace';
        const timerStr = (elapsedMs | 0).toString().padStart(5, '0') + 'ms';
        const timerR = 80 + chaos * 120 | 0;
        const timerG = 80 + chaos * 40 | 0;
        const timerB = 100 + chaos * 100 | 0;
        ctx.globalAlpha = 0.6 + chaos * 0.4;
        ctx.fillStyle = `rgb(${timerR}, ${timerG}, ${timerB})`;
        const timerShake = baseShake + chaos * 2;
        ctx.fillText(timerStr, logoX + 4 + shakeX * 0.5 + (Math.random() - 0.5) * timerShake, logoY + logoSize + 14 + shakeY * 0.5 + (Math.random() - 0.5) * timerShake);
        ctx.globalAlpha = 1;
        
        // Draw log text
        ctx.font = '12px "Courier New", monospace';
        const now = performance.now();
        lines.forEach((line, i) => {
          const y = textStartY + i * lineHeight;
          if (y > H - 10) return;
          
          const age = i * 0.08;
          const alpha = Math.max(0.25, 1 - age * 0.6);
          const lineAge = (now - line.time) / 1000;
          const lineBurst = Math.max(0, line.burst - lineAge * 2);
          
          let displayText = line.text;
          if (i === 0 && !cursorVisible) displayText = displayText.replace(/_$/, ' ');
          
          // Shake from start, more with chaos
          const lineShake = baseShake * 0.5 + lineBurst * 3 + chaos * 1.5;
          const lx = textX + shakeX + (Math.random() - 0.5) * lineShake;
          const ly = y + shakeY + (Math.random() - 0.5) * lineShake;
          
          // Colors: pink ‚Üí noise16Aesthetic purple
          const baseR = 200 - colorLerp * 100 - i * 5;
          const baseG = 80 - colorLerp * 55 - i * 4;
          const baseB = 140 + colorLerp * 60 - i * 2;
          
          // Subtle glow from start, stronger with chaos
          ctx.globalAlpha = alpha * (0.15 + chaos * 0.25 + lineBurst * 0.3);
          ctx.filter = `blur(${2 + chaos * 3}px)`;
          ctx.fillStyle = `rgb(${Math.min(255, baseR + 40)}, ${Math.max(0, baseG + 20)}, ${Math.min(255, baseB + 30)})`;
          ctx.fillText(displayText, lx, ly);
          ctx.filter = 'none';
          
          // Main text
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgb(${Math.max(0,Math.min(255,baseR + lineBurst * 25))}, ${Math.max(0,baseG)}, ${Math.min(255,baseB + lineBurst * 15)})`;
          ctx.fillText(displayText, lx, ly);
        });
        ctx.globalAlpha = 1;
        
        // === VHS effects - subtle from start, intensify with chaos ===
        
        // Scanlines - always on, subtle
        ctx.globalAlpha = 0.03 + chaos * 0.12;
        ctx.fillStyle = '#000';
        for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);
        
        // Occasional glitch from start, more frequent with chaos
        if (Math.random() < 0.05 + chaos * 0.5) {
          const sliceCount = 1 + (chaos * 6) | 0;
          for (let i = 0; i < sliceCount; i++) {
            const gy = Math.random() * H | 0;
            const gh = 2 + Math.random() * 6 | 0;
            const shift = ((Math.random() - 0.5) * (8 + chaos * 25)) | 0;
            if (gy + gh < H && gy > 0) {
              try {
                const slice = ctx.getImageData(0, gy, W, gh);
                ctx.putImageData(slice, shift, gy);
              } catch(e) {}
            }
          }
        }
        
        // VHS noise - light from start
        const noiseAmount = 10 + chaos * 70 | 0;
        ctx.globalAlpha = 0.03 + chaos * 0.1;
        for (let i = 0; i < noiseAmount; i++) {
          ctx.fillStyle = `rgb(${Math.random() * 100 | 0}, ${Math.random() * 40 | 0}, ${Math.random() * 200 | 0})`;
          ctx.fillRect(Math.random() * W | 0, Math.random() * H | 0, 1 + Math.random() * 2, 1);
        }
        
        // Flicker overlay - subtle from start
        ctx.globalAlpha = 0.02 + chaos * 0.12 * (0.5 + Math.random() * 0.5);
        ctx.fillStyle = `rgb(${100 + colorLerp * 20}, ${25 + colorLerp * 10}, ${160 + colorLerp * 40})`;
        ctx.fillRect(0, 0, W, H);
        
        ctx.globalAlpha = 1;
        
        requestAnimationFrame(animate);
      };
      
      // Start animation IMMEDIATELY - don't wait for image
      animate();
      img.onload = () => {}; // Image loads in background
      
      return {
        log: addLine,
        hide: () => { running = false; canvas.remove(); }
      };
    })();
    
    window.acBOOT_LOG_CANVAS = (msg) => {
      if (window.acBootCanvas?.log) window.acBootCanvas.log(msg);
    };
  </script>
  <script>
    if (window.self !== window.top) document.body.classList.add("embed");
    // Apply nogap class immediately if parameter is present to prevent flash
    const params = new URLSearchParams(location.search);
    if (params.has("nogap") || location.search.includes("nogap")) {
      document.body.classList.add("nogap");
    }
  </script>
  </body>
</html>