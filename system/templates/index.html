<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>aesthetic.computer</title>
    <script src="/aesthetic.computer/boot.js" type="module" defer></script>
    <!-- Modulepreload hints for critical path modules -->
    <link rel="modulepreload" href="/aesthetic.computer/bios.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/parse.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/disk.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/graph.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/kidlisp.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/num.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/help.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/geo.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/pen.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/keyboard.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/loop.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/store.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/type.mjs">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/aesthetic.computer/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="og:title" content="aesthetic.computer" />
    <meta name="og:description" content="Run any piece by typing its name..." />
    <meta name="og:image" content="https://aesthetic.computer/preview/1200x630" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="aesthetic.computer" />
    <meta name="twitter:site" content="aesthetic.computer" />
    <meta name="twitter:image" content="https://aesthetic.computer/preview/800x800"/>
    <script>
      // Global error handler for fatal boot errors
      window.onerror = function(message, source, lineno, colno, error) {
        // Only show if we haven't booted yet (canvas not present)
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          const sourcePath = source ? source.replace(window.location.origin, '') : 'unknown';
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error</h2>` +
            `<strong style="color:#ffcc66;">${message}</strong>\n\n` +
            `File: ${sourcePath}\n` +
            `Line: ${lineno}, Column: ${colno}\n\n` +
            (error?.stack ? `<span style="color:#888;">${error.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
        return false;
      };
      // Also catch unhandled promise rejections
      window.onunhandledrejection = function(event) {
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error (Promise)</h2>` +
            `<strong style="color:#ffcc66;">${event.reason}</strong>\n\n` +
            (event.reason?.stack ? `<span style="color:#888;">${event.reason.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
      };
    </script>
  </head>
  <body class="native-cursor"> <!-- Hides the 2D UI on first boot. -->
  <!-- Boot Log Overlay - Single Canvas -->
  <canvas id="boot-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;pointer-events:none;margin:0;padding:0;"></canvas>
  <script>
    // üìº VHS Hacker Boot Screen - syntax highlighted code, variable sizes
    window.acBootCanvas = (function() {
      const canvas = document.getElementById('boot-canvas');
      if (!canvas) return {};
      const ctx = canvas.getContext('2d');
      let W = window.innerWidth, H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      window.addEventListener('resize', () => { W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; });
      const logoSize = 64;
      const logoX = 8, logoY = 8;
      const textX = logoX + logoSize + 14;
      const textStartY = 18;
      const lineHeight = 14;
      const maxLines = 18;
      
      // Tiny 16x16 PNG placeholder (loads instantly), then swap to full SVG
      const tinyPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR4nN2Ru0pDQRCGg3fUzk5bEVS0ELxVwQsYTRBvJ5ed3VgZVBB8g1Q+gCDIzq6IluclUktmT1Kk8mWUWT2RTcBep1nmZ//vn53NZP5XOWU3ndTlOIoHe/UE8MxJM8s9SdxuVR9nAnMneph0Up+25esECSwEAGFK3gh4SwIvnDQ5UrgXAN5v7kcJ9HUjWx/iKZwyJ6RsxMkEWPzSTY7A5psVsxaYG+fPYyTNFZ8+qaaHSRjhzcpGrSou+knKdprH70t2Ci+Z7qS56wIAj9M7DPkJskcBIAG96gHKzKdv/X5vkU+/E7B5AtxI4GnBKasSpXf5brBIqulxB/qQjZzO4/uxwe68qZep7l6EXmKNQemv+GIzE5vKHKTL87owpbbCOQK9wj1Jvc59prcSwAqnd6J4hM0pgGGsf9TrA32mACD0Pu/Dp1bNcqJ01gMEFkjYrV/Nf7s+AS1XxDy7PXOrAAAAAElFTkSuQmCC';
      const img = new Image();
      const imgFull = new Image();
      let imgFullLoaded = false;
      img.src = tinyPng; // Instant load
      imgFull.onload = () => { imgFullLoaded = true; };
      imgFull.src = '/purple-pals.svg';
      
      // Boot state
      let lines = [];
      let lineCount = 0;
      let bootProgress = 0;
      let cursorVisible = true;
      let cursorTimer = 0;
      let lastLogTime = performance.now();
      let logBurst = 0;
      const bootStartTime = performance.now();
      
      // Syntax highlighting colors (VSCode dark theme)
      const SYN = {
        kw: [197, 134, 192],   // purple - keywords
        fn: [220, 220, 170],   // yellow - functions
        str: [206, 145, 120],  // orange - strings
        num: [181, 206, 168],  // green - numbers
        cmt: [106, 153, 85],   // dark green - comments
        op: [212, 212, 212],   // white - operators
        tp: [78, 201, 176],    // teal - types
        vr: [156, 220, 254],   // light blue - variables
      };
      
      // Code snippets with syntax tokens [text, colorKey]
      const codeSnippets = [
        [[' const ', 'kw'], ['boot', 'vr'], [' = ', 'op'], ['async', 'kw'], [' () => {', 'op']],
        [['  await ', 'kw'], ['loadSystem', 'fn'], ['();', 'op']],
        [[' import ', 'kw'], ['{ disk }', 'vr'], [' from ', 'kw'], ['"./lib"', 'str'], [';', 'op']],
        [[' function ', 'kw'], ['paint', 'fn'], ['(api) {', 'op']],
        [['  ', 'op'], ['wipe', 'fn'], ['(', 'op'], ['32', 'num'], [');', 'op']],
        [['  ', 'op'], ['ink', 'fn'], ['(', 'op'], ['255', 'num'], [').', 'op'], ['box', 'fn'], ['();', 'op']],
        [[' if ', 'kw'], ['(event.', 'vr'], ['is', 'fn'], ['(', 'op'], ['"touch"', 'str'], ['))', 'op']],
        [[' return ', 'kw'], ['{ boot, act };', 'vr']],
        [[' class ', 'kw'], ['Aesthetic', 'tp'], [' {', 'op']],
        [['  ', 'op'], ['constructor', 'fn'], ['() {}', 'op']],
        [[' }', 'op']],
        [[' // boot sequence', 'cmt']],
        [[' ctx.', 'vr'], ['fillRect', 'fn'], ['(x, y);', 'op']],
        [[' for ', 'kw'], ['(let i=', 'vr'], ['0', 'num'], ['; i<n; i++)', 'op']],
        [[' Promise', 'tp'], ['.all(tasks);', 'op']],
        [[' /* render */', 'cmt']],
      ];
      
      // Single column of code lines
      let codeLines = [];
      const CODE_MAX = 40;
      const CODE_SPEED = 2.5;
      
      let frame = 0;
      let running = true;
      
      // Pre-populate code for instant visual
      for (let i = 0; i < 30; i++) {
        codeLines.push({
          tokens: codeSnippets[Math.random() * codeSnippets.length | 0],
          y: H - i * 18 - Math.random() * 10,
          alpha: 0.2 + Math.random() * 0.4,
          speed: CODE_SPEED + Math.random() * 1.5,
          size: 10 + (Math.random() * 4 | 0)
        });
      }
      
      const addLine = (msg) => {
        const now = performance.now();
        const deltaMs = now - lastLogTime;
        lastLogTime = now;
        
        const speed = Math.min(1, 500 / Math.max(50, deltaMs));
        logBurst = 0.5 + speed * 0.5;
        
        if (lines.length > 0) lines[0].text = lines[0].text.replace(/_$/, '');
        lines.unshift({ text: msg + '_', time: now, burst: logBurst });
        if (lines.length > maxLines) lines.pop();
        
        lineCount++;
        bootProgress = Math.min(1, lineCount / 15);
      };
      
      const animate = () => {
        if (!running || !document.getElementById('boot-canvas')) return;
        
        const t = frame * 0.05;
        frame++;
        cursorTimer++;
        if (cursorTimer % 15 === 0) cursorVisible = !cursorVisible;
        
        logBurst *= 0.9;
        
        // Chaos INCREASES with boot progress
        const chaos = bootProgress + logBurst * 0.5;
        const colorLerp = bootProgress;
        
        // Base shake from the start
        const baseShake = 0.5 + Math.sin(t * 2) * 0.3;
        const shakeAmount = baseShake + chaos * chaos * 5 + logBurst * 4;
        const shakeX = (Math.random() - 0.5) * shakeAmount;
        const shakeY = (Math.random() - 0.5) * shakeAmount;
        
        // Spawn new code lines
        const spawnCount = 1 + (chaos * 1.5) | 0;
        for (let s = 0; s < spawnCount; s++) {
          codeLines.push({
            tokens: codeSnippets[Math.random() * codeSnippets.length | 0],
            y: H + 5,
            alpha: 0.25 + Math.random() * 0.45,
            speed: CODE_SPEED + Math.random() * 1.5 + chaos,
            size: 10 + (Math.random() * 4 | 0)
          });
          if (codeLines.length > CODE_MAX) codeLines.shift();
        }
        
        // Update code positions
        codeLines.forEach(c => c.y -= c.speed);
        codeLines = codeLines.filter(c => c.y > -20);
        
        // === DRAW ===
        ctx.clearRect(0, 0, W, H);
        
        // Draw streaming code with syntax highlighting
        codeLines.forEach(line => {
          if (line.y < 0 || line.y > H) return;
          const codeAlpha = line.alpha * (0.4 + chaos * 0.5);
          ctx.font = `${line.size}px "Courier New", monospace`;
          ctx.globalAlpha = codeAlpha;
          
          // Slight shake
          const codeShake = 0.5 + chaos * 2;
          const baseX = 10 + (Math.random() - 0.5) * codeShake;
          const y = line.y + (Math.random() - 0.5) * codeShake;
          
          // Draw each token
          let xOff = 0;
          line.tokens.forEach(([text, colorKey]) => {
            const [r, g, b] = SYN[colorKey] || SYN.op;
            ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            ctx.fillText(text, baseX + xOff, y);
            xOff += ctx.measureText(text).width;
          });
        });
        ctx.globalAlpha = 1;
        
        // Draw logo with ghosting trails and color tinting
        const logoShake = baseShake * 0.8 + chaos * chaos * 3;
        ctx.imageSmoothingEnabled = imgFullLoaded;
        const logoImg = imgFullLoaded ? imgFull : img;
        const lx = logoX + shakeX * 0.5;
        const ly = logoY + shakeY * 0.5;
        
        // Ghost trails - draw multiple offset copies with decreasing alpha
        const trailCount = 3 + (chaos * 4) | 0;
        for (let tr = trailCount; tr >= 0; tr--) {
          const trailAlpha = tr === 0 ? 1 : (0.15 + chaos * 0.2) * (1 - tr / trailCount);
          const trailOffset = tr * (2 + chaos * 4);
          const trailShake = logoShake * (1 + tr * 0.5);
          
          ctx.globalAlpha = trailAlpha;
          
          // Color tint overlay for trails
          if (tr > 0) {
            // Draw tinted version - use hue shift for chromatic aberration
            const hueShift = tr * 15 * (Math.random() > 0.5 ? 1 : -1);
            ctx.filter = `hue-rotate(${hueShift}deg) saturate(${1.5 + chaos})`;
          }
          
          ctx.drawImage(logoImg,
            lx + (Math.random() - 0.5) * trailShake - trailOffset * 0.3,
            ly + (Math.random() - 0.5) * trailShake + trailOffset * 0.2,
            logoSize, logoSize);
          
          ctx.filter = 'none';
        }
        
        // Main logo with purple/magenta tint overlay
        ctx.globalAlpha = 0.3 + chaos * 0.4;
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = `rgb(${180 + chaos * 40 | 0}, ${80 + chaos * 30 | 0}, ${200 + chaos * 30 | 0})`;
        ctx.fillRect(lx - 2, ly - 2, logoSize + 4, logoSize + 4);
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.imageSmoothingEnabled = true;
        
        // Live ms timer under logo
        const elapsedMs = performance.now() - bootStartTime;
        ctx.font = 'bold 10px "Courier New", monospace';
        const timerStr = (elapsedMs | 0).toString().padStart(5, '0') + 'ms';
        const timerR = 80 + chaos * 120 | 0;
        const timerG = 80 + chaos * 40 | 0;
        const timerB = 100 + chaos * 100 | 0;
        ctx.globalAlpha = 0.6 + chaos * 0.4;
        ctx.fillStyle = `rgb(${timerR}, ${timerG}, ${timerB})`;
        const timerShake = baseShake + chaos * 2;
        ctx.fillText(timerStr, logoX + 4 + shakeX * 0.5 + (Math.random() - 0.5) * timerShake, logoY + logoSize + 14 + shakeY * 0.5 + (Math.random() - 0.5) * timerShake);
        ctx.globalAlpha = 1;
        
        // Draw log text
        ctx.font = '12px "Courier New", monospace';
        const now = performance.now();
        lines.forEach((line, i) => {
          const y = textStartY + i * lineHeight;
          if (y > H - 10) return;
          
          const age = i * 0.08;
          const alpha = Math.max(0.25, 1 - age * 0.6);
          const lineAge = (now - line.time) / 1000;
          const lineBurst = Math.max(0, line.burst - lineAge * 2);
          
          let displayText = line.text;
          if (i === 0 && !cursorVisible) displayText = displayText.replace(/_$/, ' ');
          
          // Shake from start, more with chaos
          const lineShake = baseShake * 0.5 + lineBurst * 3 + chaos * 1.5;
          const lx = textX + shakeX + (Math.random() - 0.5) * lineShake;
          const ly = y + shakeY + (Math.random() - 0.5) * lineShake;
          
          // Colors: pink ‚Üí noise16Aesthetic purple
          const baseR = 200 - colorLerp * 100 - i * 5;
          const baseG = 80 - colorLerp * 55 - i * 4;
          const baseB = 140 + colorLerp * 60 - i * 2;
          
          // Chromatic aberration / RGB split ghost trails
          const aberration = 1 + chaos * 3 + lineBurst * 2;
          if (aberration > 1.5) {
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = `rgb(255, 50, 100)`; // Red channel
            ctx.fillText(displayText, lx - aberration, ly);
            ctx.fillStyle = `rgb(50, 255, 150)`; // Green channel  
            ctx.fillText(displayText, lx + aberration * 0.5, ly - aberration * 0.3);
            ctx.fillStyle = `rgb(100, 100, 255)`; // Blue channel
            ctx.fillText(displayText, lx + aberration * 0.3, ly + aberration * 0.5);
          }
          
          // Subtle glow from start, stronger with chaos
          ctx.globalAlpha = alpha * (0.15 + chaos * 0.25 + lineBurst * 0.3);
          ctx.filter = `blur(${2 + chaos * 3}px)`;
          ctx.fillStyle = `rgb(${Math.min(255, baseR + 40)}, ${Math.max(0, baseG + 20)}, ${Math.min(255, baseB + 30)})`;
          ctx.fillText(displayText, lx, ly);
          ctx.filter = 'none';
          
          // Main text
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgb(${Math.max(0,Math.min(255,baseR + lineBurst * 25))}, ${Math.max(0,baseG)}, ${Math.min(255,baseB + lineBurst * 15)})`;
          ctx.fillText(displayText, lx, ly);
        });
        ctx.globalAlpha = 1;
        
        // === VHS effects - subtle from start, intensify with chaos ===
        
        // Scanlines - always on, subtle
        ctx.globalAlpha = 0.03 + chaos * 0.12;
        ctx.fillStyle = '#000';
        for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);
        
        // Occasional glitch from start, more frequent with chaos
        if (Math.random() < 0.05 + chaos * 0.5) {
          const sliceCount = 1 + (chaos * 6) | 0;
          for (let i = 0; i < sliceCount; i++) {
            const gy = Math.random() * H | 0;
            const gh = 2 + Math.random() * 6 | 0;
            const shift = ((Math.random() - 0.5) * (8 + chaos * 25)) | 0;
            if (gy + gh < H && gy > 0) {
              try {
                const slice = ctx.getImageData(0, gy, W, gh);
                ctx.putImageData(slice, shift, gy);
              } catch(e) {}
            }
          }
        }
        
        // VHS noise - light from start
        const noiseAmount = 10 + chaos * 70 | 0;
        ctx.globalAlpha = 0.03 + chaos * 0.1;
        for (let i = 0; i < noiseAmount; i++) {
          ctx.fillStyle = `rgb(${Math.random() * 100 | 0}, ${Math.random() * 40 | 0}, ${Math.random() * 200 | 0})`;
          ctx.fillRect(Math.random() * W | 0, Math.random() * H | 0, 1 + Math.random() * 2, 1);
        }
        
        // Flicker overlay - subtle from start
        ctx.globalAlpha = 0.02 + chaos * 0.12 * (0.5 + Math.random() * 0.5);
        ctx.fillStyle = `rgb(${100 + colorLerp * 20}, ${25 + colorLerp * 10}, ${160 + colorLerp * 40})`;
        ctx.fillRect(0, 0, W, H);
        
        ctx.globalAlpha = 1;
        
        requestAnimationFrame(animate);
      };
      
      // Start animation IMMEDIATELY - don't wait for image
      animate();
      img.onload = () => {}; // Image loads in background
      
      return {
        log: addLine,
        hide: () => { running = false; canvas.remove(); }
      };
    })();
    
    window.acBOOT_LOG_CANVAS = (msg) => {
      if (window.acBootCanvas?.log) window.acBootCanvas.log(msg);
    };
  </script>
  <script>
    if (window.self !== window.top) document.body.classList.add("embed");
    // Apply nogap class immediately if parameter is present to prevent flash
    const params = new URLSearchParams(location.search);
    if (params.has("nogap") || location.search.includes("nogap")) {
      document.body.classList.add("nogap");
    }
  </script>
  </body>
</html>