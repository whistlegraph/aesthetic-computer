<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>aesthetic.computer</title>
    <script src="/aesthetic.computer/boot.js" type="module" defer></script>
    <!-- Modulepreload hints for critical path modules -->
    <link rel="modulepreload" href="/aesthetic.computer/bios.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/parse.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/disk.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/graph.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/kidlisp.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/num.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/help.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/geo.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/pen.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/keyboard.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/loop.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/store.mjs">
    <link rel="modulepreload" href="/aesthetic.computer/lib/type.mjs">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="/aesthetic.computer/style.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="og:title" content="aesthetic.computer" />
    <meta name="og:description" content="Run any piece by typing its name..." />
    <meta name="og:image" content="https://aesthetic.computer/preview/1200x630" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="aesthetic.computer" />
    <meta name="twitter:site" content="aesthetic.computer" />
    <meta name="twitter:image" content="https://aesthetic.computer/preview/800x800"/>
    <script>
      // Global error handler for fatal boot errors
      window.onerror = function(message, source, lineno, colno, error) {
        // Only show if we haven't booted yet (canvas not present)
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          const sourcePath = source ? source.replace(window.location.origin, '') : 'unknown';
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error</h2>` +
            `<strong style="color:#ffcc66;">${message}</strong>\n\n` +
            `File: ${sourcePath}\n` +
            `Line: ${lineno}, Column: ${colno}\n\n` +
            (error?.stack ? `<span style="color:#888;">${error.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
        return false;
      };
      // Also catch unhandled promise rejections
      window.onunhandledrejection = function(event) {
        if (!document.querySelector('canvas')) {
          const errorDiv = document.createElement('div');
          errorDiv.id = 'boot-error';
          errorDiv.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: #111; color: #f88; padding: 2rem;
            font-family: monospace; font-size: 14px; white-space: pre-wrap;
            overflow: auto; z-index: 99999;
          `;
          errorDiv.innerHTML = `<h2 style="color:#ff6666;margin:0 0 1rem 0;">‚ö†Ô∏è Boot Error (Promise)</h2>` +
            `<strong style="color:#ffcc66;">${event.reason}</strong>\n\n` +
            (event.reason?.stack ? `<span style="color:#888;">${event.reason.stack}</span>` : '') +
            `\n\n<span style="color:#666;">Check the browser console (F12) for more details.</span>`;
          document.body.appendChild(errorDiv);
        }
      };
    </script>
  </head>
  <body class="native-cursor"> <!-- Hides the 2D UI on first boot. -->
  <!-- Boot Log Overlay - Single Canvas -->
  <canvas id="boot-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:99999;pointer-events:none;margin:0;padding:0;"></canvas>
  <script>
    // üìº File Block Boot Screen - actual source files scroll up as they load
    window.acBootCanvas = (function() {
      const canvas = document.getElementById('boot-canvas');
      if (!canvas) return {};
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      let W = window.innerWidth, H = window.innerHeight;
      canvas.width = W; canvas.height = H;
      window.addEventListener('resize', () => { W = window.innerWidth; H = window.innerHeight; canvas.width = W; canvas.height = H; });
      const logoSize = 64;
      const logoX = 8, logoY = 8;
      const textX = logoX + logoSize + 14;
      const textStartY = 18;
      const lineHeight = 14;
      const maxLines = 18;
      
      // Tiny 16x16 PNG placeholder (loads instantly), then swap to full SVG
      const tinyPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR4nN2Ru0pDQRCGg3fUzk5bEVS0ELxVwQsYTRBvJ5ed3VgZVBB8g1Q+gCDIzq6IluclUktmT1Kk8mWUWT2RTcBep1nmZ//vn53NZP5XOWU3ndTlOIoHe/UE8MxJM8s9SdxuVR9nAnMneph0Up+25esECSwEAGFK3gh4SwIvnDQ5UrgXAN5v7kcJ9HUjWx/iKZwyJ6RsxMkEWPzSTY7A5psVsxaYG+fPYyTNFZ8+qaaHSRjhzcpGrSou+knKdprH70t2Ci+Z7qS56wIAj9M7DPkJskcBIAG96gHKzKdv/X5vkU+/E7B5AtxI4GnBKasSpXf5brBIqulxB/qQjZzO4/uxwe68qZep7l6EXmKNQemv+GIzE5vKHKTL87owpbbCOQK9wj1Jvc59prcSwAqnd6J4hM0pgGGsf9TrA32mACD0Pu/Dp1bNcqJ01gMEFkjYrV/Nf7s+AS1XxDy7PXOrAAAAAElFTkSuQmCC';
      const img = new Image();
      const imgFull = new Image();
      let imgFullLoaded = false;
      img.src = tinyPng; // Instant load
      imgFull.onload = () => { imgFullLoaded = true; };
      imgFull.src = '/purple-pals.svg';
      
      // Boot state
      let lines = [];
      let lineCount = 0;
      let bootProgress = 0;
      let cursorVisible = true;
      let cursorTimer = 0;
      let lastLogTime = performance.now();
      let logBurst = 0;
      const bootStartTime = performance.now();
      
      // User handle display
      let userHandle = null;
      let handleShowTime = 0;
      
      // Syntax highlighting colors (VSCode dark theme)
      const SYN = {
        kw: [197, 134, 192],   // purple - keywords
        fn: [220, 220, 170],   // yellow - functions
        str: [206, 145, 120],  // orange - strings
        num: [181, 206, 168],  // green - numbers
        cmt: [106, 153, 85],   // dark green - comments
        op: [212, 212, 212],   // white - operators
        tp: [78, 201, 176],    // teal - types
        vr: [156, 220, 254],   // light blue - variables
      };
      
      // File block colors (unique per file)
      const FILE_COLORS = [
        { bg: [20, 10, 30], border: [100, 60, 140], text: [180, 140, 220] },   // purple
        { bg: [10, 20, 35], border: [50, 100, 140], text: [140, 180, 220] },   // blue
        { bg: [25, 25, 10], border: [100, 100, 50], text: [200, 200, 140] },   // yellow
        { bg: [35, 15, 20], border: [140, 70, 90], text: [220, 160, 180] },    // pink
        { bg: [15, 30, 20], border: [60, 120, 80], text: [160, 220, 180] },    // green
        { bg: [30, 20, 10], border: [120, 85, 50], text: [220, 185, 140] },    // orange
      ];
      
      // Constants for file block layout - FULL PAGE style
      const CHAR_WIDTH = 5.5;    // Monospace char width at 9px font
      const COL_WIDTH = 80;      // 80 char column
      const BLOCK_PADDING = 12;  // Padding inside block
      const LINE_HEIGHT_CODE = 11; // Line height for code
      const HEADER_HEIGHT = 24;  // Space for filename
      const PAGE_MARGIN = 20;    // Margin around page
      
      // File blocks - displayed one at a time, scrolling up
      let fileBlocks = [];
      let currentFileIndex = 0;  // Which file is currently displayed
      let scrollOffset = 0;      // How far current file has scrolled
      let fileColorIndex = 0;
      
      // Queue of files waiting to display
      let fileQueue = [];
      
      let frame = 0;
      let running = true;
      
      // Simple syntax highlighter for source code
      function tokenizeLine(line) {
        const tokens = [];
        const keywords = /\b(import|export|from|const|let|var|function|async|await|return|if|else|for|while|class|this|new|try|catch|throw|true|false|null|undefined)\b/g;
        const strings = /(["'`])(?:(?!\1)[^\\]|\\.)*?\1/g;
        const numbers = /\b\d+\.?\d*\b/g;
        const comments = /\/\/.*$|\/\*[\s\S]*?\*\//g;
        const functions = /\b([a-zA-Z_]\w*)\s*(?=\()/g;
        
        let remaining = line;
        let pos = 0;
        
        // Simple token extraction
        while (remaining.length > 0) {
          let match = null;
          let type = 'op';
          let earliest = remaining.length;
          
          // Find comments first
          const cmtMatch = remaining.match(/^(\/\/.*|\/\*[\s\S]*?\*\/)/);
          if (cmtMatch) {
            tokens.push([cmtMatch[0], 'cmt']);
            remaining = remaining.slice(cmtMatch[0].length);
            continue;
          }
          
          // Find strings
          const strMatch = remaining.match(/^(["'`])(?:(?!\1)[^\\]|\\.)*?\1/);
          if (strMatch) {
            tokens.push([strMatch[0], 'str']);
            remaining = remaining.slice(strMatch[0].length);
            continue;
          }
          
          // Find keywords
          const kwMatch = remaining.match(/^(import|export|from|const|let|var|function|async|await|return|if|else|for|while|class|this|new|try|catch|throw|true|false|null|undefined)\b/);
          if (kwMatch) {
            tokens.push([kwMatch[0], 'kw']);
            remaining = remaining.slice(kwMatch[0].length);
            continue;
          }
          
          // Find numbers
          const numMatch = remaining.match(/^\d+\.?\d*/);
          if (numMatch) {
            tokens.push([numMatch[0], 'num']);
            remaining = remaining.slice(numMatch[0].length);
            continue;
          }
          
          // Find function calls
          const fnMatch = remaining.match(/^([a-zA-Z_]\w*)\s*(?=\()/);
          if (fnMatch) {
            tokens.push([fnMatch[1], 'fn']);
            remaining = remaining.slice(fnMatch[1].length);
            continue;
          }
          
          // Find identifiers (variables/types)
          const idMatch = remaining.match(/^[a-zA-Z_]\w*/);
          if (idMatch) {
            const isType = idMatch[0][0] === idMatch[0][0].toUpperCase();
            tokens.push([idMatch[0], isType ? 'tp' : 'vr']);
            remaining = remaining.slice(idMatch[0].length);
            continue;
          }
          
          // Whitespace and operators
          const wsMatch = remaining.match(/^(\s+|[^\s\w]+)/);
          if (wsMatch) {
            tokens.push([wsMatch[0], 'op']);
            remaining = remaining.slice(wsMatch[0].length);
            continue;
          }
          
          // Fallback: single char
          tokens.push([remaining[0], 'op']);
          remaining = remaining.slice(1);
        }
        
        return tokens;
      }
      
      // Create a file block from source content
      function createFileBlock(filename, content) {
        const allLines = content.split('\n');
        const maxLines = Math.floor((H - PAGE_MARGIN * 2 - HEADER_HEIGHT) / LINE_HEIGHT_CODE);
        const lines = allLines.slice(0, Math.min(allLines.length, maxLines));
        const tokenizedLines = lines.map(l => tokenizeLine(l.slice(0, COL_WIDTH)));
        const color = FILE_COLORS[fileColorIndex % FILE_COLORS.length];
        fileColorIndex++;
        
        // Calculate actual height needed
        const contentHeight = lines.length * LINE_HEIGHT_CODE;
        const totalHeight = contentHeight + HEADER_HEIGHT + BLOCK_PADDING * 2;
        
        return {
          filename,
          lines: tokenizedLines,
          totalLines: allLines.length,
          contentHeight,
          totalHeight,
          color,
          spawnTime: performance.now(),
          scrollY: 0,  // Internal scroll within this file
        };
      }
      
      // Add a file to display (called by boot.mjs)
      const addFile = (filename, content) => {
        if (!content || typeof content !== 'string') return;
        const block = createFileBlock(filename, content);
        fileBlocks.push(block);
        bootProgress = Math.min(1, fileBlocks.length / 6);
      };
      
      const addLine = (msg) => {
        const now = performance.now();
        const deltaMs = now - lastLogTime;
        lastLogTime = now;
        
        const speed = Math.min(1, 500 / Math.max(50, deltaMs));
        logBurst = 0.5 + speed * 0.5;
        
        if (lines.length > 0) lines[0].text = lines[0].text.replace(/_$/, '');
        lines.unshift({ text: msg + '_', time: now, burst: logBurst });
        if (lines.length > maxLines) lines.pop();
        
        lineCount++;
        bootProgress = Math.min(1, lineCount / 15);
      };
      
      const setHandle = (h) => {
        userHandle = h;
        handleShowTime = performance.now();
      };
      
      const animate = () => {
        if (!running || !document.getElementById('boot-canvas')) return;
        
        const t = frame * 0.05;
        frame++;
        cursorTimer++;
        if (cursorTimer % 15 === 0) cursorVisible = !cursorVisible;
        
        logBurst *= 0.9;
        
        // Chaos INCREASES with boot progress - start clear, get glitchier
        const chaos = bootProgress + logBurst * 0.5;
        const colorLerp = bootProgress;
        
        // Base shake - very subtle
        const baseShake = 0.2 + Math.sin(t * 2) * 0.1;
        const shakeAmount = baseShake + chaos * 0.5;
        const shakeX = (Math.random() - 0.5) * shakeAmount;
        const shakeY = (Math.random() - 0.5) * shakeAmount;
        
        // Scroll current file up, advance to next when done
        if (fileBlocks.length > 0 && currentFileIndex < fileBlocks.length) {
          scrollOffset += 2.0; // Scroll speed
          const currentBlock = fileBlocks[currentFileIndex];
          // Move to next file when current one is mostly scrolled
          if (scrollOffset > currentBlock.totalHeight + 50) {
            currentFileIndex++;
            scrollOffset = 0;
          }
        }
        
        // === DRAW ===
        ctx.clearRect(0, 0, W, H);
        
        // Calculate page dimensions - full width minus margins
        const pageWidth = Math.min(W - PAGE_MARGIN * 2, COL_WIDTH * CHAR_WIDTH + BLOCK_PADDING * 2);
        const pageX = (W - pageWidth) / 2;
        const pageTop = PAGE_MARGIN;
        const pageHeight = H - PAGE_MARGIN * 2;
        
        // Draw current file as a full-page "document"
        if (fileBlocks.length > 0 && currentFileIndex < fileBlocks.length) {
          const block = fileBlocks[currentFileIndex];
          const { bg, border, text } = block.color;
          const age = (performance.now() - block.spawnTime) / 1000;
          const fadeIn = Math.min(1, age * 2);
          
          // Page background - full screen rectangle
          ctx.globalAlpha = fadeIn * 0.92;
          const grad = ctx.createLinearGradient(pageX, pageTop, pageX + pageWidth, pageTop + pageHeight);
          grad.addColorStop(0, `rgb(${bg[0]}, ${bg[1]}, ${bg[2]})`);
          grad.addColorStop(1, `rgb(${bg[0] + 8}, ${bg[1] + 4}, ${bg[2] + 12})`);
          ctx.fillStyle = grad;
          ctx.fillRect(pageX, pageTop, pageWidth, pageHeight);
          
          // Page border - crisp lines
          ctx.globalAlpha = fadeIn * 0.8;
          ctx.strokeStyle = `rgb(${border[0]}, ${border[1]}, ${border[2]})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(pageX, pageTop, pageWidth, pageHeight);
          
          // Inner border for "page" feel
          ctx.globalAlpha = fadeIn * 0.3;
          ctx.lineWidth = 1;
          ctx.strokeRect(pageX + 4, pageTop + 4, pageWidth - 8, pageHeight - 8);
          
          // Filename header bar
          ctx.globalAlpha = fadeIn * 0.95;
          ctx.fillStyle = `rgba(${border[0]}, ${border[1]}, ${border[2]}, 0.4)`;
          ctx.fillRect(pageX, pageTop, pageWidth, HEADER_HEIGHT);
          
          // Filename text
          ctx.font = 'bold 11px "Courier New", monospace';
          ctx.fillStyle = `rgb(${text[0]}, ${text[1]}, ${text[2]})`;
          const displayName = block.filename.length > 60 ? '...' + block.filename.slice(-57) : block.filename;
          ctx.fillText(displayName, pageX + BLOCK_PADDING, pageTop + 16);
          
          // Line count badge
          ctx.font = '9px "Courier New", monospace';
          ctx.globalAlpha = fadeIn * 0.6;
          ctx.fillText(`${block.totalLines} lines`, pageX + pageWidth - 70, pageTop + 16);
          
          // Source code - scrolling within the page
          ctx.save();
          ctx.beginPath();
          ctx.rect(pageX, pageTop + HEADER_HEIGHT, pageWidth, pageHeight - HEADER_HEIGHT);
          ctx.clip();
          
          ctx.font = '9px "Courier New", monospace';
          const codeStartY = pageTop + HEADER_HEIGHT + BLOCK_PADDING - scrollOffset;
          
          for (let i = 0; i < block.lines.length; i++) {
            const lineY = codeStartY + i * LINE_HEIGHT_CODE;
            // Skip lines outside visible area
            if (lineY < pageTop + HEADER_HEIGHT - LINE_HEIGHT_CODE) continue;
            if (lineY > pageTop + pageHeight) break;
            
            const tokens = block.lines[i];
            let xOff = pageX + BLOCK_PADDING;
            
            // Line number (dim)
            ctx.globalAlpha = fadeIn * 0.3;
            ctx.fillStyle = `rgb(${text[0]}, ${text[1]}, ${text[2]})`;
            const lineNum = String(i + 1).padStart(3, ' ');
            ctx.fillText(lineNum, xOff, lineY);
            xOff += 28;
            
            // Vertical separator
            ctx.globalAlpha = fadeIn * 0.15;
            ctx.fillRect(xOff - 4, lineY - 8, 1, LINE_HEIGHT_CODE);
            
            // Code tokens with syntax highlighting
            ctx.globalAlpha = fadeIn * 0.85;
            tokens.forEach(([tokenText, colorKey]) => {
              const [r, g, b] = SYN[colorKey] || SYN.op;
              ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
              ctx.fillText(tokenText, xOff, lineY);
              xOff += ctx.measureText(tokenText).width;
            });
          }
          
          ctx.restore();
          
          // Scroll progress bar at bottom
          const scrollProgress = scrollOffset / (block.totalHeight + 50);
          ctx.globalAlpha = fadeIn * 0.5;
          ctx.fillStyle = `rgb(${border[0]}, ${border[1]}, ${border[2]})`;
          ctx.fillRect(pageX, pageTop + pageHeight - 3, pageWidth * Math.min(1, scrollProgress), 3);
        }
        ctx.globalAlpha = 1;
        
        // Draw logo with subtle effects
        ctx.imageSmoothingEnabled = imgFullLoaded;
        const logoImg = imgFullLoaded ? imgFull : img;
        const lx = logoX + shakeX * 0.3;
        const ly = logoY + shakeY * 0.3;
        
        // Subtle glow
        ctx.globalAlpha = 0.3;
        ctx.filter = 'blur(8px)';
        ctx.drawImage(logoImg, lx - 4, ly - 4, logoSize + 8, logoSize + 8);
        ctx.filter = 'none';
        
        // Main logo
        ctx.globalAlpha = 0.9;
        ctx.drawImage(logoImg, lx, ly, logoSize, logoSize);
        ctx.globalAlpha = 1;
        
        // Live ms timer under logo
        const elapsedMs = performance.now() - bootStartTime;
        ctx.font = 'bold 10px "Courier New", monospace';
        const timerStr = (elapsedMs | 0).toString().padStart(5, '0') + 'ms';
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = `rgb(${100 + chaos * 80 | 0}, ${80}, ${140 + chaos * 60 | 0})`;
        ctx.fillText(timerStr, logoX + 4, logoY + logoSize + 14);
        ctx.globalAlpha = 1;
        
        // User handle display
        if (userHandle) {
          const handleAge = (performance.now() - handleShowTime) / 1000;
          const handleFade = Math.min(1, handleAge * 2);
          
          ctx.font = 'bold 14px "Courier New", monospace';
          ctx.globalAlpha = handleFade * 0.9;
          ctx.fillStyle = '#c084fc';
          ctx.fillText(userHandle, logoX + 4, logoY + logoSize + 30);
        }
        
        // Draw log text (status messages)
        ctx.font = '11px "Courier New", monospace';
        const now = performance.now();
        lines.forEach((line, i) => {
          const y = textStartY + i * lineHeight;
          if (y > H - 10) return;
          
          const age = i * 0.1;
          const alpha = Math.max(0.2, 1 - age * 0.5);
          
          let displayText = line.text;
          if (i === 0 && !cursorVisible) displayText = displayText.replace(/_$/, ' ');
          
          const lx = textX + shakeX * 0.5;
          const ly = y + shakeY * 0.5;
          
          // Simple colored text
          const baseR = 180 - colorLerp * 60 - i * 4;
          const baseG = 100 - colorLerp * 40 - i * 3;
          const baseB = 180 + colorLerp * 40 - i * 2;
          
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgb(${Math.max(0,Math.min(255,baseR | 0))}, ${Math.max(0,baseG | 0)}, ${Math.min(255,baseB | 0)})`;
          ctx.fillText(displayText, lx, ly);
        });
        ctx.globalAlpha = 1;
        
        // Subtle scanlines
        ctx.globalAlpha = 0.03 + chaos * 0.05;
        ctx.fillStyle = '#000';
        for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);
        ctx.globalAlpha = 1;
        
        requestAnimationFrame(animate);
      };
      
      // Start animation IMMEDIATELY
      animate();
      img.onload = () => {};
      
      return {
        log: addLine,
        hide: () => { running = false; canvas.remove(); },
        setHandle: setHandle,
        addFile: addFile  // New: add a file block
      };
    })();
    
    window.acBOOT_LOG_CANVAS = (msg) => {
      if (window.acBootCanvas?.log) window.acBootCanvas.log(msg);
    };
    
    // Expose addFile for boot.mjs
    window.acBOOT_ADD_FILE = (filename, content) => {
      if (window.acBootCanvas?.addFile) window.acBootCanvas.addFile(filename, content);
    };
  </script>
  <script>
    if (window.self !== window.top) document.body.classList.add("embed");
    // Apply nogap class immediately if parameter is present to prevent flash
    const params = new URLSearchParams(location.search);
    if (params.has("nogap") || location.search.includes("nogap")) {
      document.body.classList.add("nogap");
    }
  </script>
  </body>
</html>